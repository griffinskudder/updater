# Admin Key Management Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace config-file API key management with storage-backed CRUD endpoints at `/api/v1/admin/keys`, seeding a single bootstrap key from config on first startup.

**Architecture:** New `models.APIKey` model stores a SHA-256 hash of the raw key; five new `Storage` interface methods fan out to all four backends; auth middleware switches from iterating config memory to querying storage by hash; four new REST endpoints plus admin UI pages complete the surface.

**Tech Stack:** Go 1.25, `crypto/sha256`, `encoding/hex`, `github.com/google/uuid`, `crypto/rand`, `encoding/base64`; all existing storage backends; gorilla/mux; HTMX admin templates.

**Design doc:** `docs/plans/2026-02-16-admin-key-management-design.md`

---

### Task 1: New `APIKey` model and key helpers

**Files:**
- Create: `internal/models/api_key.go`
- Modify: `internal/models/config.go`
- Create: `internal/models/api_key_test.go`

**Context:** The current `APIKey` struct in `config.go` stores the raw key value. We are replacing it with a model that stores a SHA-256 hash and a display prefix. The raw key is generated by a helper and returned to the caller only once.

**Step 1: Write the failing test**

```go
// internal/models/api_key_test.go
package models_test

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateAPIKey(t *testing.T) {
	key, err := models.GenerateAPIKey()
	require.NoError(t, err)
	assert.True(t, strings.HasPrefix(key, "upd_"), "key must start with upd_")
	assert.Len(t, key, 48, "upd_ (4) + 44 base64url chars = 48")
}

func TestHashAPIKey(t *testing.T) {
	hash1 := models.HashAPIKey("upd_abc123")
	hash2 := models.HashAPIKey("upd_abc123")
	hash3 := models.HashAPIKey("upd_different")
	assert.Equal(t, hash1, hash2, "same input must produce same hash")
	assert.NotEqual(t, hash1, hash3, "different inputs must produce different hashes")
	assert.Len(t, hash1, 64, "SHA-256 hex is 64 characters")
}

func TestAPIKeyHasPermission(t *testing.T) {
	tests := []struct {
		name        string
		permissions []string
		check       string
		want        bool
	}{
		{"admin grants all", []string{"admin"}, "read", true},
		{"admin grants write", []string{"admin"}, "write", true},
		{"write grants read", []string{"write"}, "read", true},
		{"write denied admin", []string{"write"}, "admin", false},
		{"read only", []string{"read"}, "read", true},
		{"read denied write", []string{"read"}, "write", false},
		{"wildcard grants all", []string{"*"}, "admin", true},
		{"disabled key denied", []string{"admin"}, "read", false}, // Enabled: false tested separately
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			key := &models.APIKey{Permissions: tt.permissions, Enabled: true}
			if tt.name == "disabled key denied" {
				key.Enabled = false
			}
			assert.Equal(t, tt.want, key.HasPermission(tt.check))
		})
	}
}
```

**Step 2: Run test to verify it fails**

```
make test
```

Expected: FAIL — `models.GenerateAPIKey`, `models.HashAPIKey`, new `models.APIKey` not defined.

**Step 3: Create `internal/models/api_key.go`**

```go
package models

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// APIKey represents a stored API key. The raw key value is never persisted;
// only its SHA-256 hex hash and an 8-character display prefix are stored.
type APIKey struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	KeyHash     string    `json:"key_hash"`
	Prefix      string    `json:"prefix"`
	Permissions []string  `json:"permissions"`
	Enabled     bool      `json:"enabled"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// NewAPIKey creates a new APIKey from a raw key string.
// The raw key is not stored; call GenerateAPIKey to produce one.
func NewAPIKey(id, name, rawKey string, permissions []string) *APIKey {
	now := time.Now().UTC()
	prefix := rawKey
	if len(prefix) > 8 {
		prefix = prefix[:8]
	}
	return &APIKey{
		ID:          id,
		Name:        name,
		KeyHash:     HashAPIKey(rawKey),
		Prefix:      prefix,
		Permissions: permissions,
		Enabled:     true,
		CreatedAt:   now,
		UpdatedAt:   now,
	}
}

// GenerateAPIKey produces a new random API key in the format upd_<32 url-safe base64 chars>.
// The caller is responsible for hashing before storage.
func GenerateAPIKey() (string, error) {
	b := make([]byte, 33) // 33 bytes → 44 base64url chars
	if _, err := rand.Read(b); err != nil {
		return "", fmt.Errorf("generate api key: %w", err)
	}
	return "upd_" + base64.RawURLEncoding.EncodeToString(b), nil
}

// HashAPIKey computes the SHA-256 hex digest of a raw API key.
func HashAPIKey(rawKey string) string {
	sum := sha256.Sum256([]byte(rawKey))
	return hex.EncodeToString(sum[:])
}

// NewKeyID generates a new UUID v4 for use as an APIKey ID.
func NewKeyID() string {
	return uuid.New().String()
}

// HasPermission returns true when the key is enabled and possesses the required permission.
// The admin permission and the wildcard "*" grant all access; write implies read.
func (ak *APIKey) HasPermission(required string) bool {
	if !ak.Enabled {
		return false
	}
	for _, p := range ak.Permissions {
		switch p {
		case "*", "admin":
			return true
		case "write":
			if required == "read" || required == "write" {
				return true
			}
		case required:
			return true
		}
	}
	return false
}
```

**Step 4: Update `internal/models/config.go`**

Replace the `SecurityConfig` struct and the old `APIKey` struct + `HasPermission` method. The `APIKey` struct is now in `api_key.go`; `SecurityConfig` gains `BootstrapKey` and loses `APIKeys []APIKey`.

Find and replace in `config.go`:

```go
// OLD (lines 88-101)
type SecurityConfig struct {
	APIKeys        []APIKey        `yaml:"api_keys" json:"api_keys"`
	RateLimit      RateLimitConfig `yaml:"rate_limit" json:"rate_limit"`
	JWTSecret      string          `yaml:"jwt_secret" json:"jwt_secret"`
	EnableAuth     bool            `yaml:"enable_auth" json:"enable_auth"`
	TrustedProxies []string        `yaml:"trusted_proxies" json:"trusted_proxies"`
}

type APIKey struct {
	Key         string   `yaml:"key" json:"key"`
	Name        string   `yaml:"name" json:"name"`
	Permissions []string `yaml:"permissions" json:"permissions"`
	Enabled     bool     `yaml:"enabled" json:"enabled"`
}
```

```go
// NEW
type SecurityConfig struct {
	BootstrapKey   string          `yaml:"bootstrap_key" json:"bootstrap_key"`
	RateLimit      RateLimitConfig `yaml:"rate_limit" json:"rate_limit"`
	JWTSecret      string          `yaml:"jwt_secret" json:"jwt_secret"`
	EnableAuth     bool            `yaml:"enable_auth" json:"enable_auth"`
	TrustedProxies []string        `yaml:"trusted_proxies" json:"trusted_proxies"`
}
```

Also remove the old `HasPermission` method at the bottom of `config.go` (lines 494-504), since it now lives in `api_key.go`.

Also update `NewDefaultConfig` — remove `APIKeys: []APIKey{}` from the Security section.

Also update `SecurityConfig.Validate()` — remove the loop that validates `sec.APIKeys`.

**Step 5: Run tests**

```
make test
```

Expected: PASS. (There may be compile errors in other packages that reference the old `APIKey.Key` field — those are fixed in later tasks.)

**Step 6: Commit**

```
git add internal/models/api_key.go internal/models/api_key_test.go internal/models/config.go
git commit -m "feat(models): add APIKey model with SHA-256 hashing helpers"
```

---

### Task 2: Extend the Storage interface

**Files:**
- Modify: `internal/storage/interface.go`

**Context:** Five new methods must be added to the `Storage` interface. All four backends (memory, JSON, SQLite, PostgreSQL) and the `InstrumentedStorage` wrapper in `observability` must implement them. Add the interface methods first so the compiler guides the remaining work.

**Step 1: Add methods to `internal/storage/interface.go`**

Append to the `Storage` interface (after the `Ping` and `Close` methods):

```go
// CreateAPIKey stores a new API key.
CreateAPIKey(ctx context.Context, key *models.APIKey) error

// GetAPIKeyByHash retrieves an API key by its SHA-256 hash.
// Returns storage.ErrNotFound if no matching enabled key exists.
GetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error)

// ListAPIKeys returns all API keys (both enabled and disabled).
ListAPIKeys(ctx context.Context) ([]*models.APIKey, error)

// UpdateAPIKey replaces the mutable fields of an existing API key.
UpdateAPIKey(ctx context.Context, key *models.APIKey) error

// DeleteAPIKey permanently removes an API key by ID.
DeleteAPIKey(ctx context.Context, id string) error
```

**Step 2: Run build to see what needs implementing**

```
make build
```

Expected: compile errors listing every type that is missing the new methods.

**Step 3: Commit**

```
git add internal/storage/interface.go
git commit -m "feat(storage): extend Storage interface with APIKey CRUD methods"
```

---

### Task 3: Memory storage — APIKey methods

**Files:**
- Modify: `internal/storage/memory.go`
- Modify: `internal/storage/memory_test.go`

**Context:** `MemoryStorage` uses `sync.RWMutex` plus maps for fast access. Add a primary map keyed by ID and a secondary map keyed by hash for O(1) auth lookups.

**Step 1: Write the failing tests**

Add to `internal/storage/memory_test.go`:

```go
func TestMemoryStorage_APIKeyCRUD(t *testing.T) {
	s, _ := NewMemoryStorage(Config{})
	ctx := context.Background()

	raw, _ := models.GenerateAPIKey()
	key := models.NewAPIKey(models.NewKeyID(), "test", raw, []string{"read"})

	// Create
	require.NoError(t, s.CreateAPIKey(ctx, key))

	// GetByHash
	got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)
	require.NoError(t, err)
	assert.Equal(t, key.ID, got.ID)

	// List
	list, err := s.ListAPIKeys(ctx)
	require.NoError(t, err)
	assert.Len(t, list, 1)

	// Update
	key.Name = "updated"
	require.NoError(t, s.UpdateAPIKey(ctx, key))
	got, _ = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Equal(t, "updated", got.Name)

	// Delete
	require.NoError(t, s.DeleteAPIKey(ctx, key.ID))
	_, err = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Error(t, err)
}

func TestMemoryStorage_GetAPIKeyByHash_NotFound(t *testing.T) {
	s, _ := NewMemoryStorage(Config{})
	_, err := s.GetAPIKeyByHash(context.Background(), "nonexistent")
	assert.ErrorIs(t, err, ErrNotFound)
}
```

**Step 2: Run to verify failure**

```
make test
```

Expected: FAIL — methods not found.

**Step 3: Add fields and implement methods in `internal/storage/memory.go`**

Add to `MemoryStorage` struct:
```go
apiKeys     map[string]*models.APIKey // keyed by ID
apiKeyHashes map[string]string         // hash → ID
```

Update `NewMemoryStorage` to initialise both maps.

Then add the five methods following the same pattern as `SaveApplication` (copy-on-return, mutex lock):

```go
func (m *MemoryStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	c := *key
	m.apiKeys[key.ID] = &c
	m.apiKeyHashes[key.KeyHash] = key.ID
	return nil
}

func (m *MemoryStorage) GetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	id, ok := m.apiKeyHashes[hash]
	if !ok {
		return nil, ErrNotFound
	}
	k := *m.apiKeys[id]
	return &k, nil
}

func (m *MemoryStorage) ListAPIKeys(ctx context.Context) ([]*models.APIKey, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	out := make([]*models.APIKey, 0, len(m.apiKeys))
	for _, k := range m.apiKeys {
		c := *k
		out = append(out, &c)
	}
	return out, nil
}

func (m *MemoryStorage) UpdateAPIKey(ctx context.Context, key *models.APIKey) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	existing, ok := m.apiKeys[key.ID]
	if !ok {
		return ErrNotFound
	}
	// Update hash index if hash changed (shouldn't happen, but be safe)
	if existing.KeyHash != key.KeyHash {
		delete(m.apiKeyHashes, existing.KeyHash)
		m.apiKeyHashes[key.KeyHash] = key.ID
	}
	c := *key
	m.apiKeys[key.ID] = &c
	return nil
}

func (m *MemoryStorage) DeleteAPIKey(ctx context.Context, id string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	k, ok := m.apiKeys[id]
	if !ok {
		return ErrNotFound
	}
	delete(m.apiKeyHashes, k.KeyHash)
	delete(m.apiKeys, id)
	return nil
}
```

Check `internal/storage/errors.go` for the existing `ErrNotFound` sentinel — use it here.

**Step 4: Run tests**

```
make test
```

Expected: PASS for `TestMemoryStorage_APIKeyCRUD` and `TestMemoryStorage_GetAPIKeyByHash_NotFound`.

**Step 5: Commit**

```
git add internal/storage/memory.go internal/storage/memory_test.go
git commit -m "feat(storage/memory): implement APIKey CRUD methods"
```

---

### Task 4: JSON storage — APIKey methods

**Files:**
- Modify: `internal/storage/json.go`
- Modify: `internal/storage/json_test.go`

**Context:** `JSONStorage` uses a `JSONData` struct that is serialised to disk. Add an `APIKeys` field to `JSONData` so keys persist. Follow the existing `save`/`load` pattern.

**Step 1: Write failing tests**

Add to `internal/storage/json_test.go`:

```go
func TestJSONStorage_APIKeyCRUD(t *testing.T) {
	dir := t.TempDir()
	s, err := NewJSONStorage(Config{Path: filepath.Join(dir, "data.json")})
	require.NoError(t, err)
	ctx := context.Background()

	raw, _ := models.GenerateAPIKey()
	key := models.NewAPIKey(models.NewKeyID(), "ci", raw, []string{"write"})

	require.NoError(t, s.CreateAPIKey(ctx, key))

	got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)
	require.NoError(t, err)
	assert.Equal(t, "ci", got.Name)

	keys, err := s.ListAPIKeys(ctx)
	require.NoError(t, err)
	assert.Len(t, keys, 1)

	key.Name = "ci-updated"
	require.NoError(t, s.UpdateAPIKey(ctx, key))

	require.NoError(t, s.DeleteAPIKey(ctx, key.ID))
	_, err = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Error(t, err)
}
```

**Step 2: Run to verify failure**

```
make test
```

Expected: FAIL — methods not found.

**Step 3: Implement in `internal/storage/json.go`**

1. Add `APIKeys []*models.APIKey \`json:"api_keys"\`` to `JSONData`.

2. Initialise in `ensureFileExists`:
```go
data = &JSONData{
    Applications: []*models.Application{},
    Releases:     []*models.Release{},
    APIKeys:      []*models.APIKey{},
    LastUpdated:  time.Now(),
}
```

3. Add the five methods. Each method calls `s.loadData()`, mutates `s.data.APIKeys`, then calls `s.saveData()`. Follow the same locking pattern as the existing application methods:

```go
func (j *JSONStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {
	j.mu.Lock()
	defer j.mu.Unlock()
	if err := j.loadData(); err != nil {
		return err
	}
	c := *key
	j.data.APIKeys = append(j.data.APIKeys, &c)
	return j.saveData()
}

func (j *JSONStorage) GetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error) {
	j.mu.RLock()
	defer j.mu.RUnlock()
	if err := j.loadData(); err != nil {
		return nil, err
	}
	for _, k := range j.data.APIKeys {
		if k.KeyHash == hash {
			c := *k
			return &c, nil
		}
	}
	return nil, ErrNotFound
}

func (j *JSONStorage) ListAPIKeys(ctx context.Context) ([]*models.APIKey, error) {
	j.mu.RLock()
	defer j.mu.RUnlock()
	if err := j.loadData(); err != nil {
		return nil, err
	}
	out := make([]*models.APIKey, len(j.data.APIKeys))
	for i, k := range j.data.APIKeys {
		c := *k
		out[i] = &c
	}
	return out, nil
}

func (j *JSONStorage) UpdateAPIKey(ctx context.Context, key *models.APIKey) error {
	j.mu.Lock()
	defer j.mu.Unlock()
	if err := j.loadData(); err != nil {
		return err
	}
	for i, k := range j.data.APIKeys {
		if k.ID == key.ID {
			c := *key
			j.data.APIKeys[i] = &c
			return j.saveData()
		}
	}
	return ErrNotFound
}

func (j *JSONStorage) DeleteAPIKey(ctx context.Context, id string) error {
	j.mu.Lock()
	defer j.mu.Unlock()
	if err := j.loadData(); err != nil {
		return err
	}
	for i, k := range j.data.APIKeys {
		if k.ID == id {
			j.data.APIKeys = append(j.data.APIKeys[:i], j.data.APIKeys[i+1:]...)
			return j.saveData()
		}
	}
	return ErrNotFound
}
```

**Step 4: Run tests**

```
make test
```

Expected: PASS.

**Step 5: Commit**

```
git add internal/storage/json.go internal/storage/json_test.go
git commit -m "feat(storage/json): implement APIKey CRUD methods"
```

---

### Task 5: SQLite schema and queries

**Files:**
- Create: `internal/storage/sqlc/schema/sqlite/004_api_keys.sql`
- Create: `internal/storage/sqlc/queries/sqlite/api_keys.sql`

**Context:** The sqlc tool generates Go code from SQL. Add a migration file for the `api_keys` table and a queries file. Run `make sqlc-generate` afterwards. The schema follows the same conventions as `001_initial.sql`: `TEXT` primary key, `TEXT NOT NULL DEFAULT (datetime('now'))` timestamps, JSON array as `TEXT` for `permissions`.

**Step 1: Create the schema migration**

```sql
-- internal/storage/sqlc/schema/sqlite/004_api_keys.sql
-- API keys table (SQLite version)
CREATE TABLE api_keys (
    id          TEXT NOT NULL PRIMARY KEY,
    name        TEXT NOT NULL,
    key_hash    TEXT NOT NULL UNIQUE,
    prefix      TEXT NOT NULL,
    permissions TEXT NOT NULL DEFAULT '[]', -- JSON array as TEXT
    enabled     INTEGER NOT NULL DEFAULT 1,
    created_at  TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at  TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_api_keys_hash ON api_keys(key_hash);

CREATE TRIGGER update_api_keys_updated_at
    AFTER UPDATE ON api_keys
    FOR EACH ROW
BEGIN
    UPDATE api_keys SET updated_at = datetime('now') WHERE id = NEW.id;
END;
```

**Step 2: Create the query file**

```sql
-- internal/storage/sqlc/queries/sqlite/api_keys.sql

-- name: CreateAPIKey :exec
INSERT INTO api_keys (id, name, key_hash, prefix, permissions, enabled, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

-- name: GetAPIKeyByHash :one
SELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at
FROM api_keys
WHERE key_hash = ?;

-- name: ListAPIKeys :many
SELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at
FROM api_keys
ORDER BY created_at;

-- name: UpdateAPIKey :exec
UPDATE api_keys
SET name = ?, permissions = ?, enabled = ?, updated_at = ?
WHERE id = ?;

-- name: DeleteAPIKey :exec
DELETE FROM api_keys
WHERE id = ?;
```

**Step 3: Run sqlc-generate**

```
make sqlc-generate
```

Expected: new file `internal/storage/sqlc/sqlite/api_keys.sql.go` created; `internal/storage/sqlc/sqlite/models.go` updated with an `ApiKey` struct.

**Step 4: Commit**

```
git add internal/storage/sqlc/schema/sqlite/004_api_keys.sql \
        internal/storage/sqlc/queries/sqlite/api_keys.sql \
        internal/storage/sqlc/sqlite/
git commit -m "feat(storage/sqlc/sqlite): add api_keys table schema and generated queries"
```

---

### Task 6: PostgreSQL schema and queries

**Files:**
- Create: `internal/storage/sqlc/schema/postgres/004_api_keys.sql`
- Create: `internal/storage/sqlc/queries/postgres/api_keys.sql`

**Context:** Same as Task 5 but using PostgreSQL syntax: `TIMESTAMPTZ`, `JSONB` for permissions, `$1`-style placeholders, and a trigger using the existing `update_updated_at_column()` function from `001_initial.sql`.

**Step 1: Create the schema migration**

```sql
-- internal/storage/sqlc/schema/postgres/004_api_keys.sql
-- API keys table (PostgreSQL version)
CREATE TABLE api_keys (
    id          TEXT        NOT NULL PRIMARY KEY,
    name        TEXT        NOT NULL,
    key_hash    TEXT        NOT NULL UNIQUE,
    prefix      TEXT        NOT NULL,
    permissions JSONB       NOT NULL DEFAULT '[]',
    enabled     BOOLEAN     NOT NULL DEFAULT TRUE,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_api_keys_hash ON api_keys(key_hash);

CREATE TRIGGER update_api_keys_updated_at
    BEFORE UPDATE ON api_keys
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

**Step 2: Create the query file**

```sql
-- internal/storage/sqlc/queries/postgres/api_keys.sql

-- name: CreateAPIKey :exec
INSERT INTO api_keys (id, name, key_hash, prefix, permissions, enabled, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8);

-- name: GetAPIKeyByHash :one
SELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at
FROM api_keys
WHERE key_hash = $1;

-- name: ListAPIKeys :many
SELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at
FROM api_keys
ORDER BY created_at;

-- name: UpdateAPIKey :exec
UPDATE api_keys
SET name = $2, permissions = $3, enabled = $4, updated_at = $5
WHERE id = $1;

-- name: DeleteAPIKey :exec
DELETE FROM api_keys
WHERE id = $1;
```

**Step 3: Run sqlc-generate**

```
make sqlc-generate
```

Expected: `internal/storage/sqlc/postgres/api_keys.sql.go` created; `models.go` updated.

**Step 4: Commit**

```
git add internal/storage/sqlc/schema/postgres/004_api_keys.sql \
        internal/storage/sqlc/queries/postgres/api_keys.sql \
        internal/storage/sqlc/postgres/
git commit -m "feat(storage/sqlc/postgres): add api_keys table schema and generated queries"
```

---

### Task 7: SQLite storage — APIKey methods

**Files:**
- Modify: `internal/storage/sqlite.go`
- Modify: `internal/storage/sqlite_test.go`
- Create: `internal/storage/dbconvert.go` (add helpers, do not replace — see context)

**Context:** `SQLiteStorage` uses the sqlc-generated `Queries` type. After `make sqlc-generate` in Tasks 5–6, the generated package `sqlcite` has `ApiKey` rows and query methods. Convert between `sqlcite.ApiKey` and `models.APIKey` using the same pattern as `dbconvert.go` does for applications. The `permissions` field is a JSON TEXT column in SQLite.

**Step 1: Add conversion helpers to `internal/storage/dbconvert.go`**

Append (do not replace) the following functions:

```go
// marshalPermissions serialises a permissions slice to JSON.
func marshalPermissions(perms []string) ([]byte, error) {
	if perms == nil {
		perms = []string{}
	}
	return json.Marshal(perms)
}

// unmarshalPermissionsFromString parses a JSON string into a permissions slice.
func unmarshalPermissionsFromString(data string) ([]string, error) {
	if data == "" {
		return []string{}, nil
	}
	var perms []string
	if err := json.Unmarshal([]byte(data), &perms); err != nil {
		return nil, fmt.Errorf("unmarshal permissions: %w", err)
	}
	if perms == nil {
		perms = []string{}
	}
	return perms, nil
}
```

**Step 2: Write failing tests**

Add to `internal/storage/sqlite_test.go`:

```go
func TestSQLiteStorage_APIKeyCRUD(t *testing.T) {
	s := newTestSQLiteStorage(t) // use existing helper
	ctx := context.Background()

	raw, _ := models.GenerateAPIKey()
	key := models.NewAPIKey(models.NewKeyID(), "deploy", raw, []string{"write"})

	require.NoError(t, s.CreateAPIKey(ctx, key))

	got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)
	require.NoError(t, err)
	assert.Equal(t, key.ID, got.ID)
	assert.Equal(t, []string{"write"}, got.Permissions)

	keys, err := s.ListAPIKeys(ctx)
	require.NoError(t, err)
	assert.Len(t, keys, 1)

	key.Name = "deploy-v2"
	key.Permissions = []string{"write", "read"}
	require.NoError(t, s.UpdateAPIKey(ctx, key))

	got, _ = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Equal(t, "deploy-v2", got.Name)

	require.NoError(t, s.DeleteAPIKey(ctx, key.ID))
	_, err = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Error(t, err)
}
```

**Step 3: Run to verify failure**

```
make test
```

Expected: FAIL — methods not defined.

**Step 4: Implement in `internal/storage/sqlite.go`**

Look up the generated function names in `internal/storage/sqlc/sqlite/api_keys.sql.go`. They will be methods on `*sqlcite.Queries`, e.g. `q.CreateAPIKey(ctx, sqlcite.CreateAPIKeyParams{...})`.

Add a helper to convert `sqlcite.ApiKey` → `*models.APIKey`:

```go
func sqliteAPIKeyToModel(row sqlcite.ApiKey) (*models.APIKey, error) {
	perms, err := unmarshalPermissionsFromString(row.Permissions)
	if err != nil {
		return nil, err
	}
	createdAt, _ := time.Parse("2006-01-02T15:04:05Z", row.CreatedAt)
	updatedAt, _ := time.Parse("2006-01-02T15:04:05Z", row.UpdatedAt)
	return &models.APIKey{
		ID:          row.ID,
		Name:        row.Name,
		KeyHash:     row.KeyHash,
		Prefix:      row.Prefix,
		Permissions: perms,
		Enabled:     row.Enabled,
		CreatedAt:   createdAt,
		UpdatedAt:   updatedAt,
	}, nil
}
```

Then implement the five methods using the generated queries. For `CreateAPIKey`:
```go
func (s *SQLiteStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {
	permsJSON, err := marshalPermissions(key.Permissions)
	if err != nil {
		return err
	}
	return s.queries.CreateAPIKey(ctx, sqlcite.CreateAPIKeyParams{
		ID:          key.ID,
		Name:        key.Name,
		KeyHash:     key.KeyHash,
		Prefix:      key.Prefix,
		Permissions: string(permsJSON),
		Enabled:     key.Enabled,
		CreatedAt:   key.CreatedAt.UTC().Format("2006-01-02T15:04:05Z"),
		UpdatedAt:   key.UpdatedAt.UTC().Format("2006-01-02T15:04:05Z"),
	})
}
```

Use the same pattern for the remaining four methods. For `GetAPIKeyByHash`, call `s.queries.GetAPIKeyByHash(ctx, hash)` and convert with `sqliteAPIKeyToModel`. Return `ErrNotFound` when the sqlc result is `sql.ErrNoRows`. For `UpdateAPIKey`, the generated params use `(id, name, permissions, enabled, updated_at)` — match the column order in your query.

**Step 5: Run tests**

```
make test
```

Expected: PASS.

**Step 6: Commit**

```
git add internal/storage/sqlite.go internal/storage/sqlite_test.go internal/storage/dbconvert.go
git commit -m "feat(storage/sqlite): implement APIKey CRUD methods"
```

---

### Task 8: PostgreSQL storage — APIKey methods

**Files:**
- Modify: `internal/storage/postgres.go`
- Modify: `internal/storage/postgres_test.go`

**Context:** Same pattern as Task 7. PostgreSQL uses JSONB for permissions (stored as `pgtype.Text` or a raw JSON string depending on how sqlc generates it — check `internal/storage/sqlc/postgres/models.go` after generation). Timestamps use `time.Time` via `pgx`. The test helper `newTestPostgresStorage` may require a running database; if one isn't available in the test environment, add a `t.Skip("requires postgres")` guard consistent with how the existing postgres tests skip.

**Step 1: Write failing tests**

Add to `internal/storage/postgres_test.go` (mirroring the SQLite test structure and existing skip guard):

```go
func TestPostgresStorage_APIKeyCRUD(t *testing.T) {
	s := newTestPostgresStorage(t) // skips if no DB available
	ctx := context.Background()

	raw, _ := models.GenerateAPIKey()
	key := models.NewAPIKey(models.NewKeyID(), "ci", raw, []string{"write"})

	require.NoError(t, s.CreateAPIKey(ctx, key))

	got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)
	require.NoError(t, err)
	assert.Equal(t, key.ID, got.ID)
	assert.Equal(t, []string{"write"}, got.Permissions)

	key.Name = "ci-v2"
	require.NoError(t, s.UpdateAPIKey(ctx, key))

	require.NoError(t, s.DeleteAPIKey(ctx, key.ID))
	_, err = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.Error(t, err)
}
```

**Step 2: Implement in `internal/storage/postgres.go`**

Inspect `internal/storage/sqlc/postgres/models.go` for the generated `ApiKey` type and `internal/storage/sqlc/postgres/api_keys.sql.go` for the query method signatures.

Add a conversion helper `postgresAPIKeyToModel` similar to the SQLite version; handle the JSONB permissions field. Then implement the five methods using the generated queries.

**Step 3: Run tests**

```
make test
```

Expected: PASS (postgres tests skip if no DB).

**Step 4: Commit**

```
git add internal/storage/postgres.go internal/storage/postgres_test.go
git commit -m "feat(storage/postgres): implement APIKey CRUD methods"
```

---

### Task 9: InstrumentedStorage — APIKey methods

**Files:**
- Modify: `internal/observability/storage.go`
- Modify: `internal/observability/storage_test.go`

**Context:** `InstrumentedStorage` in `internal/observability/storage.go` wraps a `storage.Storage` and records OTel spans + metrics for each method. It must implement the five new interface methods. Each method follows the existing pattern: call `s.startSpan(...)`, defer `s.recordDuration(...)`, call the inner method, and call `s.recordError(...)` on failure.

Look at an existing method such as `GetApplication` or `Ping` in `storage.go` to understand the exact instrumentation pattern, then repeat it for each new method.

**Step 1: Write failing tests**

Add to `internal/observability/storage_test.go` — use the existing test setup (mock inner storage or a MemoryStorage):

```go
func TestInstrumentedStorage_APIKeyMethods(t *testing.T) {
	inner, _ := storage.NewMemoryStorage(storage.Config{})
	s, err := NewInstrumentedStorage(inner)
	require.NoError(t, err)
	ctx := context.Background()

	raw, _ := models.GenerateAPIKey()
	key := models.NewAPIKey(models.NewKeyID(), "test", raw, []string{"read"})

	assert.NoError(t, s.CreateAPIKey(ctx, key))
	_, err = s.GetAPIKeyByHash(ctx, key.KeyHash)
	assert.NoError(t, err)
	_, err = s.ListAPIKeys(ctx)
	assert.NoError(t, err)
	key.Name = "test2"
	assert.NoError(t, s.UpdateAPIKey(ctx, key))
	assert.NoError(t, s.DeleteAPIKey(ctx, key.ID))
}
```

**Step 2: Implement the five methods in `internal/observability/storage.go`**

Follow the existing pattern exactly. Example for `CreateAPIKey`:

```go
func (s *InstrumentedStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {
	ctx, span := s.startSpan(ctx, "CreateAPIKey")
	start := time.Now()
	defer s.recordDuration(ctx, "CreateAPIKey", start)
	defer span.End()
	err := s.inner.CreateAPIKey(ctx, key)
	s.recordError(ctx, "CreateAPIKey", err)
	return err
}
```

Repeat for the other four methods. Do not add new OTel attributes beyond what the existing pattern uses.

**Step 3: Run tests**

```
make test
```

Expected: PASS.

**Step 4: Commit**

```
git add internal/observability/storage.go internal/observability/storage_test.go
git commit -m "feat(observability): instrument APIKey CRUD methods"
```

---

### Task 10: Bootstrap seeding

**Files:**
- Modify: `cmd/updater/updater.go`

**Context:** After storage is initialised (and optionally wrapped with `InstrumentedStorage`), check if `config.Security.BootstrapKey` is set. If it is, hash it and call `GetAPIKeyByHash`. If not found, create the key in storage. This is idempotent — safe to call on every restart.

**Step 1: Add `seedBootstrapKey` function**

Add after `initializeStorage` in `cmd/updater/updater.go`:

```go
// seedBootstrapKey inserts the configured bootstrap key into storage if it
// does not already exist. It is a no-op when BootstrapKey is empty.
func seedBootstrapKey(ctx context.Context, store storage.Storage, cfg *models.Config) error {
	raw := cfg.Security.BootstrapKey
	if raw == "" {
		return nil
	}
	hash := models.HashAPIKey(raw)
	if _, err := store.GetAPIKeyByHash(ctx, hash); err == nil {
		// Already seeded.
		return nil
	}
	key := models.NewAPIKey(models.NewKeyID(), "bootstrap", raw, []string{"admin"})
	if err := store.CreateAPIKey(ctx, key); err != nil {
		return fmt.Errorf("seed bootstrap key: %w", err)
	}
	slog.Info("bootstrap API key seeded", "id", key.ID, "prefix", key.Prefix)
	return nil
}
```

**Step 2: Call it in `main`**

In `main()`, after `activeStorage` is assigned, add:

```go
if err := seedBootstrapKey(context.Background(), activeStorage, cfg); err != nil {
    slog.Error("Failed to seed bootstrap key", "error", err)
    os.Exit(1)
}
```

**Step 3: Build**

```
make build
```

Expected: successful build.

**Step 4: Commit**

```
git add cmd/updater/updater.go
git commit -m "feat(cmd): seed bootstrap API key into storage on startup"
```

---

### Task 11: Update auth and admin middleware to use storage

**Files:**
- Modify: `internal/api/routes.go`
- Modify: `internal/api/middleware.go`
- Modify: `internal/api/middleware_admin.go`
- Modify: `internal/api/handlers_admin.go`

**Context:** Four functions currently look up keys from `config.Security.APIKeys` (a `[]models.APIKey` slice that no longer exists). They must all switch to querying storage by SHA-256 hash. Storage is already available on `*Handlers`; thread it through to the middleware closures via the `SetupRoutes` parameters.

**Note:** After removing `APIKeys []APIKey` from `SecurityConfig` in Task 1, these four functions will already have compile errors — fix them here.

**Step 1: Update `authMiddleware` in `routes.go`**

Change signature from:
```go
func authMiddleware(securityConfig models.SecurityConfig) mux.MiddlewareFunc
```
To:
```go
func authMiddleware(securityConfig models.SecurityConfig, store storage.Storage) mux.MiddlewareFunc
```

Replace the loop body with a storage lookup:
```go
token := authHeader[len(prefix):]
hash := models.HashAPIKey(token)
validKey, err := store.GetAPIKeyByHash(r.Context(), hash)
if err != nil || !validKey.Enabled {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusUnauthorized)
    json.NewEncoder(w).Encode(models.NewErrorResponse("Invalid API key", models.ErrorCodeUnauthorized))
    return
}
ctx := context.WithValue(r.Context(), "api_key", validKey)
next.ServeHTTP(w, r.WithContext(ctx))
```

In `SetupRoutes`, update all calls from `authMiddleware(config.Security)` to `authMiddleware(config.Security, handlers.storage)`.

**Step 2: Update `OptionalAuth` in `middleware.go`**

Same signature change: add `store storage.Storage` parameter. Replace the loop with:
```go
hash := models.HashAPIKey(token)
validKey, err := store.GetAPIKeyByHash(r.Context(), hash)
if err == nil && validKey.Enabled {
    ctx := context.WithValue(r.Context(), "api_key", validKey)
    next.ServeHTTP(w, r.WithContext(ctx))
    return
}
next.ServeHTTP(w, r)
```

In `SetupRoutes`, update the call from `OptionalAuth(config.Security)` to `OptionalAuth(config.Security, handlers.storage)`.

**Step 3: Update `isValidAdminKey` and `adminSessionMiddleware` in `middleware_admin.go`**

`isValidAdminKey` needs a context and storage:
```go
func isValidAdminKey(ctx context.Context, key string, store storage.Storage) bool {
    if key == "" {
        return false
    }
    // Dev mode: no keys in storage → accept any non-empty key
    keys, err := store.ListAPIKeys(ctx)
    if err != nil || len(keys) == 0 {
        return true
    }
    hash := models.HashAPIKey(key)
    ak, err := store.GetAPIKeyByHash(ctx, hash)
    if err != nil || !ak.Enabled {
        return false
    }
    return ak.HasPermission("admin")
}
```

Update `adminSessionMiddleware` signature to accept `store storage.Storage`:
```go
func adminSessionMiddleware(cfg models.SecurityConfig, store storage.Storage) mux.MiddlewareFunc
```

Pass `r.Context()` and `store` to `isValidAdminKey`.

In `SetupRoutes`, update the call:
```go
adminRouter.Use(adminSessionMiddleware(config.Security, handlers.storage))
```

**Step 4: Update `AdminLogin` handler in `handlers_admin.go`**

`AdminLogin` calls `isValidAdminKey(key, h.securityConfig)` — update to pass context and storage:
```go
if !isValidAdminKey(r.Context(), key, h.storage) {
```

**Step 5: Build**

```
make build
```

Expected: successful build, no remaining compile errors referencing `APIKeys`.

**Step 6: Run tests**

```
make test
```

Expected: PASS.

**Step 7: Commit**

```
git add internal/api/routes.go internal/api/middleware.go \
        internal/api/middleware_admin.go internal/api/handlers_admin.go
git commit -m "feat(api): switch auth middleware to storage-backed key lookup"
```

---

### Task 12: REST handlers for key management

**Files:**
- Create: `internal/api/handlers_keys.go`
- Modify: `internal/api/routes.go`
- Create: `internal/api/handlers_keys_test.go`

**Context:** Four handlers implement the key management REST API. They follow the same pattern as `handlers_admin.go`: decode JSON, call storage, return JSON. All four require `admin` permission and emit security audit log events.

**Step 1: Write failing tests**

```go
// internal/api/handlers_keys_test.go
package api_test

// Table-driven tests for all four handlers using httptest.NewRecorder() and
// a MemoryStorage instance. Cover: happy path, missing fields, not found,
// permission denied (non-admin key).

func TestListAPIKeys(t *testing.T) { ... }
func TestCreateAPIKey(t *testing.T) { ... }
func TestUpdateAPIKey(t *testing.T) { ... }
func TestDeleteAPIKey(t *testing.T) { ... }
```

Use the same test setup pattern as existing handler tests in the `api` package.

**Step 2: Run to verify failure**

```
make test
```

Expected: FAIL — handlers not defined.

**Step 3: Create `internal/api/handlers_keys.go`**

```go
package api

import (
    "encoding/json"
    "log/slog"
    "net/http"
    "time"
    "updater/internal/models"

    "github.com/google/uuid"
    "github.com/gorilla/mux"
)

// createAPIKeyRequest is the request body for POST /api/v1/admin/keys.
type createAPIKeyRequest struct {
    Name        string   `json:"name"`
    Permissions []string `json:"permissions"`
}

// createAPIKeyResponse includes the raw key — returned exactly once.
type createAPIKeyResponse struct {
    ID          string    `json:"id"`
    Name        string    `json:"name"`
    Key         string    `json:"key"`
    Prefix      string    `json:"prefix"`
    Permissions []string  `json:"permissions"`
    Enabled     bool      `json:"enabled"`
    CreatedAt   time.Time `json:"created_at"`
}

// apiKeyResponse is the metadata-only view (no raw key, no hash).
type apiKeyResponse struct {
    ID          string    `json:"id"`
    Name        string    `json:"name"`
    Prefix      string    `json:"prefix"`
    Permissions []string  `json:"permissions"`
    Enabled     bool      `json:"enabled"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// updateAPIKeyRequest is the request body for PATCH /api/v1/admin/keys/{id}.
// All fields are optional.
type updateAPIKeyRequest struct {
    Name        *string   `json:"name"`
    Permissions []string  `json:"permissions"`
    Enabled     *bool     `json:"enabled"`
}

func apiKeyToResponse(k *models.APIKey) apiKeyResponse {
    return apiKeyResponse{
        ID:          k.ID,
        Name:        k.Name,
        Prefix:      k.Prefix,
        Permissions: k.Permissions,
        Enabled:     k.Enabled,
        CreatedAt:   k.CreatedAt,
        UpdatedAt:   k.UpdatedAt,
    }
}

// ListAPIKeys handles GET /api/v1/admin/keys
func (h *Handlers) ListAPIKeys(w http.ResponseWriter, r *http.Request) {
    keys, err := h.storage.ListAPIKeys(r.Context())
    if err != nil {
        writeJSONError(w, http.StatusInternalServerError, "failed to list keys", models.ErrorCodeInternalError)
        return
    }
    resp := make([]apiKeyResponse, len(keys))
    for i, k := range keys {
        resp[i] = apiKeyToResponse(k)
    }
    writeJSON(w, http.StatusOK, resp)
}

// CreateAPIKey handles POST /api/v1/admin/keys
func (h *Handlers) CreateAPIKey(w http.ResponseWriter, r *http.Request) {
    var req createAPIKeyRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSONError(w, http.StatusBadRequest, "invalid request body", models.ErrorCodeInvalidRequest)
        return
    }
    if req.Name == "" {
        writeJSONError(w, http.StatusBadRequest, "name is required", models.ErrorCodeInvalidRequest)
        return
    }
    if len(req.Permissions) == 0 {
        writeJSONError(w, http.StatusBadRequest, "permissions is required", models.ErrorCodeInvalidRequest)
        return
    }

    rawKey, err := models.GenerateAPIKey()
    if err != nil {
        writeJSONError(w, http.StatusInternalServerError, "failed to generate key", models.ErrorCodeInternalError)
        return
    }

    key := models.NewAPIKey(models.NewKeyID(), req.Name, rawKey, req.Permissions)
    if err := h.storage.CreateAPIKey(r.Context(), key); err != nil {
        writeJSONError(w, http.StatusInternalServerError, "failed to create key", models.ErrorCodeInternalError)
        return
    }

    actor := actorKeyID(r)
    slog.Info("api key created",
        "event", "security_audit",
        "action", "create",
        "key_id", key.ID,
        "key_name", key.Name,
        "actor_key_id", actor,
    )

    writeJSON(w, http.StatusCreated, createAPIKeyResponse{
        ID:          key.ID,
        Name:        key.Name,
        Key:         rawKey,
        Prefix:      key.Prefix,
        Permissions: key.Permissions,
        Enabled:     key.Enabled,
        CreatedAt:   key.CreatedAt,
    })
}

// UpdateAPIKey handles PATCH /api/v1/admin/keys/{id}
func (h *Handlers) UpdateAPIKey(w http.ResponseWriter, r *http.Request) {
    id := mux.Vars(r)["id"]
    var req updateAPIKeyRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeJSONError(w, http.StatusBadRequest, "invalid request body", models.ErrorCodeInvalidRequest)
        return
    }

    // Fetch existing key to apply partial updates
    keys, err := h.storage.ListAPIKeys(r.Context())
    if err != nil {
        writeJSONError(w, http.StatusInternalServerError, "failed to fetch keys", models.ErrorCodeInternalError)
        return
    }
    var key *models.APIKey
    for _, k := range keys {
        if k.ID == id {
            c := *k
            key = &c
            break
        }
    }
    if key == nil {
        writeJSONError(w, http.StatusNotFound, "key not found", models.ErrorCodeNotFound)
        return
    }

    if req.Name != nil {
        key.Name = *req.Name
    }
    if req.Permissions != nil {
        key.Permissions = req.Permissions
    }
    if req.Enabled != nil {
        key.Enabled = *req.Enabled
    }
    key.UpdatedAt = time.Now().UTC()

    if err := h.storage.UpdateAPIKey(r.Context(), key); err != nil {
        writeJSONError(w, http.StatusInternalServerError, "failed to update key", models.ErrorCodeInternalError)
        return
    }

    slog.Info("api key updated",
        "event", "security_audit",
        "action", "update",
        "key_id", key.ID,
        "key_name", key.Name,
        "actor_key_id", actorKeyID(r),
    )

    writeJSON(w, http.StatusOK, apiKeyToResponse(key))
}

// DeleteAPIKey handles DELETE /api/v1/admin/keys/{id}
func (h *Handlers) DeleteAPIKey(w http.ResponseWriter, r *http.Request) {
    id := mux.Vars(r)["id"]
    if err := h.storage.DeleteAPIKey(r.Context(), id); err != nil {
        writeJSONError(w, http.StatusNotFound, "key not found", models.ErrorCodeNotFound)
        return
    }

    slog.Info("api key deleted",
        "event", "security_audit",
        "action", "delete",
        "key_id", id,
        "actor_key_id", actorKeyID(r),
    )

    w.WriteHeader(http.StatusNoContent)
}

// actorKeyID extracts the ID of the authenticated key making this request.
func actorKeyID(r *http.Request) string {
    if k, ok := r.Context().Value("api_key").(*models.APIKey); ok {
        return k.ID
    }
    return "unknown"
}

// writeJSON encodes v as JSON with the given status code.
func writeJSON(w http.ResponseWriter, status int, v any) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(v)
}

// writeJSONError writes a standard error JSON response.
func writeJSONError(w http.ResponseWriter, status int, msg string, code models.ErrorCode) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(models.NewErrorResponse(msg, code))
}
```

**Note:** Check `internal/api/handlers.go` and other handler files — `writeJSON` and `writeJSONError` may already exist under different names. Use the existing helpers if present rather than redefining.

**Step 4: Register routes in `routes.go`**

In the `config.Security.EnableAuth` branch, after the existing admin release-deletion block, add:

```go
// API key management (admin permission required)
keyAdminAPI := api.PathPrefix("/admin/keys").Subrouter()
keyAdminAPI.Use(authMiddleware(config.Security, handlers.storage))
keyAdminAPI.Use(RequirePermission(PermissionAdmin))
keyAdminAPI.HandleFunc("", handlers.ListAPIKeys).Methods("GET")
keyAdminAPI.HandleFunc("", handlers.CreateAPIKey).Methods("POST")
keyAdminAPI.HandleFunc("/{id}", handlers.UpdateAPIKey).Methods("PATCH")
keyAdminAPI.HandleFunc("/{id}", handlers.DeleteAPIKey).Methods("DELETE")
```

Also add the same routes in the `else` branch (auth disabled) for consistency:
```go
api.HandleFunc("/admin/keys", handlers.ListAPIKeys).Methods("GET")
api.HandleFunc("/admin/keys", handlers.CreateAPIKey).Methods("POST")
api.HandleFunc("/admin/keys/{id}", handlers.UpdateAPIKey).Methods("PATCH")
api.HandleFunc("/admin/keys/{id}", handlers.DeleteAPIKey).Methods("DELETE")
```

**Step 5: Run tests**

```
make test
```

Expected: PASS.

**Step 6: Commit**

```
git add internal/api/handlers_keys.go internal/api/handlers_keys_test.go internal/api/routes.go
git commit -m "feat(api): add REST handlers for API key management"
```

---

### Task 13: Admin UI — key management pages

**Files:**
- Create: `internal/api/admin/templates/keys.html`
- Modify: `internal/api/admin/templates/partials/` (nav partial to add Keys link)
- Modify: `internal/api/handlers_admin.go`
- Modify: `internal/api/routes.go`

**Context:** The admin UI uses HTMX + Go templates embedded with `go:embed`. Look at `applications.html` and `partials/` for the page structure and flash message pattern to follow. Create a keys list page with inline HTMX delete/toggle and a create form page.

**Step 1: Explore existing admin templates structure**

Run:
```
find internal/api/admin -name "*.html" | head -20
```

Look at `internal/api/admin/templates/applications.html` for layout conventions, and `internal/api/admin/templates/partials/nav.html` (if it exists) for navigation.

**Step 2: Create `internal/api/admin/templates/keys.html`**

Model after `applications.html`. The page shows a table with columns: Prefix, Name, Permissions, Status, Created, Actions. Each row has:
- An HTMX delete button: `hx-delete="/admin/keys/{id}" hx-confirm="Revoke this key?" hx-target="closest tr" hx-swap="outerHTML"`
- An HTMX enable/disable toggle: `hx-post="/admin/keys/{id}/toggle"`

Includes a "New Key" link to `/admin/keys/new`.

**Step 3: Create `internal/api/admin/templates/keys_new.html`**

A form with fields for Name and Permissions (checkboxes: read, write, admin). On successful creation, the server renders a `keys_created.html` partial that shows the raw key in a styled read-only input with a JS copy button and a prominent "This key will not be shown again" warning.

**Step 4: Add data structs and handlers to `handlers_admin.go`**

Add data types:
```go
type adminKeysData struct {
    adminBaseData
    Keys []models.APIKey
}

type adminNewKeyData struct {
    adminBaseData
    Error string
    CreatedKey *createdKeyData
}

type createdKeyData struct {
    Name   string
    Key    string // raw key — shown once
    Prefix string
}
```

Add handlers:
```go
func (h *Handlers) AdminListKeys(w http.ResponseWriter, r *http.Request)  { ... }
func (h *Handlers) AdminNewKeyForm(w http.ResponseWriter, r *http.Request) { ... }
func (h *Handlers) AdminCreateKey(w http.ResponseWriter, r *http.Request) { ... }
func (h *Handlers) AdminDeleteKey(w http.ResponseWriter, r *http.Request) { ... }
func (h *Handlers) AdminToggleKey(w http.ResponseWriter, r *http.Request) { ... }
```

`AdminCreateKey` calls `models.GenerateAPIKey()`, then `storage.CreateAPIKey`, then re-renders the new-key form with `createdKeyData` populated.

`AdminDeleteKey` calls `storage.DeleteAPIKey` and returns either an empty 200 (for HTMX swap) or redirects.

`AdminToggleKey` reads the key from storage, flips `Enabled`, calls `UpdateAPIKey`, and returns an HTMX fragment.

**Step 5: Register routes in `routes.go`**

Add to `adminRouter`:
```go
adminRouter.HandleFunc("/keys", handlers.AdminListKeys).Methods("GET")
adminRouter.HandleFunc("/keys/new", handlers.AdminNewKeyForm).Methods("GET")
adminRouter.HandleFunc("/keys", handlers.AdminCreateKey).Methods("POST")
adminRouter.HandleFunc("/keys/{id}", handlers.AdminDeleteKey).Methods("DELETE")
adminRouter.HandleFunc("/keys/{id}/toggle", handlers.AdminToggleKey).Methods("POST")
```

**Step 6: Build and smoke test**

```
make build
make run
```

Navigate to `http://localhost:8080/admin/keys` and verify the page loads.

**Step 7: Commit**

```
git add internal/api/admin/ internal/api/handlers_admin.go internal/api/routes.go
git commit -m "feat(admin): add API key management pages to admin UI"
```

---

### Task 14: Update OpenAPI spec

**Files:**
- Modify: `internal/api/openapi/openapi.yaml`

**Context:** The OpenAPI spec is maintained manually. Add the four new endpoints and their schemas. Run `make openapi-validate` after editing to catch syntax errors. Follow the structure of existing endpoint entries in the file.

**Step 1: Add schemas**

In the `components.schemas` section, add:

```yaml
APIKeyMeta:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    prefix: { type: string }
    permissions:
      type: array
      items: { type: string }
    enabled: { type: boolean }
    created_at: { type: string, format: date-time }
    updated_at: { type: string, format: date-time }

CreateAPIKeyRequest:
  type: object
  required: [name, permissions]
  properties:
    name: { type: string }
    permissions:
      type: array
      items: { type: string }

CreateAPIKeyResponse:
  allOf:
    - $ref: '#/components/schemas/APIKeyMeta'
  properties:
    key: { type: string, description: "Raw key value — returned exactly once" }

UpdateAPIKeyRequest:
  type: object
  properties:
    name: { type: string }
    permissions:
      type: array
      items: { type: string }
    enabled: { type: boolean }
```

**Step 2: Add path entries**

Add under `paths`:

```yaml
/api/v1/admin/keys:
  get:
    summary: List API keys
    tags: [Admin]
    security: [{ BearerAuth: [] }]
    responses:
      '200':
        description: List of API key metadata
        content:
          application/json:
            schema:
              type: array
              items: { $ref: '#/components/schemas/APIKeyMeta' }
  post:
    summary: Create an API key
    tags: [Admin]
    security: [{ BearerAuth: [] }]
    requestBody:
      required: true
      content:
        application/json:
          schema: { $ref: '#/components/schemas/CreateAPIKeyRequest' }
    responses:
      '201':
        description: Key created — raw key returned once
        content:
          application/json:
            schema: { $ref: '#/components/schemas/CreateAPIKeyResponse' }

/api/v1/admin/keys/{id}:
  patch:
    summary: Update an API key
    tags: [Admin]
    security: [{ BearerAuth: [] }]
    parameters:
      - in: path
        name: id
        required: true
        schema: { type: string }
    requestBody:
      content:
        application/json:
          schema: { $ref: '#/components/schemas/UpdateAPIKeyRequest' }
    responses:
      '200':
        description: Updated key metadata
        content:
          application/json:
            schema: { $ref: '#/components/schemas/APIKeyMeta' }
      '404':
        description: Key not found
  delete:
    summary: Revoke an API key
    tags: [Admin]
    security: [{ BearerAuth: [] }]
    parameters:
      - in: path
        name: id
        required: true
        schema: { type: string }
    responses:
      '204':
        description: Key revoked
      '404':
        description: Key not found
```

**Step 3: Validate**

```
make openapi-validate
```

Expected: validation passes with no errors.

**Step 4: Commit**

```
git add internal/api/openapi/openapi.yaml
git commit -m "docs(openapi): document API key management endpoints"
```

---

### Task 15: Final check

**Step 1: Run full test suite**

```
make check
```

Expected: fmt + vet + tests all pass.

**Step 2: Run integration tests**

```
make integration-test
```

Expected: PASS.

**Step 3: Build docs**

```
make docs-build
```

Expected: OpenAPI validation passes and docs site builds.

**Step 4: Commit if anything was adjusted**

```
git add -A
git commit -m "chore: final cleanup after key management implementation"
```