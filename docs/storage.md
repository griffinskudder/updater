# Storage

The updater service uses a pluggable storage layer that supports multiple backends for persisting application and release metadata. All providers implement the same `Storage` interface, enabling seamless switching between backends based on deployment needs.

## Architecture

```mermaid
graph TD
    A[Storage Interface] --> B[JSON File Storage]
    A --> C[Memory Storage]
    A --> D[PostgreSQL Storage]
    A --> E[SQLite Storage]
    F[Factory] --> A
    G[Configuration] --> F
    D --> H[sqlc Generated Queries]
    E --> I[sqlc Generated Queries]
    H --> J[PostgreSQL Database]
    I --> K[SQLite Database]
```

## Provider Comparison

| Feature | JSON | Memory | SQLite | PostgreSQL |
|---------|------|--------|--------|------------|
| Persistence | File-based | None (in-memory) | File-based | Server-based |
| Concurrency | Thread-safe with caching | Thread-safe (RWMutex) | Single writer (WAL mode) | Full concurrent access |
| Setup | No external dependencies | No setup needed | No external dependencies | Requires PostgreSQL server |
| Performance | Good for small datasets | Fastest (no I/O) | Good for medium datasets | Best for large datasets |
| Use Case | Development, small deployments | Testing, development | Single-server deployments | Production, multi-server |
| CGO Required | No | No | No (pure Go driver) | No |
| Schema Management | Automatic | Automatic | Automatic (embedded DDL) | Manual migration required |

## Storage Interface

All providers implement 15 methods covering application, release, and API key CRUD operations, plus health and lifecycle management:

```mermaid
classDiagram
    class Storage {
        <<interface>>
        +Applications(ctx) []*Application, error
        +GetApplication(ctx, appID) *Application, error
        +SaveApplication(ctx, app) error
        +DeleteApplication(ctx, appID) error
        +Releases(ctx, appID) []*Release, error
        +GetRelease(ctx, appID, version, platform, arch) *Release, error
        +SaveRelease(ctx, release) error
        +DeleteRelease(ctx, appID, version, platform, arch) error
        +GetLatestRelease(ctx, appID, platform, arch) *Release, error
        +GetReleasesAfterVersion(ctx, appID, version, platform, arch) []*Release, error
        +Ping(ctx) error
        +Close() error
        +CreateAPIKey(ctx, key) error
        +GetAPIKeyByHash(ctx, hash) *APIKey, error
        +ListAPIKeys(ctx) []*APIKey, error
        +UpdateAPIKey(ctx, key) error
        +DeleteAPIKey(ctx, id) error
    }
```

## Configuration

### JSON Storage

```yaml
storage:
  type: json
  path: ./data/releases.json
```

### Memory Storage

```yaml
storage:
  type: memory
```

### SQLite Storage

```yaml
storage:
  type: sqlite
  database:
    dsn: ./data/updater.db
```

### PostgreSQL Storage

```yaml
storage:
  type: postgres
  database:
    dsn: postgres://user:password@localhost:5432/updater?sslmode=disable
```

## Provider Details

### JSON File Storage

Stores all data in a single JSON file with an in-memory cache. Thread-safe using read-write mutexes with configurable cache TTL. Best suited for development and small deployments with limited data.

### Memory Storage

Stores data in Go maps protected by `sync.RWMutex`. Returns copies of all data to prevent external mutation. Data is lost on service restart. Ideal for testing and development environments.

### SQLite Storage

Uses the `modernc.org/sqlite` pure-Go driver (no CGO required). The schema is automatically created on startup using an embedded SQL file with `IF NOT EXISTS` guards. Key characteristics:

- **WAL mode** enabled for better concurrent read performance
- **Foreign keys** enabled for referential integrity
- **Single connection** to prevent concurrency issues with SQLite's single-writer model
- **Semantic version comparison** performed in Go after fetching results
- **Upsert pattern**: check-then-create/update for `SaveApplication` and `SaveRelease`

### PostgreSQL Storage

Uses `pgx/v5` with connection pooling via `pgxpool`. All queries are generated by sqlc for type safety. Key characteristics:

- **Connection pooling** for efficient resource usage
- **JSONB columns** for platforms, config, and metadata fields
- **Timestamptz** for proper timezone-aware timestamps
- **Cascade deletes** from applications to releases
- **Semantic version comparison** performed in Go after fetching results
- **Upsert pattern**: check-then-create/update for `SaveApplication` and `SaveRelease`

## Database Schema

Both database providers share the same logical schema with engine-specific type differences:

```mermaid
erDiagram
    applications {
        TEXT id PK
        TEXT name
        TEXT description
        JSON platforms
        JSON config
        TIMESTAMP created_at
        TIMESTAMP updated_at
    }
    releases {
        TEXT id PK
        TEXT application_id FK
        TEXT version
        TEXT platform
        TEXT architecture
        TEXT download_url
        TEXT checksum
        TEXT checksum_type
        BIGINT file_size
        TEXT release_notes
        TIMESTAMP release_date
        BOOLEAN required
        TEXT minimum_version
        JSON metadata
        TIMESTAMP created_at
    }
    api_keys {
        TEXT id PK
        TEXT name
        TEXT key_hash UK
        TEXT prefix
        TEXT permissions
        INTEGER enabled
        TIMESTAMP created_at
        TIMESTAMP updated_at
    }
    applications ||--o{ releases : "has many"
```

The `api_keys.permissions` column stores a JSON array of permission strings (e.g. `["admin"]`). The `enabled` column uses `INTEGER` (0/1) in SQLite and `BOOLEAN` in PostgreSQL.

### Type Differences

| Model Type | PostgreSQL | SQLite |
|-----------|-----------|--------|
| JSON fields | `JSONB` (binary, indexed) | `TEXT` (string) |
| Timestamps | `TIMESTAMPTZ` | `TEXT` (ISO8601) |
| Large integers | `BIGINT` | `INTEGER` |
| Nullable strings | `pgtype.Text` | `sql.NullString` |

## Type Conversion

Shared conversion helpers in `dbconvert.go` handle JSON marshaling for:

- **Platforms**: `[]string` to/from JSON
- **Config**: `ApplicationConfig` struct to/from JSON
- **Metadata**: `map[string]string` to/from JSON

Each provider has additional helpers for engine-specific type conversions (e.g., `pgtype.Text` for PostgreSQL, `sql.NullString` for SQLite).

## Factory Pattern

The `Factory` type provides centralized provider instantiation:

```go
factory := storage.NewFactory()
store, err := factory.Create(config.Storage)
```

The factory validates configuration before creating providers and supports all four backend types.

## Database Schema Docs

The auto-generated schema reference (including ER diagrams per table) lives in
the [Database](db/README.md) section. It is generated from the live
PostgreSQL schema by running:

```bash
make docs-db
```

## Testing

- **Memory**: Full CRUD tests with concurrency testing
- **JSON**: File I/O tests with caching and concurrent access
- **SQLite**: Full CRUD tests using `:memory:` (always runs, no external DB)
- **PostgreSQL**: Full CRUD tests skipped unless `POSTGRES_TEST_DSN` env var is set
