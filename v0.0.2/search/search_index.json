{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Updater Service Documentation","text":"<p>Welcome to the comprehensive documentation for the Updater Service, a Go-based software update service designed to be queried by desktop applications for checking and downloading updates.</p>"},{"location":"#overview","title":"Overview","text":"<p>The updater service acts as a metadata provider, referencing externally hosted download files rather than hosting the files directly. This design allows for efficient distribution via CDNs while maintaining a lightweight, scalable update service.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Semantic Versioning Support: Full semantic versioning compliance with flexible parsing</li> <li>Multi-Platform Support: Windows, Linux, macOS, Android, and iOS compatibility</li> <li>Security First: Strong cryptographic checksums and comprehensive validation</li> <li>Performance Optimized: Caching-friendly design with efficient querying</li> <li>Developer Friendly: Comprehensive API documentation and client libraries</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#architecture-documentation","title":"Architecture Documentation","text":"<p>Complete system design, API specification, and architectural decisions. Start here for system overview and design rationale.</p>"},{"location":"#models-documentation","title":"Models Documentation","text":"<p>Overview and auto-generated type reference for all data models:</p> <ul> <li>Model Reference - Complete auto-generated type reference (Application, Release, APIKey, Config, request/response types)</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#for-api-integration","title":"For API Integration","text":"<ol> <li>Review the Architecture Documentation for system overview</li> <li>Study API Models for request/response contracts</li> <li>Check the API Reference for the live Swagger UI</li> </ol>"},{"location":"#for-service-deployment","title":"For Service Deployment","text":"<ol> <li>Start with Configuration Models for setup options</li> <li>See Security for the API key management workflow</li> <li>Review security considerations across all components</li> </ol>"},{"location":"#for-development","title":"For Development","text":"<ol> <li>Follow the build instructions in the project README</li> <li>Use the provided Makefile commands for development workflow</li> <li>Refer to model documentation for implementation guidance</li> </ol>"},{"location":"#development-status","title":"Development Status","text":"Component Implementation Documentation Tests Models Layer Complete Complete Planned API Layer Planned Complete Planned Storage Layer Planned Complete Planned Business Logic Planned Complete Planned"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Layer (Planned)\"\n        api[HTTP Handlers &amp; Routing]\n    end\n\n    subgraph \"Business Logic (Planned)\"\n        logic[Update Determination &amp; Version Comparison]\n    end\n\n    subgraph \"Models Layer (COMPLETE)\"\n        subgraph \"Core Models\"\n            version[Version Models]\n            platform[Platform Models]\n            release[Release Models]\n            apimodels[API Models]\n        end\n        config[Configuration Models]\n    end\n\n    subgraph \"Storage Layer (Planned)\"\n        storage[Data Persistence &amp; Retrieval]\n    end\n\n    api --&gt; logic\n    logic --&gt; version\n    logic --&gt; platform\n    logic --&gt; release\n    logic --&gt; apimodels\n    logic --&gt; config\n    version --&gt; storage\n    platform --&gt; storage\n    release --&gt; storage\n    config --&gt; storage\n\n    classDef complete fill:#4caf50,stroke:#2e7d32,color:#fff\n    classDef planned fill:#ff9800,stroke:#f57c00,color:#fff\n\n    class version,platform,release,apimodels,config complete\n    class api,logic,storage planned</code></pre>"},{"location":"#core-principles","title":"Core Principles","text":""},{"location":"#security-first","title":"Security First","text":"<ul> <li>Strong cryptographic validation (SHA256 checksums)</li> <li>Comprehensive input validation and sanitization</li> <li>Safe defaults with security-conscious configuration</li> <li>Privacy-first approach (analytics disabled by default)</li> </ul>"},{"location":"#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Memory-efficient struct design and field ordering</li> <li>Caching-friendly response structures</li> <li>Pagination support for large datasets</li> <li>Minimal external dependencies</li> </ul>"},{"location":"#developer-experience","title":"Developer Experience","text":"<ul> <li>Clear error messages with actionable feedback</li> <li>Consistent naming following Go conventions</li> <li>Comprehensive examples and usage patterns</li> <li>Type safety to prevent runtime errors</li> </ul>"},{"location":"#extensibility","title":"Extensibility","text":"<ul> <li>Forward-compatible API design</li> <li>Extensible metadata systems</li> <li>Plugin-like configuration architecture</li> <li>Support for future enhancements</li> </ul>"},{"location":"#api-endpoints","title":"API Endpoints","text":"<p>The service provides RESTful API endpoints for update management:</p> <ul> <li><code>GET /api/v1/updates/{app_id}/check</code> - Check for available updates</li> <li><code>GET /api/v1/updates/{app_id}/latest</code> - Get latest version information</li> <li><code>GET /api/v1/updates/{app_id}/releases</code> - List all releases with filtering</li> <li><code>POST /api/v1/updates/{app_id}/register</code> - Register new release (admin)</li> </ul> <p>Detailed API documentation is available in the Architecture Documentation.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The service supports flexible configuration for different deployment scenarios:</p> <ul> <li>Development: JSON file storage, permissive settings, debug logging</li> <li>Production: Database storage, security hardening, structured logging</li> <li>Container: Environment variable configuration, health checks</li> </ul> <p>Full configuration options are documented in the Model Reference.</p>"},{"location":"#support-and-contributing","title":"Support and Contributing","text":""},{"location":"#development-workflow","title":"Development Workflow","text":"<ul> <li>Use provided Makefile commands for common tasks</li> <li>Follow Go conventions and security best practices</li> <li>Write comprehensive tests for all new functionality</li> <li>Update documentation for any changes</li> </ul>"},{"location":"#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Include design rationale for major decisions</li> <li>Provide practical usage examples</li> <li>Document security considerations</li> <li>Explain performance implications</li> </ul> <p>For more detailed development guidance, see the project's CLAUDE.md file and individual model documentation.</p>"},{"location":"ARCHITECTURE/","title":"Update Service Architecture","text":""},{"location":"ARCHITECTURE/#overview","title":"Overview","text":"<p>The updater service is designed to be queried by desktop applications to check for and download updates. The service acts as a metadata provider, referencing externally hosted download files rather than hosting the files directly. This design allows for efficient distribution via CDNs while maintaining a lightweight, scalable update service.</p>"},{"location":"ARCHITECTURE/#core-design-principles","title":"Core Design Principles","text":"<ol> <li>Stateless Design: The service doesn't store user-specific data, only release metadata</li> <li>External Storage: Download files are hosted separately (CDN/object storage)</li> <li>Flexible Storage: Support multiple storage backends for metadata</li> <li>Version Agnostic: Support semantic versioning and custom version schemes</li> <li>Platform Aware: Handle different OS/architecture combinations</li> <li>Caching Ready: Designed for CDN caching and local performance caching</li> <li>Extensible: Plugin-like architecture for different storage backends</li> </ol>"},{"location":"ARCHITECTURE/#architecture-components","title":"Architecture Components","text":""},{"location":"ARCHITECTURE/#1-api-layer-internalapi-complete","title":"1. API Layer (<code>internal/api/</code>) \u2705 COMPLETE","text":"<p>Fully implemented HTTP API with production-ready features and comprehensive security.</p> <p>Core Components: - Handlers (<code>handlers.go</code>): HTTP request/response processing for all endpoints - Middleware (<code>middleware.go</code>): Security, authentication, and request processing pipeline - Routes (<code>routes.go</code>): URL routing, CORS, rate limiting, and middleware orchestration</p> <p>Implemented Endpoints: - <code>GET /api/v1/updates/{app_id}/check</code> - Check for updates (public) - <code>POST /api/v1/check</code> - Check for updates via JSON body (public) - <code>GET /api/v1/updates/{app_id}/latest</code> - Get latest version (public) - <code>GET /api/v1/latest</code> - Get latest version with query params (public) - <code>GET /api/v1/updates/{app_id}/releases</code> - List releases (protected: read permission) - <code>POST /api/v1/updates/{app_id}/register</code> - Register new release (protected: write permission) - <code>DELETE /api/v1/updates/{app_id}/releases/{version}/{platform}/{arch}</code> - Delete a release (protected: admin permission) - <code>GET /api/v1/applications</code> - List applications (protected: read permission) - <code>GET /api/v1/applications/{app_id}</code> - Get application details (protected: read permission) - <code>POST /api/v1/applications</code> - Create application (protected: write permission) - <code>PUT /api/v1/applications/{app_id}</code> - Update application (protected: admin permission) - <code>DELETE /api/v1/applications/{app_id}</code> - Delete application (protected: admin permission) - <code>GET /health</code> - Health check (public with enhanced details for authenticated users) - <code>GET /api/v1/health</code> - Versioned health check alias (public) - <code>GET /api/v1/admin/keys</code> - List API keys (protected: admin permission) - <code>POST /api/v1/admin/keys</code> - Create API key; raw value returned once (protected: admin permission) - <code>PATCH /api/v1/admin/keys/{id}</code> - Update API key name, permissions, or enabled status (protected: admin permission) - <code>DELETE /api/v1/admin/keys/{id}</code> - Permanently revoke an API key (protected: admin permission) - <code>GET /api/v1/docs</code> - Swagger UI (public) - <code>GET /api/v1/openapi.yaml</code> - OpenAPI specification (public)</p> <p>Security Features: - API key authentication with Bearer token format - Role-based authorization (read/write/admin permissions with hierarchy) - CORS, rate limiting, and TLS delegated to the reverse proxy layer (see <code>docs/reverse-proxy.md</code>) - Request validation and structured error responses - Audit logging for all security-sensitive operations - Protection against common vulnerabilities (SQL injection, path traversal, etc.)</p> <p>Error Handling: - Structured ServiceError types with HTTP status code mapping - Consistent JSON error response format - Panic recovery middleware with proper logging - Request/response logging for debugging and monitoring</p>"},{"location":"ARCHITECTURE/#2-update-management-internalupdate-complete","title":"2. Update Management (<code>internal/update/</code>) \u2705 COMPLETE","text":"<p>Fully implemented business logic for version comparison and update determination.</p> <p>Core Components: - Service (<code>service.go</code>): Main business logic implementation - Interface (<code>interface.go</code>): Service contract definition - Errors (<code>errors.go</code>): Structured error types with HTTP status mapping</p> <p>Implemented Operations: - <code>CheckForUpdate()</code> - Intelligent update availability determination - <code>GetLatestVersion()</code> - Latest version retrieval with platform filtering - <code>ListReleases()</code> - Release listing with filtering, sorting, and pagination - <code>RegisterRelease()</code> - New release registration with validation</p> <p>Features: - Semantic versioning support with pre-release handling - Platform and architecture awareness - Update requirement rules (critical vs optional updates) - Minimum version enforcement - Pre-release filtering (configurable inclusion/exclusion) - Release metadata management with validation - Structured error responses with proper HTTP status codes</p>"},{"location":"ARCHITECTURE/#3-storage-layer-internalstorage-complete","title":"3. Storage Layer (<code>internal/storage/</code>) \u2705 COMPLETE","text":"<p>Multi-provider persistence layer with a unified interface and factory-based provider creation.</p> <p>Core Components: - Interface (<code>interface.go</code>): <code>Storage</code> interface with context support for all operations - Factory (<code>factory.go</code>): Factory pattern for creating providers by type string - Type Conversions (<code>dbconvert.go</code>): Shared database-to-model conversion helpers</p> <p>Storage Providers: - JSON (<code>json.go</code>): File-based storage using JSON, suitable for development and small deployments - Memory (<code>memory.go</code>): In-memory storage for testing and ephemeral use - PostgreSQL (<code>postgres.go</code>): Production database backend using sqlc-generated queries - SQLite (<code>sqlite.go</code>): Lightweight database backend using sqlc-generated queries</p> <p>Database Layer (<code>sqlc/</code>): - <code>schema/postgres/</code>, <code>schema/sqlite/</code>: Migration-friendly schemas (<code>001_initial.sql</code>, <code>002_add_indexes.sql</code>) - <code>queries/postgres/</code>, <code>queries/sqlite/</code>: Engine-specific SQL query definitions - <code>postgres/</code>, <code>sqlite/</code>: sqlc-generated type-safe Go code</p> <p>Key Patterns: - <code>context.Context</code> on all operations for cancellation and timeout support - Copy-on-return to prevent callers from mutating cached data - <code>Ping()</code> method on all providers for health check integration - <code>Close()</code> for clean resource release (database connections, file handles) - Auth middleware calls <code>GetAPIKeyByHash(ctx, sha256(bearerToken))</code> on every authenticated request \u2014 no plaintext keys are ever stored</p>"},{"location":"ARCHITECTURE/#4-models-internalmodels-complete","title":"4. Models (<code>internal/models/</code>) \u2705 COMPLETE","text":"<p>Data structures, domain objects, and validation logic.</p> <p>Core Files: - Application (<code>application.go</code>): Application metadata, platform support, configuration - Release (<code>release.go</code>): Release metadata, checksum validation, filtering - Request (<code>request.go</code>): API request types with validation - Response (<code>response.go</code>): API response types with helper constructors - Config (<code>config.go</code>): Service configuration schemas with defaults and validation - APIKey (<code>api_key.go</code>): Storage-backed API key with key generation, SHA-256 hashing, and permission checking</p> <p>Key Design Decisions: - Version comparison uses <code>github.com/Masterminds/semver/v3</code> directly (no separate version model) - All models include comprehensive validation methods - Response types use <code>omitempty</code> to minimize payload size - Configuration provides <code>NewDefaultConfig()</code> with safe production defaults</p>"},{"location":"ARCHITECTURE/#5-observability-internalobservability-complete","title":"5. Observability (<code>internal/observability/</code>) \u2705 COMPLETE","text":"<p>OpenTelemetry-based instrumentation for metrics, tracing, and storage monitoring.</p> <p>Core Components: - SDK Setup (<code>observability.go</code>): OpenTelemetry TracerProvider and MeterProvider initialization - Metrics Server (<code>metrics.go</code>): Prometheus HTTP metrics server on a separate port - Instrumented Storage (<code>storage.go</code>): <code>InstrumentedStorage</code> wrapper that adds operation-level metrics and tracing to any <code>Storage</code> implementation</p> <p>Exporters: - Prometheus (pull-based metrics) - stdout (development/debugging) - OTLP gRPC (for collectors like Jaeger, Grafana Tempo)</p> <p>Infrastructure: - <code>docker-compose.observability.yml</code>: Local Prometheus + Grafana stack - <code>configs/dev-observability.yaml</code>: Development configuration for the observability stack - <code>docker/prometheus/prometheus.yml</code>: Prometheus scrape configuration - <code>docker/grafana/provisioning/datasources/datasources.yml</code>: Grafana auto-provisioning</p>"},{"location":"ARCHITECTURE/#6-logging-internallogger-complete","title":"6. Logging (<code>internal/logger/</code>) \u2705 COMPLETE","text":"<p>Structured logging using Go's standard <code>log/slog</code> package.</p> <p>Core Components: - Logger Setup (<code>logger.go</code>): Configurable logger initialization with format, level, and output options</p> <p>Features: - JSON and text output formats - Configurable log levels (debug, info, warn, error) - File output with configurable permissions - Security audit events tagged with <code>\"event\", \"security_audit\"</code> - Global fields automatically included on all log messages (version, git_commit, build_date)</p>"},{"location":"ARCHITECTURE/#7-version-metadata-internalversion-complete","title":"7. Version Metadata (<code>internal/version/</code>) \u2705 COMPLETE","text":"<p>Build-time metadata injection and runtime version information.</p> <p>Core Components: - Version Package (<code>version.go</code>): Build metadata storage, instance ID generation, and thread-safe caching</p> <p>Features: - Build metadata injected via ldflags at compile time (VERSION, GIT_COMMIT, BUILD_DATE) - Runtime metadata generation (instance ID, hostname) - Thread-safe caching using <code>sync.Once</code> pattern - Global version fields on all log messages - OpenTelemetry resource attributes for traces and metrics - CLI <code>--version</code> flag for version display - HTTP <code>/version</code> endpoint for programmatic access</p> <p>Key Design: - Package-level variables populated by linker flags: <code>-X 'updater/internal/version.Version=$(VERSION)'</code> - <code>GetInfo()</code> function returns cached <code>Info</code> struct with all metadata - Instance ID generated once per process using UUID v4 - Hostname retrieved with fallback to \"unknown\" if unavailable - \"unknown\" values used for local development builds (CI injects proper values)</p> <p>Integration Points: - Logger: Version fields added as global fields via <code>slog.With()</code> - Observability: Version metadata added to OpenTelemetry resource attributes - API: <code>/version</code> endpoint serves version information as JSON - CLI: <code>--version</code> flag displays version in human-readable format</p>"},{"location":"ARCHITECTURE/#api-design","title":"API Design","text":""},{"location":"ARCHITECTURE/#core-endpoints","title":"Core Endpoints","text":""},{"location":"ARCHITECTURE/#check-for-updates","title":"Check for Updates","text":"<pre><code>GET /api/v1/updates/{app_id}/check?current_version=1.2.3&amp;platform=windows&amp;architecture=amd64\n</code></pre>"},{"location":"ARCHITECTURE/#get-latest-version-info","title":"Get Latest Version Info","text":"<pre><code>GET /api/v1/updates/{app_id}/latest?platform=windows&amp;architecture=amd64\n</code></pre>"},{"location":"ARCHITECTURE/#list-all-releases","title":"List All Releases","text":"<pre><code>GET /api/v1/updates/{app_id}/releases\n</code></pre>"},{"location":"ARCHITECTURE/#register-new-release-admin","title":"Register New Release (Admin)","text":"<pre><code>POST /api/v1/updates/{app_id}/register\n</code></pre>"},{"location":"ARCHITECTURE/#requestresponse-format","title":"Request/Response Format","text":""},{"location":"ARCHITECTURE/#update-check-request","title":"Update Check Request","text":"<p>Parameters can be provided via query params or headers: - <code>current_version</code>: Current application version - <code>platform</code>: Target platform (windows, linux, darwin) - <code>architecture</code>: Architecture (amd64, arm64, 386)</p>"},{"location":"ARCHITECTURE/#update-check-response","title":"Update Check Response","text":"<pre><code>{\n  \"update_available\": true,\n  \"latest_version\": \"1.3.0\",\n  \"current_version\": \"1.2.3\",\n  \"download_url\": \"https://releases.example.com/app/1.3.0/app-windows-amd64.exe\",\n  \"checksum\": \"abc123def456...\",\n  \"checksum_type\": \"sha256\",\n  \"file_size\": 15728640,\n  \"release_notes\": \"Bug fixes and improvements\",\n  \"release_date\": \"2024-02-14T10:00:00Z\",\n  \"required\": false,\n  \"minimum_version\": \"1.0.0\"\n}\n</code></pre>"},{"location":"ARCHITECTURE/#directory-structure","title":"Directory Structure","text":"<pre><code>.\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 updater/\n\u2502       \u2514\u2500\u2500 updater.go                # Server initialization and entry point\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 api/                          # HTTP handlers, middleware, routing\n\u2502   \u2502   \u251c\u2500\u2500 handlers.go\n\u2502   \u2502   \u251c\u2500\u2500 handlers_test.go\n\u2502   \u2502   \u251c\u2500\u2500 middleware.go\n\u2502   \u2502   \u251c\u2500\u2500 routes.go\n\u2502   \u2502   \u2514\u2500\u2500 security_test.go\n\u2502   \u251c\u2500\u2500 config/                       # Configuration loading\n\u2502   \u2502   \u251c\u2500\u2500 config.go\n\u2502   \u2502   \u2514\u2500\u2500 config_test.go\n\u2502   \u251c\u2500\u2500 integration/                  # Integration tests\n\u2502   \u2502   \u2514\u2500\u2500 integration_test.go\n\u2502   \u251c\u2500\u2500 logger/                       # Structured logging (log/slog)\n\u2502   \u2502   \u251c\u2500\u2500 logger.go\n\u2502   \u2502   \u2514\u2500\u2500 logger_test.go\n\u2502   \u251c\u2500\u2500 models/                       # Data models and validation\n\u2502   \u2502   \u251c\u2500\u2500 application.go\n\u2502   \u2502   \u251c\u2500\u2500 application_test.go\n\u2502   \u2502   \u251c\u2500\u2500 config.go\n\u2502   \u2502   \u251c\u2500\u2500 config_test.go\n\u2502   \u2502   \u251c\u2500\u2500 release.go\n\u2502   \u2502   \u251c\u2500\u2500 release_test.go\n\u2502   \u2502   \u251c\u2500\u2500 request.go\n\u2502   \u2502   \u251c\u2500\u2500 request_test.go\n\u2502   \u2502   \u251c\u2500\u2500 response.go\n\u2502   \u2502   \u2514\u2500\u2500 response_test.go\n\u2502   \u251c\u2500\u2500 observability/                # OpenTelemetry instrumentation\n\u2502   \u2502   \u251c\u2500\u2500 metrics.go\n\u2502   \u2502   \u251c\u2500\u2500 metrics_test.go\n\u2502   \u2502   \u251c\u2500\u2500 observability.go\n\u2502   \u2502   \u251c\u2500\u2500 observability_test.go\n\u2502   \u2502   \u251c\u2500\u2500 storage.go\n\u2502   \u2502   \u2514\u2500\u2500 storage_test.go\n\u2502   \u251c\u2500\u2500 storage/                      # Multi-provider persistence\n\u2502   \u2502   \u251c\u2500\u2500 dbconvert.go\n\u2502   \u2502   \u251c\u2500\u2500 dbconvert_test.go\n\u2502   \u2502   \u251c\u2500\u2500 factory.go\n\u2502   \u2502   \u251c\u2500\u2500 factory_test.go\n\u2502   \u2502   \u251c\u2500\u2500 interface.go\n\u2502   \u2502   \u251c\u2500\u2500 json.go\n\u2502   \u2502   \u251c\u2500\u2500 json_test.go\n\u2502   \u2502   \u251c\u2500\u2500 memory.go\n\u2502   \u2502   \u251c\u2500\u2500 memory_test.go\n\u2502   \u2502   \u251c\u2500\u2500 postgres.go\n\u2502   \u2502   \u251c\u2500\u2500 postgres_test.go\n\u2502   \u2502   \u251c\u2500\u2500 sqlite.go\n\u2502   \u2502   \u251c\u2500\u2500 sqlite_schema.sql\n\u2502   \u2502   \u251c\u2500\u2500 sqlite_test.go\n\u2502   \u2502   \u2514\u2500\u2500 sqlc/\n\u2502   \u2502       \u251c\u2500\u2500 postgres/             # Generated PostgreSQL queries\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 api_keys.sql.go\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 applications.sql.go\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 db.go\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 models.go\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 releases.sql.go\n\u2502   \u2502       \u251c\u2500\u2500 queries/              # SQL query definitions\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 postgres/\n\u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 api_keys.sql\n\u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 applications.sql\n\u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 releases.sql\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 sqlite/\n\u2502   \u2502       \u2502       \u251c\u2500\u2500 api_keys.sql\n\u2502   \u2502       \u2502       \u251c\u2500\u2500 applications.sql\n\u2502   \u2502       \u2502       \u2514\u2500\u2500 releases.sql\n\u2502   \u2502       \u251c\u2500\u2500 schema/               # Database migrations\n\u2502   \u2502       \u2502   \u251c\u2500\u2500 postgres/\n\u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 001_initial.sql\n\u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 002_add_indexes.sql\n\u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 003_fk_restrict.sql\n\u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 004_api_keys.sql\n\u2502   \u2502       \u2502   \u2514\u2500\u2500 sqlite/\n\u2502   \u2502       \u2502       \u251c\u2500\u2500 001_initial.sql\n\u2502   \u2502       \u2502       \u251c\u2500\u2500 002_add_indexes.sql\n\u2502   \u2502       \u2502       \u251c\u2500\u2500 003_fk_restrict.sql\n\u2502   \u2502       \u2502       \u2514\u2500\u2500 004_api_keys.sql\n\u2502   \u2502       \u2514\u2500\u2500 sqlite/               # Generated SQLite queries\n\u2502   \u2502           \u251c\u2500\u2500 api_keys.sql.go\n\u2502   \u2502           \u251c\u2500\u2500 applications.sql.go\n\u2502   \u2502           \u251c\u2500\u2500 db.go\n\u2502   \u2502           \u251c\u2500\u2500 models.go\n\u2502   \u2502           \u2514\u2500\u2500 releases.sql.go\n\u2502   \u2514\u2500\u2500 update/                       # Business logic\n\u2502       \u251c\u2500\u2500 errors.go\n\u2502       \u251c\u2500\u2500 interface.go\n\u2502       \u251c\u2500\u2500 service.go\n\u2502       \u2514\u2500\u2500 service_test.go\n\u251c\u2500\u2500 configs/\n\u2502   \u251c\u2500\u2500 dev-observability.yaml        # Local observability stack config\n\u2502   \u2514\u2500\u2500 security-examples.yaml        # Security configuration examples\n\u251c\u2500\u2500 data/\n\u2502   \u2514\u2500\u2500 releases.json                 # Default release metadata\n\u251c\u2500\u2500 deployments/\n\u2502   \u2514\u2500\u2500 kubernetes/\n\u2502       \u2514\u2500\u2500 deployment.yaml           # Kubernetes manifest\n\u251c\u2500\u2500 docker/\n\u2502   \u251c\u2500\u2500 grafana/\n\u2502   \u2502   \u2514\u2500\u2500 provisioning/\n\u2502   \u2502       \u2514\u2500\u2500 datasources/\n\u2502   \u2502           \u2514\u2500\u2500 datasources.yml\n\u2502   \u251c\u2500\u2500 nginx/\n\u2502   \u2502   \u2514\u2500\u2500 nginx.conf\n\u2502   \u2514\u2500\u2500 prometheus/\n\u2502       \u2514\u2500\u2500 prometheus.yml\n\u251c\u2500\u2500 docs/                             # MkDocs documentation site\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 config.yaml                   # Example application config\n\u2502   \u2514\u2500\u2500 releases.json                 # Example release data\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 docker-build.sh               # Docker build script\n\u251c\u2500\u2500 Dockerfile                        # Multi-stage container build\n\u251c\u2500\u2500 Makefile                          # Build automation\n\u251c\u2500\u2500 docker-compose.yml                # Application stack\n\u251c\u2500\u2500 docker-compose.observability.yml  # Observability stack (Prometheus, Grafana)\n\u251c\u2500\u2500 mkdocs.yml                        # Documentation site config\n\u251c\u2500\u2500 sqlc.yaml                         # SQL code generation config\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 go.sum\n</code></pre>"},{"location":"ARCHITECTURE/#data-models","title":"Data Models","text":""},{"location":"ARCHITECTURE/#application","title":"Application","text":"<pre><code>type Application struct {\n    ID          string            `json:\"id\"`\n    Name        string            `json:\"name\"`\n    Description string            `json:\"description\"`\n    Platforms   []string          `json:\"platforms\"`\n    Config      ApplicationConfig `json:\"config\"`\n}\n</code></pre>"},{"location":"ARCHITECTURE/#release","title":"Release","text":"<pre><code>type Release struct {\n    ID           string            `json:\"id\"`\n    ApplicationID string           `json:\"application_id\"`\n    Version      string            `json:\"version\"`\n    Platform     string            `json:\"platform\"`\n    Architecture string            `json:\"architecture\"`\n    DownloadURL  string            `json:\"download_url\"`\n    Checksum     string            `json:\"checksum\"`\n    ChecksumType string            `json:\"checksum_type\"`\n    FileSize     int64             `json:\"file_size\"`\n    ReleaseNotes string            `json:\"release_notes\"`\n    ReleaseDate  time.Time         `json:\"release_date\"`\n    Required     bool              `json:\"required\"`\n    MinimumVersion string          `json:\"minimum_version,omitempty\"`\n    Metadata     map[string]string `json:\"metadata,omitempty\"`\n}\n</code></pre>"},{"location":"ARCHITECTURE/#security-architecture","title":"Security Architecture","text":""},{"location":"ARCHITECTURE/#overview_1","title":"Overview","text":"<p>The updater service implements a comprehensive multi-layered security architecture following defense-in-depth principles. The security model protects against unauthorized access, data tampering, and service abuse while maintaining high availability and performance.</p>"},{"location":"ARCHITECTURE/#security-flow-diagram","title":"Security Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant RP as Reverse Proxy\n    participant AM as Auth Middleware\n    participant PM as Permission Middleware\n    participant H as Handler\n    participant S as Storage\n\n    C-&gt;&gt;RP: HTTPS Request\n    RP-&gt;&gt;AM: Rate/CORS checked; plain HTTP forwarded\n    AM-&gt;&gt;AM: Validate API Key\n    AM-&gt;&gt;PM: Authentication Success\n    PM-&gt;&gt;PM: Check Permissions\n    PM-&gt;&gt;H: Authorization Success\n    H-&gt;&gt;S: Business Logic\n    S-&gt;&gt;H: Data Response\n    H-&gt;&gt;C: JSON Response\n\n    Note over AM,PM: Security Context Added\n    Note over H: Audit Logging</code></pre>"},{"location":"ARCHITECTURE/#security-layers","title":"Security Layers","text":""},{"location":"ARCHITECTURE/#1-network-security-layer-implemented","title":"1. Network Security Layer \u2705 IMPLEMENTED","text":"<ul> <li>TLS/HTTPS Enforcement: All communications encrypted in transit</li> <li>CORS, rate limiting, and TLS delegated to the reverse proxy layer (see <code>docs/reverse-proxy.md</code>)</li> </ul>"},{"location":"ARCHITECTURE/#2-authentication-layer-implemented","title":"2. Authentication Layer \u2705 IMPLEMENTED","text":"<ul> <li>API Key Authentication: Bearer token-based authentication system (<code>authMiddleware</code>)</li> <li>Key Management: Support for multiple keys with individual enable/disable</li> <li>Optional Authentication: <code>OptionalAuth</code> middleware for endpoints that enhance data based on auth status</li> <li>Secure Key Storage: Environment variable and secure configuration support</li> <li>Context Propagation: Security context passed through request lifecycle</li> </ul>"},{"location":"ARCHITECTURE/#3-authorization-layer-implemented","title":"3. Authorization Layer \u2705 IMPLEMENTED","text":"<ul> <li>Permission-Based Access Control: Granular permissions per API key (read/write/admin)</li> <li>Permission Hierarchy: Admin includes write, write includes read permissions</li> <li>Endpoint Protection: <code>RequirePermission</code> middleware enforces different permission requirements</li> <li>Principle of Least Privilege: Minimal permissions by default</li> <li>Security Context: <code>SecurityContext</code> type for permission validation</li> </ul>"},{"location":"ARCHITECTURE/#4-application-security-layer-implemented","title":"4. Application Security Layer \u2705 IMPLEMENTED","text":"<ul> <li>Input Validation: Comprehensive validation of all request data with structured error responses</li> <li>Output Sanitization: Secure error messages without information leakage using <code>ServiceError</code> types</li> <li>Request Size Limits: Protection against large payload attacks</li> <li>Header Injection Protection: Validation of HTTP headers for malicious content</li> <li>Path Traversal Protection: URL path validation and sanitization</li> <li>JSON Parsing Security: Secure JSON parsing with error handling</li> </ul>"},{"location":"ARCHITECTURE/#5-operational-security-layer-implemented","title":"5. Operational Security Layer \u2705 IMPLEMENTED","text":"<ul> <li>Audit Logging: Comprehensive security event logging with client IP identification</li> <li>Health Monitoring: Service health checks with authenticated enhanced details</li> <li>Panic Recovery: <code>recoveryMiddleware</code> handles panics gracefully</li> <li>Request Logging: <code>loggingMiddleware</code> for request/response monitoring</li> <li>Client IP Detection: <code>getClientIP</code> function with proxy support (X-Forwarded-For, X-Real-IP)</li> </ul>"},{"location":"ARCHITECTURE/#permission-model","title":"Permission Model","text":""},{"location":"ARCHITECTURE/#permission-types","title":"Permission Types","text":"Permission Scope Endpoints Description <code>read</code> Query Operations <code>GET /api/v1/updates/*</code>, <code>GET /api/v1/applications*</code> Access to update checking, release information, and application details <code>write</code> Release &amp; App Creation <code>POST /api/v1/updates/*/register</code>, <code>POST /api/v1/applications</code> Register releases and create applications <code>admin</code> Full Access All endpoints including <code>PUT</code>, <code>DELETE</code> on applications and releases Complete administrative access"},{"location":"ARCHITECTURE/#permission-matrix","title":"Permission Matrix","text":"<pre><code>Endpoint                                                        | read | write | admin\n----------------------------------------------------------------|------|-------|-------\nGET    /api/v1/updates/{app}/check                              |  \u2713   |   \u2713   |   \u2713\nGET    /api/v1/updates/{app}/latest                             |  \u2713   |   \u2713   |   \u2713\nGET    /api/v1/updates/{app}/releases                           |  \u2713   |   \u2713   |   \u2713\nPOST   /api/v1/updates/{app}/register                           |  \u2717   |   \u2713   |   \u2713\nDELETE /api/v1/updates/{app}/releases/{ver}/{plat}/{arch}        |  \u2717   |   \u2717   |   \u2713\nGET    /api/v1/applications                                     |  \u2713   |   \u2713   |   \u2713\nGET    /api/v1/applications/{app}                               |  \u2713   |   \u2713   |   \u2713\nPOST   /api/v1/applications                                     |  \u2717   |   \u2713   |   \u2713\nPUT    /api/v1/applications/{app}                               |  \u2717   |   \u2717   |   \u2713\nDELETE /api/v1/applications/{app}                               |  \u2717   |   \u2717   |   \u2713\nGET    /health                                                  |  \u2713   |   \u2713   |   \u2713\n</code></pre>"},{"location":"ARCHITECTURE/#permission-inheritance","title":"Permission Inheritance","text":"<ul> <li><code>admin</code> permission grants access to all operations</li> <li><code>write</code> permission includes all <code>read</code> operations</li> <li>Permissions are cumulative, not exclusive</li> </ul>"},{"location":"ARCHITECTURE/#security-configuration","title":"Security Configuration","text":""},{"location":"ARCHITECTURE/#production-security-settings","title":"Production Security Settings","text":"<pre><code>server:\n  tls_enabled: true\n  tls_cert_file: \"/etc/ssl/certs/updater.pem\"\n  tls_key_file: \"/etc/ssl/private/updater.key\"\n\nsecurity:\n  enable_auth: true\n  bootstrap_key: \"${UPDATER_BOOTSTRAP_KEY}\"\n</code></pre> <p>CORS, rate limiting, and TLS are configured at the reverse proxy. See Reverse Proxy for examples.</p>"},{"location":"ARCHITECTURE/#threat-mitigation","title":"Threat Mitigation","text":""},{"location":"ARCHITECTURE/#identified-threats-and-countermeasures","title":"Identified Threats and Countermeasures","text":"<ol> <li>Unauthorized Release Injection</li> <li>Threat: Malicious actors registering fake releases</li> <li>Mitigation: API key authentication + write permission requirement</li> <li> <p>Detection: Audit logging of all release operations</p> </li> <li> <p>API Key Compromise</p> </li> <li>Threat: Stolen or leaked API keys</li> <li>Mitigation: Permission scoping + key rotation + rate limiting</li> <li> <p>Detection: Unusual usage pattern monitoring</p> </li> <li> <p>Denial of Service</p> </li> <li>Threat: Service overwhelm through request flooding</li> <li>Mitigation: Rate limiting + connection limits + graceful degradation</li> <li> <p>Detection: Request rate monitoring and alerting</p> </li> <li> <p>Version Downgrade Attack</p> </li> <li>Threat: Forcing clients to use vulnerable versions</li> <li>Mitigation: Checksum validation + version constraint enforcement</li> <li>Detection: Checksum mismatch logging</li> </ol>"},{"location":"ARCHITECTURE/#security-monitoring","title":"Security Monitoring","text":""},{"location":"ARCHITECTURE/#security-event-logging","title":"Security Event Logging","text":"<p>All security-relevant events are logged with structured JSON format:</p> <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"level\": \"WARN\",\n  \"component\": \"auth\",\n  \"event\": \"permission_denied\",\n  \"message\": \"Insufficient permissions for endpoint\",\n  \"client_ip\": \"192.168.1.100\",\n  \"api_key_name\": \"Monitoring System\",\n  \"endpoint\": \"/api/v1/updates/myapp/register\",\n  \"required_permission\": \"write\",\n  \"user_permissions\": [\"read\"],\n  \"request_id\": \"req_123456\"\n}\n</code></pre>"},{"location":"ARCHITECTURE/#monitored-security-events","title":"Monitored Security Events","text":"<ul> <li>Authentication failures and successes</li> <li>Authorization failures (insufficient permissions)</li> <li>Rate limit violations</li> <li>Suspicious request patterns</li> <li>Admin operations (release registration)</li> <li>Configuration changes</li> <li>Health check failures</li> </ul>"},{"location":"ARCHITECTURE/#authentication-authorization","title":"Authentication &amp; Authorization","text":""},{"location":"ARCHITECTURE/#api-key-format","title":"API Key Format","text":"<pre><code>GET /api/v1/updates/myapp/check HTTP/1.1\nHost: updater.example.com\nAuthorization: Bearer &lt;base64-encoded-api-key&gt;\nContent-Type: application/json\n</code></pre>"},{"location":"ARCHITECTURE/#authentication-flow","title":"Authentication Flow","text":"<ol> <li>Request Reception: Extract Authorization header</li> <li>Format Validation: Verify Bearer token format</li> <li>Key Lookup: Find matching API key in configuration</li> <li>Status Check: Verify key is enabled</li> <li>Context Enhancement: Add key information to request context</li> </ol>"},{"location":"ARCHITECTURE/#authorization-flow","title":"Authorization Flow","text":"<ol> <li>Endpoint Mapping: Determine required permission for endpoint</li> <li>Permission Check: Verify API key has required permission</li> <li>Access Grant: Proceed with request processing</li> <li>Audit Log: Record authorization decision</li> </ol>"},{"location":"ARCHITECTURE/#data-integrity","title":"Data Integrity","text":""},{"location":"ARCHITECTURE/#checksum-validation","title":"Checksum Validation","text":"<ul> <li>SHA256 Checksums: All releases must include SHA256 checksums</li> <li>Validation: Optional checksum verification before serving</li> <li>Storage: Checksums stored alongside release metadata</li> <li>Transmission: Checksums included in API responses</li> </ul>"},{"location":"ARCHITECTURE/#https-enforcement","title":"HTTPS Enforcement","text":"<ul> <li>TLS Configuration: Modern TLS versions (1.2+) required</li> <li>Certificate Management: Support for Let's Encrypt and custom certificates</li> <li>Header Security: Security headers (HSTS, CSP) configurable</li> <li>Redirect: HTTP to HTTPS redirects in production</li> </ul>"},{"location":"ARCHITECTURE/#privacy-protection","title":"Privacy Protection","text":""},{"location":"ARCHITECTURE/#data-minimization","title":"Data Minimization","text":"<ul> <li>No Personal Data: Service doesn't collect personally identifiable information</li> <li>Minimal Logging: Only necessary operational data logged</li> <li>Retention Policies: Configurable log retention periods</li> <li>Anonymization: IP addresses can be anonymized in logs</li> </ul>"},{"location":"ARCHITECTURE/#analytics","title":"Analytics","text":"<ul> <li>Disabled by Default: Analytics collection disabled by default</li> <li>Opt-in: Explicit configuration required for analytics</li> <li>Aggregated Only: No individual user tracking</li> <li>Configurable: Granular control over collected metrics</li> </ul>"},{"location":"ARCHITECTURE/#configuration-management","title":"Configuration Management","text":""},{"location":"ARCHITECTURE/#environment-variables","title":"Environment Variables","text":"<p>Configuration is loaded from a YAML file (via <code>-config</code> CLI flag) and overridden by environment variables.</p> <p>Server: - <code>UPDATER_PORT</code>: Server port (default: 8080) - <code>UPDATER_HOST</code>: Bind address (default: \"\") - <code>UPDATER_READ_TIMEOUT</code>: HTTP read timeout (default: 30s) - <code>UPDATER_WRITE_TIMEOUT</code>: HTTP write timeout (default: 30s) - <code>UPDATER_IDLE_TIMEOUT</code>: HTTP idle timeout (default: 120s) - <code>UPDATER_TLS_ENABLED</code>: Enable TLS (default: false) - <code>UPDATER_TLS_CERT_FILE</code>: Path to TLS certificate - <code>UPDATER_TLS_KEY_FILE</code>: Path to TLS private key</p> <p>Storage: - <code>UPDATER_STORAGE_TYPE</code>: Storage backend (json, memory, postgres, sqlite) - <code>UPDATER_STORAGE_PATH</code>: File path for JSON storage - <code>UPDATER_DATABASE_DSN</code>: Database connection string - <code>UPDATER_DATABASE_DRIVER</code>: Database driver (postgres, sqlite) - <code>UPDATER_DATABASE_MAX_OPEN_CONNS</code>: Maximum open database connections - <code>UPDATER_DATABASE_MAX_IDLE_CONNS</code>: Maximum idle database connections</p> <p>Security: - <code>UPDATER_ENABLE_AUTH</code>: Enable API key authentication (default: false) - <code>UPDATER_BOOTSTRAP_KEY</code>: Initial admin API key seeded on first startup - CORS, rate limiting, and TLS are handled by the reverse proxy (see Reverse Proxy)</p> <p>Logging: - <code>UPDATER_LOG_LEVEL</code>: Log level (debug, info, warn, error) - <code>UPDATER_LOG_FORMAT</code>: Output format (json, text) - <code>UPDATER_LOG_OUTPUT</code>: Output destination (stdout, stderr, file) - <code>UPDATER_LOG_FILE_PATH</code>: Log file path (when output is file) - <code>UPDATER_LOG_MAX_SIZE</code>: Max log file size in MB - <code>UPDATER_LOG_MAX_BACKUPS</code>: Max number of old log files - <code>UPDATER_LOG_MAX_AGE</code>: Max age of old log files in days - <code>UPDATER_LOG_COMPRESS</code>: Compress rotated log files</p> <p>Cache: - <code>UPDATER_CACHE_ENABLED</code>: Enable caching (default: false) - <code>UPDATER_CACHE_TYPE</code>: Cache type (memory, redis) - <code>UPDATER_CACHE_TTL</code>: Cache TTL duration - <code>UPDATER_REDIS_ADDR</code>: Redis address - <code>UPDATER_REDIS_PASSWORD</code>: Redis password - <code>UPDATER_REDIS_DB</code>: Redis database number - <code>UPDATER_REDIS_POOL_SIZE</code>: Redis connection pool size - <code>UPDATER_MEMORY_CACHE_MAX_SIZE</code>: Memory cache max entries - <code>UPDATER_MEMORY_CACHE_CLEANUP_INTERVAL</code>: Memory cache cleanup interval</p> <p>Metrics: - <code>UPDATER_METRICS_ENABLED</code>: Enable Prometheus metrics (default: false) - <code>UPDATER_METRICS_PATH</code>: Metrics endpoint path (default: /metrics) - <code>UPDATER_METRICS_PORT</code>: Metrics server port (default: 9090)</p>"},{"location":"ARCHITECTURE/#configuration-file-structure","title":"Configuration File Structure","text":"<pre><code>server:\n  port: 8080\n  host: \"\"\n  read_timeout: 30s\n  write_timeout: 30s\n  idle_timeout: 120s\n  tls_enabled: false\n  tls_cert_file: \"\"\n  tls_key_file: \"\"\nstorage:\n  type: json\n  path: ./data/releases.json\n  database:\n    dsn: \"\"\n    driver: \"\"\n    max_open_conns: 25\n    max_idle_conns: 5\n\nsecurity:\n  enable_auth: false\n  bootstrap_key: \"\"\n\ncache:\n  enabled: false\n  type: memory\n  ttl: 300s\n\nmetrics:\n  enabled: false\n  path: /metrics\n  port: 9090\n\nlogging:\n  level: info\n  format: json\n  output: stdout\n</code></pre>"},{"location":"ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":""},{"location":"ARCHITECTURE/#caching-strategy","title":"Caching Strategy","text":"<ul> <li>In-memory caching of frequently requested releases</li> <li>HTTP cache headers for CDN optimization</li> <li>Configurable cache TTL per endpoint</li> </ul>"},{"location":"ARCHITECTURE/#scalability","title":"Scalability","text":"<ul> <li>Stateless design enables horizontal scaling</li> <li>Database connection pooling</li> <li>Efficient indexing on version and platform fields</li> </ul>"},{"location":"ARCHITECTURE/#deployment-options","title":"Deployment Options","text":""},{"location":"ARCHITECTURE/#standalone-binary","title":"Standalone Binary","text":"<ul> <li>Single executable with embedded configuration</li> <li>Suitable for small deployments</li> <li>File-based storage backend</li> </ul>"},{"location":"ARCHITECTURE/#containerized-deployment","title":"Containerized Deployment","text":"<ul> <li>Docker container with external configuration</li> <li>Kubernetes deployment with ConfigMaps</li> <li>External database backend</li> </ul>"},{"location":"ARCHITECTURE/#serverless","title":"Serverless","text":"<ul> <li>AWS Lambda or similar for API handlers</li> <li>DynamoDB or similar for metadata storage</li> <li>CloudFront for caching</li> </ul>"},{"location":"ARCHITECTURE/#completed-enhancements","title":"Completed Enhancements","text":"<p>The following features have been implemented since the initial architecture design:</p> <ul> <li>Prometheus metrics -- <code>internal/observability/metrics.go</code>, exposed on a dedicated port</li> <li>Health check endpoints -- <code>GET /health</code> and <code>GET /api/v1/health</code> with storage ping and auth-enhanced details</li> <li>Request tracing -- OpenTelemetry integration via <code>internal/observability/observability.go</code></li> <li>Audit logging -- Security events logged in middleware with <code>\"event\", \"security_audit\"</code> tags</li> <li>PostgreSQL support -- <code>internal/storage/postgres.go</code> with sqlc-generated queries</li> <li>SQLite support -- <code>internal/storage/sqlite.go</code> with sqlc-generated queries</li> </ul>"},{"location":"ARCHITECTURE/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>Advanced Features</li> <li>Delta updates support</li> <li>Rollback functionality</li> <li> <p>A/B testing for releases</p> </li> <li> <p>Security Enhancements</p> </li> <li>Release signing and verification</li> <li> <p>OAuth2/JWT authentication</p> </li> <li> <p>Storage Backends</p> </li> <li>Redis caching</li> <li>S3-compatible object storage</li> </ol>"},{"location":"ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":""},{"location":"ARCHITECTURE/#unit-tests","title":"Unit Tests","text":"<ul> <li>Table-driven tests with co-located <code>*_test.go</code> files alongside source</li> <li>Memory provider (<code>memory.go</code>) used as a fast fake for storage tests</li> <li>Concurrency tests to verify thread safety of shared state</li> <li>Coverage across all packages: models, update logic, API handlers, storage providers, config, logger, observability</li> </ul>"},{"location":"ARCHITECTURE/#integration-tests","title":"Integration Tests","text":"<ul> <li>Dedicated <code>internal/integration/</code> package for cross-layer tests</li> <li>API endpoint testing with full middleware stack</li> <li>Storage backend integration with real providers</li> </ul>"},{"location":"ARCHITECTURE/#test-patterns","title":"Test Patterns","text":"<ul> <li>Consistent use of <code>t.Run()</code> subtests for grouped test cases</li> <li><code>t.Helper()</code> for shared assertion functions</li> <li><code>t.Parallel()</code> where test isolation permits</li> </ul>"},{"location":"DEPLOYMENT_SECURITY/","title":"Secure Deployment Guide","text":""},{"location":"DEPLOYMENT_SECURITY/#overview","title":"Overview","text":"<p>This guide provides comprehensive instructions for deploying the updater service securely across different environments. It covers configuration, best practices, and security considerations for production deployments.</p>"},{"location":"DEPLOYMENT_SECURITY/#quick-start-security-checklist","title":"Quick Start Security Checklist","text":"<p>Before deploying to production, ensure you have completed these critical security steps:</p> <ul> <li>[ ] TLS/HTTPS enabled with valid certificates</li> <li>[ ] API keys generated with cryptographically secure random values (32+ characters)</li> <li>[ ] Environment variables configured for all sensitive values</li> <li>[ ] Rate limiting enabled with appropriate limits for your use case</li> <li>[ ] CORS configured with specific allowed origins (no wildcards in production)</li> <li>[ ] Monitoring and logging configured for security events</li> <li>[ ] Regular key rotation schedule established</li> <li>[ ] Backup recovery plan tested and documented</li> </ul>"},{"location":"DEPLOYMENT_SECURITY/#environment-configurations","title":"Environment Configurations","text":""},{"location":"DEPLOYMENT_SECURITY/#development-environment","title":"Development Environment","text":"<p>For local development and testing:</p> <pre><code># Use the development configuration\ncp configs/security-examples.yaml config.yaml\n\n# Set environment variables\nexport UPDATER_CONFIG_SECTION=\"development\"\nexport UPDATER_LOG_LEVEL=\"debug\"\n\n# Generate development API keys\nopenssl rand -base64 32  # Use output for dev-admin-key\nopenssl rand -base64 32  # Use output for dev-read-key\n</code></pre> <p>Security Notes for Development: - Use strong API keys even in development - Enable authentication to test security flows - Use lenient rate limiting for testing - TLS can be disabled for localhost testing</p>"},{"location":"DEPLOYMENT_SECURITY/#staging-environment","title":"Staging Environment","text":"<p>For staging/pre-production testing:</p> <pre><code># Set environment variables\nexport UPDATER_CONFIG_SECTION=\"staging\"\nexport STAGING_ADMIN_API_KEY=\"$(openssl rand -base64 32)\"\nexport STAGING_RELEASE_API_KEY=\"$(openssl rand -base64 32)\"\nexport STAGING_READONLY_API_KEY=\"$(openssl rand -base64 32)\"\n\n# Configure TLS certificates\nsudo mkdir -p /etc/ssl/certs /etc/ssl/private\nsudo cp staging.crt /etc/ssl/certs/staging.pem\nsudo cp staging.key /etc/ssl/private/staging.key\nsudo chmod 644 /etc/ssl/certs/staging.pem\nsudo chmod 600 /etc/ssl/private/staging.key\n</code></pre>"},{"location":"DEPLOYMENT_SECURITY/#production-environment","title":"Production Environment","text":"<p>For production deployments:</p> <pre><code># Set environment variables (use your secrets management system)\nexport UPDATER_CONFIG_SECTION=\"production\"\nexport PRODUCTION_ADMIN_API_KEY=\"YOUR_SECURE_ADMIN_KEY\"\nexport PRODUCTION_RELEASE_API_KEY=\"YOUR_SECURE_RELEASE_KEY\"\nexport PRODUCTION_MONITORING_API_KEY=\"YOUR_SECURE_MONITORING_KEY\"\nexport DATABASE_URL=\"your_database_connection_string\"\n\n# Configure production TLS certificates\nsudo cp production.crt /etc/ssl/certs/production.pem\nsudo cp production.key /etc/ssl/private/production.key\nsudo chmod 644 /etc/ssl/certs/production.pem\nsudo chmod 600 /etc/ssl/private/production.key\n</code></pre>"},{"location":"DEPLOYMENT_SECURITY/#api-key-management","title":"API Key Management","text":""},{"location":"DEPLOYMENT_SECURITY/#generating-secure-api-keys","title":"Generating Secure API Keys","text":"<p>Recommended Method: <pre><code># Generate a 64-character (512-bit) API key\nopenssl rand -base64 48 | tr -d '\\n'; echo\n\n# Alternative using system random\nhead -c 32 /dev/urandom | base64 | tr -d '\\n'; echo\n</code></pre></p> <p>Key Requirements: - Minimum 32 characters (256 bits of entropy) - Use cryptographically secure random generation - Avoid predictable patterns or dictionary words - Store in secure environment variables or secrets management</p>"},{"location":"DEPLOYMENT_SECURITY/#key-rotation-strategy","title":"Key Rotation Strategy","text":"<p>Recommended Rotation Schedule: - Production: Every 90 days - Staging: Every 6 months - Development: As needed</p> <p>Zero-Downtime Rotation Process: 1. Generate new API key 2. Add new key to configuration (keeping old key enabled) 3. Update client applications to use new key 4. Verify new key works in logs 5. Disable old key in configuration 6. Remove old key after grace period</p> <p>Example Rotation Configuration: <pre><code>api_keys:\n  # New key\n  - key: \"${NEW_ADMIN_API_KEY}\"\n    name: \"Admin Key v2\"\n    permissions: [\"admin\"]\n    enabled: true\n\n  # Old key (grace period)\n  - key: \"${OLD_ADMIN_API_KEY}\"\n    name: \"Admin Key v1 (deprecated)\"\n    permissions: [\"admin\"]\n    enabled: true  # Disable after client migration\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#tlshttps-configuration","title":"TLS/HTTPS Configuration","text":""},{"location":"DEPLOYMENT_SECURITY/#certificate-requirements","title":"Certificate Requirements","text":"<p>Production Requirements: - Valid SSL certificate from trusted CA - Support for modern TLS versions (1.2+) - Strong cipher suites - HSTS headers configured</p> <p>Certificate Sources: - Let's Encrypt (free, automated) - Commercial CA (extended validation) - Internal CA (for private networks)</p>"},{"location":"DEPLOYMENT_SECURITY/#lets-encrypt-setup","title":"Let's Encrypt Setup","text":"<pre><code># Install certbot\nsudo apt-get install certbot\n\n# Generate certificate\nsudo certbot certonly --standalone -d api.yourdomain.com\n\n# Configure automatic renewal\nsudo crontab -e\n# Add: 0 12 * * * /usr/bin/certbot renew --quiet\n\n# Update configuration paths\nexport TLS_CERT_FILE=\"/etc/letsencrypt/live/api.yourdomain.com/fullchain.pem\"\nexport TLS_KEY_FILE=\"/etc/letsencrypt/live/api.yourdomain.com/privkey.pem\"\n</code></pre>"},{"location":"DEPLOYMENT_SECURITY/#load-balancer-tls-termination","title":"Load Balancer TLS Termination","text":"<p>When using a load balancer (recommended for production):</p> <pre><code># Application configuration (TLS terminated at load balancer)\nserver:\n  tls_enabled: false  # TLS handled by load balancer\n  port: 8080\n\nsecurity:\n  # Configure trusted proxy networks\n  trusted_proxies:\n    - \"10.0.0.0/8\"      # Load balancer subnet\n    - \"172.16.0.0/12\"   # Internal networks\n</code></pre>"},{"location":"DEPLOYMENT_SECURITY/#cloud-deployment-examples","title":"Cloud Deployment Examples","text":""},{"location":"DEPLOYMENT_SECURITY/#aws-deployment","title":"AWS Deployment","text":"<p>ECS Configuration: <pre><code>{\n  \"family\": \"updater-service\",\n  \"taskDefinition\": {\n    \"secrets\": [\n      {\n        \"name\": \"PRODUCTION_ADMIN_API_KEY\",\n        \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:updater/admin-key\"\n      },\n      {\n        \"name\": \"DATABASE_URL\",\n        \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:updater/db-connection\"\n      }\n    ],\n    \"environment\": [\n      {\n        \"name\": \"UPDATER_CONFIG_SECTION\",\n        \"value\": \"aws_production\"\n      }\n    ]\n  }\n}\n</code></pre></p> <p>Application Load Balancer Security Groups: <pre><code># ALB Security Group\nType: AWS::EC2::SecurityGroup\nProperties:\n  GroupDescription: Security group for updater ALB\n  SecurityGroupIngress:\n    - IpProtocol: tcp\n      FromPort: 443\n      ToPort: 443\n      CidrIp: 0.0.0.0/0  # Restrict to your IP ranges\n    - IpProtocol: tcp\n      FromPort: 80\n      ToPort: 80\n      CidrIp: 0.0.0.0/0  # For HTTP -&gt; HTTPS redirect\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#google-cloud-deployment","title":"Google Cloud Deployment","text":"<p>Cloud Run Configuration: <pre><code>apiVersion: serving.knative.dev/v1\nkind: Service\nmetadata:\n  name: updater-service\n  annotations:\n    run.googleapis.com/ingress: all\nspec:\n  template:\n    metadata:\n      annotations:\n        autoscaling.knative.dev/maxScale: \"100\"\n    spec:\n      containerConcurrency: 1000\n      containers:\n      - image: gcr.io/PROJECT/updater:latest\n        env:\n        - name: UPDATER_CONFIG_SECTION\n          value: \"gcp_production\"\n        - name: GCP_ADMIN_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: updater-secrets\n              key: admin-api-key\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>Deployment with Secrets: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: updater-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: updater-service\n  template:\n    metadata:\n      labels:\n        app: updater-service\n    spec:\n      containers:\n      - name: updater\n        image: updater:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: UPDATER_CONFIG_SECTION\n          value: \"k8s_production\"\n        - name: K8S_ADMIN_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: updater-secrets\n              key: admin-api-key\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: updater-secrets\n              key: database-url\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: updater-secrets\ntype: Opaque\nstringData:\n  admin-api-key: \"YOUR_SECURE_ADMIN_KEY_HERE\"\n  database-url: \"your_database_connection_string\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: updater-service\nspec:\n  selector:\n    app: updater-service\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: updater-ingress\n  annotations:\n    kubernetes.io/ingress.class: \"nginx\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\nspec:\n  tls:\n  - hosts:\n    - api.yourdomain.com\n    secretName: updater-tls\n  rules:\n  - host: api.yourdomain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: updater-service\n            port:\n              number: 80\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"DEPLOYMENT_SECURITY/#security-monitoring-setup","title":"Security Monitoring Setup","text":"<p>Key Security Metrics to Monitor: - Authentication failure rate - Permission denied attempts - Rate limit violations - Unusual API usage patterns - Admin operations outside business hours</p> <p>Example Monitoring Configuration: <pre><code># Prometheus metrics (implement in application)\n- name: auth_failures_total\n  help: Total authentication failures\n  type: counter\n  labels: [endpoint, client_ip]\n\n- name: permission_denials_total\n  help: Total permission denials\n  type: counter\n  labels: [endpoint, required_permission, api_key_name]\n\n- name: rate_limit_violations_total\n  help: Total rate limit violations\n  type: counter\n  labels: [client_ip]\n</code></pre></p> <p>Alert Rules: <pre><code># Example Prometheus alert rules\ngroups:\n- name: updater_security_alerts\n  rules:\n  - alert: HighAuthFailureRate\n    expr: rate(auth_failures_total[5m]) &gt; 0.1\n    for: 2m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"High authentication failure rate detected\"\n\n  - alert: AdminOperationOutsideBusinessHours\n    expr: increase(admin_operations_total[1h]) &gt; 0 unless (hour() &gt;= 9 and hour() &lt;= 17)\n    labels:\n      severity: critical\n    annotations:\n      summary: \"Admin operation detected outside business hours\"\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#log-analysis","title":"Log Analysis","text":"<p>Security Events to Log: <pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"level\": \"WARN\",\n  \"event\": \"permission_denied\",\n  \"message\": \"Insufficient permissions for endpoint\",\n  \"client_ip\": \"192.168.1.100\",\n  \"api_key_name\": \"Read Only Key\",\n  \"endpoint\": \"/api/v1/updates/myapp/register\",\n  \"required_permission\": \"write\",\n  \"user_permissions\": [\"read\"],\n  \"request_id\": \"req_123456\"\n}\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#security-testing","title":"Security Testing","text":""},{"location":"DEPLOYMENT_SECURITY/#automated-security-testing","title":"Automated Security Testing","text":"<p>Create a security test script to validate your deployment:</p> <pre><code>#!/bin/bash\n# security-validation.sh\n\nSERVER_URL=\"https://your-api.domain.com\"\nVALID_KEY=\"your-test-api-key\"\n\necho \"\ud83d\udd12 Security Validation Test\"\necho \"==========================\"\n\n# Test 1: HTTPS enforcement\necho \"Testing HTTPS enforcement...\"\nhttp_response=$(curl -s -w \"%{http_code}\" -o /dev/null \"http://your-api.domain.com/health\")\nif [[ $http_response -eq 301 ]] || [[ $http_response -eq 302 ]]; then\n    echo \"\u2705 HTTPS redirect working\"\nelse\n    echo \"\u274c HTTPS redirect not working: $http_response\"\nfi\n\n# Test 2: Authentication required\necho \"Testing authentication requirements...\"\nno_auth_response=$(curl -s -w \"%{http_code}\" -o /dev/null \"$SERVER_URL/api/v1/updates/test/register\" -X POST)\nif [[ $no_auth_response -eq 401 ]]; then\n    echo \"\u2705 Authentication required\"\nelse\n    echo \"\u274c Authentication not required: $no_auth_response\"\nfi\n\n# Test 3: Valid API key works\necho \"Testing valid API key...\"\nvalid_response=$(curl -s -w \"%{http_code}\" -o /dev/null \"$SERVER_URL/health\" -H \"Authorization: Bearer $VALID_KEY\")\nif [[ $valid_response -eq 200 ]]; then\n    echo \"\u2705 Valid API key accepted\"\nelse\n    echo \"\u274c Valid API key rejected: $valid_response\"\nfi\n\n# Test 4: Invalid API key rejected\necho \"Testing invalid API key rejection...\"\ninvalid_response=$(curl -s -w \"%{http_code}\" -o /dev/null \"$SERVER_URL/api/v1/updates/test/register\" -X POST -H \"Authorization: Bearer invalid-key\")\nif [[ $invalid_response -eq 401 ]]; then\n    echo \"\u2705 Invalid API key rejected\"\nelse\n    echo \"\u274c Invalid API key not rejected: $invalid_response\"\nfi\n\necho \"\"\necho \"Security validation complete!\"\n</code></pre>"},{"location":"DEPLOYMENT_SECURITY/#penetration-testing-checklist","title":"Penetration Testing Checklist","text":"<p>Manual Security Testing: - [ ] Test SQL injection attempts on all parameters - [ ] Test path traversal attempts in URL parameters - [ ] Test header injection attacks - [ ] Test large payload handling - [ ] Test rate limiting effectiveness - [ ] Test CORS policy enforcement - [ ] Test TLS configuration and cipher suites - [ ] Test API key brute force protection</p>"},{"location":"DEPLOYMENT_SECURITY/#incident-response","title":"Incident Response","text":""},{"location":"DEPLOYMENT_SECURITY/#security-incident-response-plan","title":"Security Incident Response Plan","text":"<p>Immediate Response (within 15 minutes): 1. Identify compromised API keys from logs 2. Disable compromised keys immediately 3. Check for unauthorized data access 4. Document incident timeline</p> <p>Short-term Response (within 1 hour): 1. Generate new API keys for affected systems 2. Update client applications with new keys 3. Review all recent admin operations 4. Increase monitoring and logging</p> <p>Long-term Response (within 24 hours): 1. Conduct full security audit 2. Update security procedures 3. Implement additional monitoring 4. Review and update incident response plan</p>"},{"location":"DEPLOYMENT_SECURITY/#emergency-key-revocation","title":"Emergency Key Revocation","text":"<p>Quick Key Disable: <pre><code># Method 1: Environment variable\nexport EMERGENCY_DISABLE_KEY=\"compromised-key-value\"\n\n# Method 2: Configuration update\nkubectl patch configmap updater-config \\\n  -p '{\"data\":{\"security.api_keys[0].enabled\":\"false\"}}'\n\n# Method 3: Service restart with new config\ndocker stop updater-service\n# Update configuration file\ndocker start updater-service\n</code></pre></p>"},{"location":"DEPLOYMENT_SECURITY/#compliance-considerations","title":"Compliance Considerations","text":""},{"location":"DEPLOYMENT_SECURITY/#gdpr-compliance","title":"GDPR Compliance","text":"<p>Data Minimization: - Log only necessary operational data - Avoid logging personally identifiable information - Implement log retention policies - Provide data deletion capabilities</p>"},{"location":"DEPLOYMENT_SECURITY/#soc-2-compliance","title":"SOC 2 Compliance","text":"<p>Access Controls: - Implement role-based access control - Maintain access logs and audit trails - Regular access reviews and key rotation - Secure key storage and management</p>"},{"location":"DEPLOYMENT_SECURITY/#hipaa-compliance-if-handling-health-data","title":"HIPAA Compliance (if handling health data)","text":"<p>Additional Requirements: - End-to-end encryption - Business Associate Agreements (BAAs) - Enhanced access logging - Regular risk assessments</p>"},{"location":"DEPLOYMENT_SECURITY/#security-maintenance","title":"Security Maintenance","text":""},{"location":"DEPLOYMENT_SECURITY/#regular-security-tasks","title":"Regular Security Tasks","text":"<p>Weekly: - Review security logs for anomalies - Monitor rate limiting effectiveness - Check certificate expiration dates</p> <p>Monthly: - Rotate development/staging API keys - Review and update CORS policies - Update dependencies and security patches</p> <p>Quarterly: - Rotate production API keys - Conduct security assessment - Review and update security documentation - Test incident response procedures</p>"},{"location":"DEPLOYMENT_SECURITY/#security-updates","title":"Security Updates","text":"<p>Staying Current: - Subscribe to Go security announcements - Monitor dependency vulnerabilities - Follow security best practices updates - Regular security training for team members</p> <p>Update Process: 1. Test security updates in staging 2. Schedule maintenance windows 3. Apply updates with rollback plan 4. Validate security posture post-update 5. Document changes and lessons learned</p> <p>This comprehensive deployment guide ensures that your updater service is deployed securely and maintains strong security posture throughout its lifecycle.</p>"},{"location":"ROADMAP/","title":"Roadmap","text":"<p>This document captures the planned direction for the updater service. Items are grouped into phases reflecting agreed priorities: developer experience comes first, then storage extensions, then ops hardening. Work items within a phase are roughly sequenced but may shift based on feedback.</p> <p>Items marked TBD require an explicit design decision before implementation begins.</p>"},{"location":"ROADMAP/#phase-1-developer-experience","title":"Phase 1: Developer Experience","text":"<p>The most pressing gap is that every consumer of the service has to write their own HTTP integration and manage API keys by editing YAML. This phase removes both of those friction points.</p>"},{"location":"ROADMAP/#11-admin-rest-api","title":"1.1 Admin REST API","text":"<p>Add CRUD endpoints for managing API keys without touching config files or restarting the service.</p> <p>Scope:</p> <ul> <li><code>GET /api/v1/admin/keys</code> \u2014 list API keys (metadata only; never return the raw key after creation)</li> <li><code>POST /api/v1/admin/keys</code> \u2014 create a key, returning it once in the response</li> <li><code>PATCH /api/v1/admin/keys/{id}</code> \u2014 update name, permissions, or enabled state</li> <li><code>DELETE /api/v1/admin/keys/{id}</code> \u2014 revoke a key</li> </ul> <p>Constraints:</p> <ul> <li>Requires a new <code>admin</code> permission scope distinct from the existing <code>admin</code> release-management permission (or a super-admin concept)</li> <li>Keys stored in whichever configured storage backend is active; no separate keystore</li> <li>Audit log entry on every mutation</li> </ul>"},{"location":"ROADMAP/#12-admin-web-ui","title":"1.2 Admin Web UI","text":"<p>A server-rendered HTMX + Go templates UI embedded directly in the binary at <code>/admin</code>. No separate frontend build step; no external CDN at runtime.</p> <p>Design document: <code>docs/plans/2026-02-16-admin-frontend.md</code></p> <p>Covers:</p> <ul> <li>API key login with HttpOnly session cookie</li> <li>Application CRUD</li> <li>Release listing and deletion</li> <li>Health dashboard (storage ping, uptime, active key count)</li> </ul> <p>Depends on: 1.1 Admin REST API (or direct service layer calls \u2014 per the plan, handlers call the service directly)</p>"},{"location":"ROADMAP/#13-go-client-sdk","title":"1.3 Go Client SDK","text":"<p>A Go module (<code>updater/client</code> or a separate repository) that wraps the HTTP API and handles retries, version parsing, and platform detection.</p> <p>Scope:</p> <ul> <li><code>CheckForUpdate(appID, currentVersion, platform, arch string) (*UpdateResult, error)</code></li> <li><code>GetLatestVersion(appID, platform, arch string) (*Release, error)</code></li> <li><code>RegisterRelease(appID string, r ReleaseRequest) error</code> (authenticated)</li> <li>Configurable HTTP client (timeout, base URL, API key)</li> <li>Automatic platform and architecture detection from <code>runtime.GOOS</code> / <code>runtime.GOARCH</code></li> </ul>"},{"location":"ROADMAP/#14-python-and-java-client-sdks","title":"1.4 Python and Java Client SDKs","text":"<p>Generate clients from the OpenAPI 3.0.3 spec (<code>internal/api/openapi/openapi.yaml</code>) using the official OpenAPI Generator, then layer hand-written convenience wrappers on top.</p> <p>Scope:</p> <ul> <li>Python package (<code>updater-client</code>) \u2014 targets Python 3.10+, published to PyPI</li> <li>Java library \u2014 targets Java 17+, published to Maven Central</li> <li>Both expose the same conceptual surface as the Go SDK: <code>check_for_update</code>, <code>get_latest_version</code>, <code>register_release</code></li> </ul> <p>Prerequisite: The OpenAPI spec must be complete and validated before client generation. Run <code>make openapi-validate</code> before each release.</p>"},{"location":"ROADMAP/#15-admin-cli","title":"1.5 Admin CLI","text":"<p>A <code>updater-ctl</code> binary for scripting key management and release publishing without the web UI.</p> <pre><code>updater-ctl keys list\nupdater-ctl keys create --name \"CI Publisher\" --permissions write\nupdater-ctl keys revoke &lt;id&gt;\nupdater-ctl releases publish --app myapp --version 2.1.0 --platform linux --arch amd64 --url https://...\n</code></pre> <p>Depends on: 1.1 Admin REST API</p>"},{"location":"ROADMAP/#phase-2-storage-extensions","title":"Phase 2: Storage Extensions","text":""},{"location":"ROADMAP/#21-presigned-redirect-url-support","title":"2.1 Presigned Redirect URL Support","text":"<p>Clients are redirected (or given a short-lived signed URL) to private object storage rather than receiving a static public URL. This enables storing binaries in private S3/GCS/Azure Blob buckets.</p> <p>Providers:</p> Provider Implementation AWS S3 (+ S3-compatible: MinIO, Backblaze B2) <code>storage/signing/s3.go</code> Google Cloud Storage <code>storage/signing/gcs.go</code> Azure Blob Storage <code>storage/signing/azure.go</code> <p>Design:</p> <ul> <li>New <code>URLSigner</code> interface: <code>Sign(rawURL string, ttl time.Duration) (string, error)</code></li> <li>Factory selects provider from config; falls back to passthrough (no signing) if unconfigured</li> <li>URL TTL configurable per-request and globally via config</li> <li>The <code>download_url</code> field in update check responses returns the signed URL</li> </ul> <p>Config:</p> <pre><code>signing:\n  provider: s3       # s3 | gcs | azure | none\n  ttl: 15m\n  s3:\n    bucket: my-releases\n    region: us-east-1\n    # credentials from environment (AWS_ACCESS_KEY_ID etc.) or IAM role\n  gcs:\n    bucket: my-releases\n    credentials_file: /etc/updater/gcs-key.json\n  azure:\n    account: myaccount\n    container: releases\n</code></pre>"},{"location":"ROADMAP/#22-multi-tenancy-tbd","title":"2.2 Multi-Tenancy \u2014 TBD","text":"<p>Decision required: Should tenant isolation be enforced at the data layer (each tenant gets their own schema or database) or at the API key layer (keys are scoped to specific applications)?</p> <p>Until a decision is reached, the service operates as single-tenant. The flag to introduce multi-tenancy early is whether a SaaS deployment model becomes a near-term requirement.</p> <p>Options under consideration:</p> <ul> <li>Schema-per-tenant (PostgreSQL): Strong isolation; higher operational complexity</li> <li>Application-namespace isolation: Each API key is bound to one or more <code>app_id</code> values; enforced in middleware. Low complexity, weaker isolation.</li> <li>Separate deployments: Each tenant runs their own instance. No code changes needed.</li> </ul>"},{"location":"ROADMAP/#phase-3-ops-reliability","title":"Phase 3: Ops &amp; Reliability","text":""},{"location":"ROADMAP/#31-built-in-migration-runner","title":"3.1 Built-in Migration Runner","text":"<p>Embed the SQL migration files and apply any outstanding migrations automatically at startup. No separate migration tool or manual SQL execution required.</p> <p>Design:</p> <ul> <li>Embed <code>internal/storage/sqlc/schema/</code> using <code>go:embed</code></li> <li>Apply migrations in filename order (<code>001_initial.sql</code>, <code>002_add_indexes.sql</code>, \u2026)</li> <li>Track applied migrations in a <code>schema_migrations</code> table</li> <li>Skip already-applied migrations; fail fast on hash mismatch</li> <li>Dry-run mode: <code>--migrate=dry-run</code> prints pending migrations without applying</li> </ul> <p>Supported backends: PostgreSQL and SQLite only (JSON and memory providers do not need migrations).</p>"},{"location":"ROADMAP/#32-high-availability","title":"3.2 High Availability","text":"<p>Document and validate the HA deployment model: multiple replicas, shared PostgreSQL, load balancer.</p> <p>Scope:</p> <ul> <li>Verify all in-flight state is either in the database or stateless (rate limiter state is currently in-memory \u2014 requires a distributed backend for HA)</li> <li>Distributed rate limiter backend (Redis recommended)</li> <li>Documentation: <code>docs/deployment-ha.md</code></li> </ul>"},{"location":"ROADMAP/#33-production-helm-chart","title":"3.3 Production Helm Chart","text":"<p>A production-grade Helm chart for Kubernetes deployment, replacing the current bare <code>deployments/kubernetes/deployment.yaml</code>.</p> <p>Scope:</p> <ul> <li>Configurable replicas, resource limits, and pod disruption budgets</li> <li>Secret management via Kubernetes Secrets or external-secrets</li> <li>Optional ingress with TLS</li> <li>Readiness and liveness probes wired to <code>/health</code></li> <li>Optional PostgreSQL dependency (Bitnami chart)</li> </ul>"},{"location":"ROADMAP/#future-under-consideration","title":"Future / Under Consideration","text":"<p>These items have no committed phase. They will be re-evaluated as the above phases complete.</p> Item Notes Release signing and verification Cosign or minisign signatures on binaries; <code>signature_url</code> field in responses Delta updates Binary patch format (bsdiff or similar); reduces download size for incremental updates Staged rollouts / A/B releases Serve different versions to percentage-based client cohorts Redis caching layer Reduce storage reads for high-volume update check endpoints Webhook notifications Notify downstream systems on new release registration CLI tool auto-update The <code>updater-ctl</code> CLI uses the service to update itself"},{"location":"ROADMAP/#decision-log","title":"Decision Log","text":"Date Decision Rationale 2026-02-16 Remain a pure metadata service; add presigned redirect support rather than hosting binaries Keeps the service lightweight and offloads bandwidth to CDN/object storage 2026-02-16 Developer experience before ops hardening Admin API, web UI, and SDKs remove the most immediate integration friction 2026-02-16 Multi-tenancy deferred pending design decision Namespace-based vs schema-based isolation has significant architectural implications; premature commitment risks expensive rework"},{"location":"SECURITY/","title":"Security Documentation","text":""},{"location":"SECURITY/#overview","title":"Overview","text":"<p>The updater service implements a comprehensive security model designed to protect against common attack vectors while providing flexible access control for administrative operations. This document outlines the security architecture, configuration, and best practices for secure deployment.</p>"},{"location":"SECURITY/#security-architecture","title":"Security Architecture","text":""},{"location":"SECURITY/#defense-in-depth-strategy","title":"Defense in Depth Strategy","text":"<p>The service implements multiple layers of security protection:</p> <pre><code>graph TB\n    P[Reverse Proxy] --&gt; A[Rate Limiting]\n    P --&gt; B[CORS Enforcement]\n    P --&gt; C[TLS Termination]\n    C --&gt; D[Authentication]\n    D --&gt; E[Authorization]\n    E --&gt; F[Input Validation]\n    F --&gt; G[Business Logic]\n    G --&gt; H[Audit Logging]</code></pre>"},{"location":"SECURITY/#security-layers","title":"Security Layers","text":"<ol> <li>Network Security (reverse proxy layer)</li> <li>TLS/HTTPS termination and certificate renewal</li> <li>CORS header management</li> <li>Rate limiting and DDoS mitigation</li> <li> <p>See Reverse Proxy for nginx and Traefik examples</p> </li> <li> <p>Authentication Layer</p> </li> <li>API key-based authentication</li> <li>Bearer token format validation</li> <li> <p>Key rotation and management</p> </li> <li> <p>Authorization Layer</p> </li> <li>Permission-based access control</li> <li>Endpoint-specific permission requirements</li> <li> <p>Principle of least privilege</p> </li> <li> <p>Application Security</p> </li> <li>Input validation and sanitization</li> <li>SQL injection prevention</li> <li> <p>Path traversal protection</p> </li> <li> <p>Operational Security</p> </li> <li>Comprehensive audit logging</li> <li>Security event monitoring</li> </ol>"},{"location":"SECURITY/#authentication-authorization","title":"Authentication &amp; Authorization","text":""},{"location":"SECURITY/#api-key-authentication","title":"API Key Authentication","text":"<p>The service uses API keys for authentication with a Bearer token format:</p> <pre><code>Authorization: Bearer &lt;api-key&gt;\n</code></pre>"},{"location":"SECURITY/#permission-model","title":"Permission Model","text":"<p>The authorization system implements role-based permissions:</p> Permission Description Endpoints <code>read</code> Query update information <code>GET /api/v1/updates/*</code> <code>write</code> Register new releases <code>POST /api/v1/updates/*/register</code> <code>admin</code> Full administrative access All endpoints"},{"location":"SECURITY/#permission-hierarchy","title":"Permission Hierarchy","text":"<ul> <li><code>admin</code> permission grants access to all operations</li> <li><code>write</code> permission includes <code>read</code> operations</li> <li><code>read</code> permission grants only query access</li> </ul>"},{"location":"SECURITY/#api-key-management","title":"API Key Management","text":"<p>API keys are stored in the service database, not in the configuration file.</p>"},{"location":"SECURITY/#bootstrap-key","title":"Bootstrap Key","text":"<p>The <code>security.bootstrap_key</code> config field (or <code>UPDATER_BOOTSTRAP_KEY</code> env var) seeds a single <code>admin</code>-permission key into an empty database on first startup. This key is the entry point for all subsequent key management.</p> <pre><code>security:\n  enable_auth: true\n  bootstrap_key: \"${UPDATER_BOOTSTRAP_KEY}\"\n</code></pre> <p>Generate a bootstrap key:</p> <pre><code>openssl rand -base64 32\n</code></pre>"},{"location":"SECURITY/#key-format","title":"Key Format","text":"<p>Generated keys use the format <code>upd_&lt;44-char base64url&gt;</code>, providing 256 bits of entropy. The raw key value is returned exactly once \u2014 at creation time \u2014 and is never stored. Only the SHA-256 hex digest (<code>key_hash</code>) and an 8-character display prefix are persisted.</p>"},{"location":"SECURITY/#key-lifecycle-rest-api","title":"Key Lifecycle (REST API)","text":"Method Path Description <code>GET</code> <code>/api/v1/admin/keys</code> List all keys (hash and raw key never returned) <code>POST</code> <code>/api/v1/admin/keys</code> Create a key; raw value returned once in response <code>PATCH</code> <code>/api/v1/admin/keys/{id}</code> Update name, permissions, or enabled status <code>DELETE</code> <code>/api/v1/admin/keys/{id}</code> Permanently revoke a key <p>All key management endpoints require <code>admin</code> permission. The admin UI at <code>/admin/keys</code> and <code>/admin/keys/new</code> provides a browser-based interface for the same operations.</p>"},{"location":"SECURITY/#permission-model_1","title":"Permission Model","text":"Permission Grants access to <code>read</code> Read-only query endpoints <code>write</code> <code>read</code> + release and application creation <code>admin</code> <code>write</code> + updates, deletes, and key management <code>*</code> Alias for <code>admin</code> \u2014 full access <p>Permissions are cumulative: <code>admin</code> includes <code>write</code>, <code>write</code> includes <code>read</code>.</p>"},{"location":"SECURITY/#security-best-practices","title":"Security Best Practices","text":"<ol> <li> <p>Key Rotation: Rotate keys regularly (recommended: every 90 days). Create    the replacement key before revoking the old one for zero-downtime rotation.</p> </li> <li> <p>Least Privilege: Assign the minimum permission required. Read-only    integrations should use <code>read</code>; release publishers should use <code>write</code>.</p> </li> <li> <p>Bootstrap Key Storage: Store the bootstrap key in a secret manager    (HashiCorp Vault, AWS Secrets Manager, Kubernetes Secrets). Never commit it    to version control.</p> </li> <li> <p>Revocation: Revoke compromised keys immediately via <code>DELETE    /api/v1/admin/keys/{id}</code> or the <code>/admin/keys</code> UI.</p> </li> </ol>"},{"location":"SECURITY/#configuration-security","title":"Configuration Security","text":""},{"location":"SECURITY/#proxy-layer","title":"Proxy Layer","text":"<p>Rate limiting, CORS, and TLS are enforced by the reverse proxy in front of the service. See Reverse Proxy for nginx and Traefik configuration examples.</p>"},{"location":"SECURITY/#threat-model","title":"Threat Model","text":""},{"location":"SECURITY/#identified-threats","title":"Identified Threats","text":"Threat Impact Mitigation Unauthorized Release Injection Critical Permission-based authorization, API key validation DDoS/Resource Exhaustion High Rate limiting, connection limits API Key Compromise High Key rotation, permission scoping, audit logging Man-in-the-Middle High TLS enforcement, HSTS headers Version Downgrade Attack Medium Checksum validation, version constraints Information Disclosure Medium Error message sanitization, access logging"},{"location":"SECURITY/#attack-scenarios-defenses","title":"Attack Scenarios &amp; Defenses","text":""},{"location":"SECURITY/#1-malicious-release-injection","title":"1. Malicious Release Injection","text":"<p>Scenario: Attacker attempts to register malicious releases</p> <p>Defense: - API key authentication required - <code>write</code> permission enforcement - Input validation on all release data - Audit logging of all release operations</p>"},{"location":"SECURITY/#2-api-key-compromise","title":"2. API Key Compromise","text":"<p>Scenario: API key is stolen or leaked</p> <p>Defense: - Permission scoping limits damage - Rate limiting prevents mass operations - Audit logging enables detection - Key rotation capability for quick response</p>"},{"location":"SECURITY/#3-ddos-attack","title":"3. DDoS Attack","text":"<p>Scenario: Service overwhelmed by requests</p> <p>Defense: - Per-IP rate limiting - Request size limits - Connection timeouts - Graceful degradation</p>"},{"location":"SECURITY/#production-security-configuration","title":"Production Security Configuration","text":""},{"location":"SECURITY/#httpstls-configuration","title":"HTTPS/TLS Configuration","text":"<p>TLS termination is handled by the reverse proxy. The service does not need TLS configured directly. See Reverse Proxy for nginx and Traefik examples that terminate TLS and forward plain HTTP to the service on port 8080.</p>"},{"location":"SECURITY/#security-monitoring-logging","title":"Security Monitoring &amp; Logging","text":""},{"location":"SECURITY/#security-events","title":"Security Events","text":"<p>The service logs the following security-relevant events:</p> <ul> <li>Authentication Events</li> <li>API key validation attempts (success/failure)</li> <li>Invalid authentication format attempts</li> <li> <p>Disabled key usage attempts</p> </li> <li> <p>Authorization Events</p> </li> <li>Permission validation failures</li> <li>Unauthorized endpoint access attempts</li> <li> <p>Admin operation attempts without proper permissions</p> </li> <li> <p>Operational Events</p> </li> <li>Release registration operations</li> <li>Configuration changes</li> <li>Service startup/shutdown</li> </ul>"},{"location":"SECURITY/#log-format","title":"Log Format","text":"<pre><code>{\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"level\": \"WARN\",\n  \"event\": \"auth_failure\",\n  \"message\": \"Invalid API key attempted\",\n  \"client_ip\": \"192.168.1.100\",\n  \"endpoint\": \"/api/v1/updates/myapp/register\",\n  \"user_agent\": \"curl/7.68.0\",\n  \"request_id\": \"req_123456\"\n}\n</code></pre>"},{"location":"SECURITY/#monitoring-alerts","title":"Monitoring Alerts","text":"<p>Set up alerts for: - Multiple authentication failures from same IP - Admin operations outside business hours - Unusual API usage patterns - Rate limit violations - Service error rate increases</p>"},{"location":"SECURITY/#incident-response","title":"Incident Response","text":""},{"location":"SECURITY/#security-incident-procedures","title":"Security Incident Procedures","text":"<ol> <li>Immediate Response</li> <li>Identify compromised API keys</li> <li>Disable affected keys immediately</li> <li> <p>Review audit logs for unauthorized operations</p> </li> <li> <p>Investigation</p> </li> <li>Analyze access patterns</li> <li>Identify affected releases/applications</li> <li> <p>Determine attack timeline and scope</p> </li> <li> <p>Recovery</p> </li> <li>Generate new API keys</li> <li>Update affected systems</li> <li>Verify system integrity</li> <li> <p>Update security configurations</p> </li> <li> <p>Post-Incident</p> </li> <li>Document lessons learned</li> <li>Update security procedures</li> <li>Enhance monitoring rules</li> </ol>"},{"location":"SECURITY/#emergency-api-key-revocation","title":"Emergency API Key Revocation","text":"<p>Revoke a key immediately via the REST API (requires an active <code>admin</code> key):</p> <pre><code># Permanently delete a key by ID\ncurl -X DELETE https://updater.example.com/api/v1/admin/keys/&lt;key-id&gt; \\\n  -H \"Authorization: Bearer &lt;admin-api-key&gt;\"\n\n# Or disable without deleting (can be re-enabled later)\ncurl -X PATCH https://updater.example.com/api/v1/admin/keys/&lt;key-id&gt; \\\n  -H \"Authorization: Bearer &lt;admin-api-key&gt;\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"enabled\": false}'\n</code></pre> <p>Key IDs are visible in <code>GET /api/v1/admin/keys</code> or the <code>/admin/keys</code> admin UI.</p>"},{"location":"SECURITY/#security-testing","title":"Security Testing","text":""},{"location":"SECURITY/#security-validation-checklist","title":"Security Validation Checklist","text":"<ul> <li>[ ] API authentication required for admin endpoints</li> <li>[ ] Permission validation enforced</li> <li>[ ] Rate limiting configured at reverse proxy</li> <li>[ ] Input validation preventing injection</li> <li>[ ] Error messages don't leak sensitive information</li> <li>[ ] HTTPS enforced in production</li> <li>[ ] Security headers configured</li> <li>[ ] Audit logging captures security events</li> </ul>"},{"location":"SECURITY/#penetration-testing","title":"Penetration Testing","text":"<p>Recommended security tests:</p> <pre><code># Test authentication bypass\ncurl -X POST http://localhost:8080/api/v1/updates/test/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"version\":\"1.0.0\"}'\n\n# Test invalid API key\ncurl -X POST http://localhost:8080/api/v1/updates/test/register \\\n  -H \"Authorization: Bearer invalid-key\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"version\":\"1.0.0\"}'\n\n# Test insufficient permissions\ncurl -X POST http://localhost:8080/api/v1/updates/test/register \\\n  -H \"Authorization: Bearer read-only-key\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"version\":\"1.0.0\"}'\n</code></pre>"},{"location":"SECURITY/#compliance-standards","title":"Compliance &amp; Standards","text":""},{"location":"SECURITY/#security-standards-alignment","title":"Security Standards Alignment","text":"<ul> <li>OWASP Top 10: Protection against common web vulnerabilities</li> <li>NIST Cybersecurity Framework: Risk-based security approach</li> <li>ISO 27001: Information security management practices</li> </ul>"},{"location":"SECURITY/#data-protection","title":"Data Protection","text":"<ul> <li>No Personal Data: Service doesn't collect or store personal information</li> <li>Minimal Data Collection: Only necessary operational data</li> <li>Data Retention: Configurable log retention periods</li> <li>Privacy by Design: Default configurations prioritize privacy</li> </ul>"},{"location":"SECURITY/#security-development-guidelines","title":"Security Development Guidelines","text":""},{"location":"SECURITY/#secure-coding-practices","title":"Secure Coding Practices","text":"<ol> <li>Input Validation</li> <li>Validate all inputs at API boundaries</li> <li>Use allowlists instead of blocklists</li> <li> <p>Sanitize data before processing</p> </li> <li> <p>Error Handling</p> </li> <li>Don't expose internal system information</li> <li>Log detailed errors securely</li> <li> <p>Return generic error messages to clients</p> </li> <li> <p>Authentication</p> </li> <li>Always verify API keys for admin operations</li> <li>Check permissions before processing requests</li> <li>Use secure comparison functions</li> </ol>"},{"location":"SECURITY/#code-review-security-checklist","title":"Code Review Security Checklist","text":"<ul> <li>[ ] New endpoints have appropriate authentication</li> <li>[ ] Permission checks implemented for admin operations</li> <li>[ ] Input validation implemented</li> <li>[ ] Error handling doesn't leak information</li> <li>[ ] Security logging added for sensitive operations</li> <li>[ ] Tests cover security scenarios</li> </ul>"},{"location":"SECURITY/#security-contact-information","title":"Security Contact Information","text":"<p>For security issues and responsible disclosure:</p> <ul> <li>Use the Github private security advisory process: https://docs.github.com/en/code-security/how-tos/report-and-fix-vulnerabilities/report-a-vulnerability/privately-reporting-a-security-vulnerability</li> </ul>"},{"location":"SECURITY/#responsible-disclosure","title":"Responsible Disclosure","text":"<p>We appreciate security researchers who help improve our security. Please:</p> <ol> <li>Report vulnerabilities privately first</li> <li>Allow reasonable time for fixes</li> <li>Avoid accessing or modifying user data</li> <li>Don't perform DDoS or destructive testing</li> </ol>"},{"location":"SECURITY/#appendix","title":"Appendix","text":""},{"location":"SECURITY/#security-references","title":"Security References","text":"<ul> <li>OWASP API Security Top 10</li> <li>NIST Cybersecurity Framework</li> <li>Go Security Best Practices</li> </ul>"},{"location":"SECURITY/#security-tools","title":"Security Tools","text":"<ul> <li>Static Analysis: <code>gosec</code>, <code>govulncheck</code></li> <li>Dependency Scanning: <code>nancy</code>, <code>snyk</code></li> <li>Penetration Testing: <code>burp suite</code>, <code>owasp zap</code></li> <li>Monitoring: <code>prometheus</code>, <code>grafana</code></li> </ul>"},{"location":"admin-ui/","title":"Admin UI","text":"<p>The updater service ships with a browser-based admin interface at <code>/admin</code>. It is server-rendered using Go's <code>html/template</code> package with HTMX for inline delete actions, styled with Tailwind CSS (Play CDN). No JavaScript build step is required.</p>"},{"location":"admin-ui/#access","title":"Access","text":"<p>Navigate to <code>http://localhost:8080/admin</code> in a browser. You will be redirected to the login page.</p>"},{"location":"admin-ui/#authentication","title":"Authentication","text":"<p>Enter an API key with <code>admin</code> permission on the login page. After a successful login the browser receives an HttpOnly, SameSite=Strict <code>admin_session</code> cookie scoped to <code>/admin</code>. Subsequent requests are authenticated automatically via this cookie \u2014 the key is never re-entered per request and is never visible to JavaScript.</p> <p>In development mode (auth disabled) any non-empty string is accepted as the key.</p>"},{"location":"admin-ui/#pages","title":"Pages","text":"Path Description <code>/admin/login</code> Login form <code>/admin/applications</code> Application list with inline delete <code>/admin/applications/new</code> Create application form <code>/admin/applications/{id}</code> Application detail and release list <code>/admin/applications/{id}/edit</code> Edit application form <code>/admin/applications/{id}/releases/new</code> Register a release <code>/admin/keys</code> API key list with enable/disable toggle (HTMX) and revoke button <code>/admin/keys/new</code> Create key form; raw key displayed exactly once on success <code>/admin/health</code> Service health dashboard"},{"location":"admin-ui/#architecture","title":"Architecture","text":"<pre><code>flowchart LR\n    B[Browser] --&gt;|GET /admin/*| R[Router\\ngorilla/mux]\n    R --&gt;|cookie check| M[adminSessionMiddleware]\n    M --&gt;|valid| H[Admin Handlers]\n    H --&gt;|direct call| S[ServiceInterface]\n    S --&gt; DB[(Storage)]\n    H --&gt;|html/template| T[Embedded Templates\\ngo:embed]\n    T --&gt; B</code></pre> <p>Templates are embedded via <code>go:embed</code> at compile time. HTMX is loaded from the unpkg CDN; an internet connection is required for the interactive delete behaviour. Core page navigation works without JavaScript.</p>"},{"location":"admin-ui/#development-login","title":"Development Login","text":"<p>When running locally with the default <code>docker-compose.yml</code> configuration, log in with the key <code>dev-admin-key-12345678901234567890</code> set in the <code>DEV_ADMIN_API_KEY</code> environment variable.</p>"},{"location":"admin-ui/#flash-messages","title":"Flash Messages","text":"<p>After create, edit, or delete actions the UI redirects with <code>?flash=&lt;message&gt;&amp;flash_type=&lt;success|error&gt;</code> query parameters. The target page reads these parameters and displays a brief notification banner, which disappears on the next navigation.</p>"},{"location":"api/","title":"API Reference","text":"<p>The interactive API reference is served directly by the running updater service.</p>"},{"location":"api/#swagger-ui","title":"Swagger UI","text":"<p>Navigate to <code>/api/v1/docs</code> on your running instance:</p> <pre><code>http://localhost:8080/api/v1/docs\n</code></pre> <p>The Swagger UI is generated from the embedded OpenAPI 3.0.3 specification and always reflects the exact endpoints and schemas of the running version.</p>"},{"location":"api/#openapi-specification","title":"OpenAPI Specification","text":"<p>The raw OpenAPI YAML is available at:</p> <pre><code>http://localhost:8080/api/v1/openapi.yaml\n</code></pre> <p>You can also validate the specification locally without starting the service:</p> <pre><code>make openapi-validate\n</code></pre> <p>The specification source lives at <code>internal/api/openapi/openapi.yaml</code>.</p>"},{"location":"api/#authentication","title":"Authentication","text":"<p>Protected endpoints require a Bearer token in the <code>Authorization</code> header:</p> <pre><code>Authorization: Bearer &lt;api-key&gt;\n</code></pre> <p>API keys are managed via the key management endpoints or the admin UI. The permission hierarchy is cumulative:</p> Level Includes Description <code>read</code> read Query releases, list applications <code>write</code> read, write Register releases, create applications <code>admin</code> read, write, admin Update/delete resources, manage API keys"},{"location":"api/#request-flow","title":"Request Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant R as Rate Limiter\n    participant A as Auth Middleware\n    participant P as Permission Check\n    participant H as Handler\n    participant S as Storage\n\n    C-&gt;&gt;R: HTTP Request\n    R-&gt;&gt;A: Rate check passed\n    A-&gt;&gt;A: SHA-256 hash Bearer token\n    A-&gt;&gt;S: GetAPIKeyByHash\n    S--&gt;&gt;A: APIKey\n    A-&gt;&gt;P: Token valid\n    P-&gt;&gt;P: Check permission level\n    P-&gt;&gt;H: Authorized\n    H-&gt;&gt;S: Execute operation\n    S--&gt;&gt;H: Result\n    H--&gt;&gt;C: JSON Response</code></pre>"},{"location":"api/#error-responses","title":"Error Responses","text":"<p>All errors follow a consistent JSON structure:</p> <pre><code>{\n  \"error\": \"error\",\n  \"message\": \"Human-readable error description\",\n  \"code\": \"ERROR_CODE\",\n  \"details\": {},\n  \"timestamp\": \"2026-02-16T10:00:00Z\",\n  \"request_id\": \"req_abc123\"\n}\n</code></pre> Code HTTP Status Description <code>NOT_FOUND</code> 404 Requested resource does not exist <code>APPLICATION_NOT_FOUND</code> 404 Application does not exist <code>BAD_REQUEST</code> 400 Malformed request format <code>INVALID_REQUEST</code> 400 Invalid request data or method <code>VALIDATION_ERROR</code> 422 Input validation failed <code>INTERNAL_ERROR</code> 500 Unexpected server-side error <code>UNAUTHORIZED</code> 401 Authentication required or invalid credentials <code>FORBIDDEN</code> 403 Insufficient permissions <code>CONFLICT</code> 409 Resource already exists or state conflict <code>SERVICE_UNAVAILABLE</code> 503 Service temporarily unavailable"},{"location":"logging/","title":"Logging","text":"<p>The updater service uses Go's built-in <code>log/slog</code> package for structured logging throughout the application. This provides consistent, machine-parseable log output suitable for production environments.</p>"},{"location":"logging/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[LoggingConfig] --&gt; B[logger.Setup]\n    B --&gt; C{Format}\n    C --&gt;|json| D[slog.JSONHandler]\n    C --&gt;|text| E[slog.TextHandler]\n    B --&gt; F{Output}\n    F --&gt;|stdout| G[os.Stdout]\n    F --&gt;|stderr| H[os.Stderr]\n    F --&gt;|file| I[os.OpenFile]\n    D --&gt; J[slog.Logger]\n    E --&gt; J\n    J --&gt; K[slog.SetDefault]\n    K --&gt; L[Application Code]\n    L --&gt; M[Structured Log Output]</code></pre>"},{"location":"logging/#configuration","title":"Configuration","text":"<p>Logging is configured through the <code>logging</code> section of the service configuration file.</p>"},{"location":"logging/#configuration-fields","title":"Configuration Fields","text":"Field Type Default Description <code>level</code> string <code>info</code> Minimum log level to output <code>format</code> string <code>json</code> Output format (<code>json</code> or <code>text</code>) <code>output</code> string <code>stdout</code> Output destination (<code>stdout</code>, <code>stderr</code>, or <code>file</code>) <code>file_path</code> string File path when output is <code>file</code> <code>max_size</code> int <code>100</code> Maximum log file size in MB (for rotation) <code>max_backups</code> int <code>3</code> Maximum number of old log files to retain <code>max_age</code> int <code>28</code> Maximum days to retain old log files <code>compress</code> bool <code>true</code> Compress rotated log files"},{"location":"logging/#example-configuration","title":"Example Configuration","text":"<pre><code>logging:\n  level: info\n  format: json\n  output: stdout\n</code></pre> <pre><code>logging:\n  level: debug\n  format: text\n  output: file\n  file_path: /var/log/updater/service.log\n  max_size: 100\n  max_backups: 5\n  max_age: 30\n  compress: true\n</code></pre>"},{"location":"logging/#log-levels","title":"Log Levels","text":"Level Description Use Case <code>debug</code> Detailed diagnostic information Development and troubleshooting <code>info</code> General operational events Normal operation monitoring <code>warn</code> Warning conditions Security audit events, degraded operation <code>error</code> Error conditions Failed operations, system errors"},{"location":"logging/#structured-fields","title":"Structured Fields","text":"<p>All log messages include structured key-value pairs for consistent parsing and filtering.</p>"},{"location":"logging/#global-fields","title":"Global Fields","text":"<p>The following fields are automatically included on every log message throughout the application:</p> Field Source Example Description <code>version</code> Build metadata <code>v1.0.0</code> Service version from git tags <code>git_commit</code> Build metadata <code>a1b2c3d</code> Short git commit hash <code>build_date</code> Build metadata <code>2026-02-21T10:00:00Z</code> Build timestamp in RFC 3339 format <p>These fields are injected via <code>slog.With()</code> during logger initialization, ensuring they appear on all log entries without requiring manual inclusion in each log call.</p>"},{"location":"logging/#build-metadata-injection","title":"Build Metadata Injection","text":"<p>Build-time fields are injected via ldflags during compilation. Local development builds will show \"unknown\" for these values; CI/CD pipelines inject proper values:</p> <pre><code>go build -ldflags \"-X 'updater/internal/version.Version=v1.0.0' \\\n                   -X 'updater/internal/version.GitCommit=a1b2c3d' \\\n                   -X 'updater/internal/version.BuildDate=2026-02-21T10:00:00Z'\" \\\n         ./cmd/updater\n</code></pre>"},{"location":"logging/#http-request-logging","title":"HTTP Request Logging","text":"<p>Every HTTP request is logged with the following fields:</p> Field Description <code>method</code> HTTP method (GET, POST, etc.) <code>path</code> Request URL path <code>remote_addr</code> Client IP address"},{"location":"logging/#security-audit-logging","title":"Security Audit Logging","text":"<p>Security-sensitive operations include the <code>event</code> field set to <code>security_audit</code>. The fields present depend on which operation triggered the event.</p>"},{"location":"logging/#release-and-application-operations","title":"Release and application operations","text":"Field Description <code>event</code> Always <code>security_audit</code> <code>app_id</code> Application identifier <code>api_key</code> Name of the API key used <code>client_ip</code> Client IP address <code>version</code> Release version (when applicable) <code>error</code> Error details (when applicable)"},{"location":"logging/#api-key-management-operations","title":"API key management operations","text":"Field Description <code>event</code> Always <code>security_audit</code> <code>action</code> Operation performed: <code>create</code>, <code>update</code>, <code>delete</code>, or <code>toggle</code> <code>key_id</code> UUID of the key being managed <code>key_name</code> Human-readable name of the key <code>actor_key_id</code> UUID of the key that performed the operation (REST API path)"},{"location":"logging/#error-logging","title":"Error Logging","text":"<p>Error logs include contextual information:</p> Field Description <code>error</code> Error message or object <code>path</code> Request path (for panic recovery)"},{"location":"logging/#output-formats","title":"Output Formats","text":""},{"location":"logging/#json-format","title":"JSON Format","text":"<p>Produces machine-parseable JSON output, suitable for log aggregation systems (ELK, Datadog, CloudWatch):</p> <pre><code>{\"time\":\"2026-02-15T10:30:00Z\",\"level\":\"INFO\",\"msg\":\"HTTP request\",\"version\":\"v1.0.0\",\"git_commit\":\"a1b2c3d\",\"build_date\":\"2026-02-21T10:00:00Z\",\"method\":\"GET\",\"path\":\"/api/v1/updates/myapp/check\",\"remote_addr\":\"192.168.1.1:54321\"}\n</code></pre> <p>Note the global fields (<code>version</code>, <code>git_commit</code>, <code>build_date</code>) automatically included in every log message.</p>"},{"location":"logging/#text-format","title":"Text Format","text":"<p>Produces human-readable text output, suitable for development:</p> <pre><code>time=2026-02-15T10:30:00Z level=INFO msg=\"HTTP request\" version=v1.0.0 git_commit=a1b2c3d build_date=2026-02-21T10:00:00Z method=GET path=/api/v1/updates/myapp/check remote_addr=192.168.1.1:54321\n</code></pre>"},{"location":"logging/#request-flow","title":"Request Flow","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant M as Middleware\n    participant H as Handler\n    participant L as Logger\n\n    C-&gt;&gt;M: HTTP Request\n    M-&gt;&gt;L: Log request (method, path, remote_addr)\n    M-&gt;&gt;H: Forward request\n    alt Security Event (release/app operation)\n        H-&gt;&gt;L: Log security audit (event, app_id, api_key, client_ip)\n    end\n    alt Security Event (key management)\n        H-&gt;&gt;L: Log security audit (event, action, key_id, key_name)\n    end\n    alt Error\n        H-&gt;&gt;L: Log error (error details)\n    end\n    alt Panic\n        M-&gt;&gt;L: Log panic recovery (error, path)\n    end\n    H-&gt;&gt;C: HTTP Response</code></pre>"},{"location":"logging/#file-output","title":"File Output","text":"<p>When using file output, log files are created with restricted permissions (<code>0600</code>) to prevent unauthorized access. The file is opened in append mode, preserving existing log entries across service restarts.</p>"},{"location":"logging/#integration-with-monitoring","title":"Integration with Monitoring","text":"<p>The structured JSON output integrates directly with common log aggregation and monitoring tools:</p> <ul> <li>ELK Stack: Parse JSON logs directly with Filebeat/Logstash</li> <li>Datadog: Use JSON log format with automatic field extraction</li> <li>CloudWatch: JSON structured logs enable CloudWatch Insights queries</li> <li>Grafana Loki: Use JSON parser for label extraction</li> </ul>"},{"location":"makefile/","title":"Makefile","text":"<p>The project uses a split Makefile structure with Docker-first execution. Only Docker is required on the host -- no local Go, sqlc, or other tooling needed.</p>"},{"location":"makefile/#structure","title":"Structure","text":"<pre><code>Makefile              -- Shared variables, includes, auto-documenting help\nmake/\n  go.mk              -- Go development (build, test, fmt, vet, clean, tidy, check)\n  docs.mk            -- Documentation (docs-serve, docs-build, docs-clean)\n  docker.mk          -- Docker operations (docker-build, docker-run, docker-dev, etc.)\n  db.mk              -- Database (sqlc-generate, sqlc-vet)\n</code></pre> <p>The root <code>Makefile</code> includes all <code>make/*.mk</code> files automatically. To add a new category, create a new <code>.mk</code> file in <code>make/</code> -- no changes to the root Makefile needed.</p>"},{"location":"makefile/#docker-first-execution","title":"Docker-first Execution","text":"<p>All Go and database targets run inside Docker containers:</p> <pre><code>graph LR\n    A[make test] --&gt; B[docker run golang:1.25-alpine]\n    B --&gt; C[go test ./...]\n    A -- cached --&gt; D[(go-mod-cache)]\n    A -- cached --&gt; E[(go-build-cache)]</code></pre> Category Container Image Go development <code>golang:1.25-alpine</code> Documentation <code>squidfunk/mkdocs-material:latest</code> Database (sqlc) <code>sqlc/sqlc:latest</code> Docker operations Host Docker daemon"},{"location":"makefile/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker -- the only local requirement</li> <li>GNU Make -- included with most systems (on Windows, use Git for Windows which provides <code>make</code> and <code>sh</code>)</li> </ul>"},{"location":"makefile/#caching","title":"Caching","text":"<p>Two named Docker volumes persist caches between runs:</p> Volume Purpose <code>updater-go-mod-cache</code> Go module downloads <code>updater-go-build-cache</code> Go build cache <p>To clear caches (e.g., after a Go version bump):</p> <pre><code>docker volume rm updater-go-mod-cache updater-go-build-cache\n</code></pre>"},{"location":"makefile/#adding-a-new-target","title":"Adding a New Target","text":"<ol> <li>Open the appropriate <code>make/*.mk</code> file (or create a new one for a new category)</li> <li>Add a category header if creating a new file: <code>##@ Category Name</code></li> <li>Add the target with a <code>## Description</code> annotation:</li> </ol> <pre><code>new-target: ## Description of what this target does\n    command to run\n</code></pre> <ol> <li>The target automatically appears in <code>make help</code> output</li> </ol>"},{"location":"makefile/#available-targets","title":"Available Targets","text":"<p>Run <code>make help</code> to see all available targets with descriptions.</p>"},{"location":"observability/","title":"Observability","text":"<p>The updater service provides a unified observability stack built on OpenTelemetry, covering metrics collection, distributed tracing, and enhanced health checks with real storage connectivity verification.</p>"},{"location":"observability/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph \"Updater Service\"\n        API[\"HTTP API&lt;br/&gt;(Gorilla Mux)\"]\n        OTelMux[\"otelmux Middleware\"]\n        Handlers[\"API Handlers\"]\n        IS[\"InstrumentedStorage\"]\n        Storage[\"Storage Backend\"]\n        Health[\"Health Check\"]\n    end\n\n    subgraph \"OpenTelemetry SDK\"\n        TP[\"TracerProvider\"]\n        MP[\"MeterProvider\"]\n    end\n\n    subgraph \"Exporters\"\n        Prom[\"Prometheus Exporter\"]\n        Stdout[\"Stdout Trace Exporter\"]\n        OTLP[\"OTLP gRPC Exporter\"]\n    end\n\n    subgraph \"External\"\n        PromServer[\"Prometheus&lt;br/&gt;:9090/metrics\"]\n        Collector[\"OTel Collector\"]\n    end\n\n    API --&gt; OTelMux --&gt; Handlers\n    Handlers --&gt; IS --&gt; Storage\n    Health --&gt; Storage\n\n    OTelMux --&gt; TP\n    IS --&gt; TP\n    IS --&gt; MP\n\n    TP --&gt; Stdout\n    TP --&gt; OTLP\n    MP --&gt; Prom\n\n    Prom --&gt; PromServer\n    OTLP --&gt; Collector</code></pre>"},{"location":"observability/#configuration","title":"Configuration","text":"<p>Observability is configured through two sections in the configuration file: <code>metrics</code> and <code>observability</code>.</p> <pre><code>metrics:\n  enabled: true\n  path: \"/metrics\"\n  port: 9090\n\nobservability:\n  service_name: \"updater\"\n  tracing:\n    enabled: true\n    exporter: \"stdout\"        # stdout | otlp\n    sample_rate: 1.0\n    otlp_endpoint: \"\"         # e.g., \"localhost:4317\"\n</code></pre> <p>Note: Service version is no longer configured here. It is automatically set from build-time metadata injected via ldflags. See the Version Metadata section below.</p>"},{"location":"observability/#configuration-reference","title":"Configuration Reference","text":"Field Type Default Description <code>metrics.enabled</code> bool <code>true</code> Enable Prometheus metrics collection <code>metrics.path</code> string <code>/metrics</code> HTTP path for Prometheus scraping <code>metrics.port</code> int <code>9090</code> Port for the metrics HTTP server <code>observability.service_name</code> string <code>updater</code> OpenTelemetry service name resource attribute <code>observability.tracing.enabled</code> bool <code>false</code> Enable distributed tracing <code>observability.tracing.exporter</code> string <code>stdout</code> Trace exporter type: <code>stdout</code> or <code>otlp</code> <code>observability.tracing.sample_rate</code> float <code>1.0</code> Sampling rate (0.0 to 1.0) <code>observability.tracing.otlp_endpoint</code> string <code>\"\"</code> OTLP gRPC collector endpoint (required when exporter is <code>otlp</code>)"},{"location":"observability/#backward-compatibility","title":"Backward Compatibility","text":"<p>If the <code>observability</code> section is absent from the configuration, tracing defaults to disabled. Metrics configuration is unchanged from previous versions.</p>"},{"location":"observability/#metrics","title":"Metrics","text":"<p>When metrics are enabled, the service starts a separate HTTP server on the configured port (default 9090) that serves Prometheus-format metrics.</p>"},{"location":"observability/#available-metrics","title":"Available Metrics","text":""},{"location":"observability/#http-metrics-via-otelmux","title":"HTTP Metrics (via otelmux)","text":"<p>Automatically collected for all API requests (excluding <code>/health</code> and <code>/metrics</code>):</p> <ul> <li><code>http.server.request.duration</code> - Request duration histogram</li> <li><code>http.server.active_requests</code> - Currently active requests gauge</li> </ul>"},{"location":"observability/#storage-metrics-via-instrumentedstorage","title":"Storage Metrics (via InstrumentedStorage)","text":"<p>Collected for every storage operation:</p> <ul> <li><code>storage.operation.duration</code> - Operation duration histogram (seconds), labeled by <code>operation</code></li> <li><code>storage.operation.errors</code> - Error counter, labeled by <code>operation</code></li> </ul> <p>Storage operation labels include: <code>Applications</code>, <code>GetApplication</code>, <code>SaveApplication</code>, <code>Releases</code>, <code>GetRelease</code>, <code>SaveRelease</code>, <code>DeleteRelease</code>, <code>GetLatestRelease</code>, <code>GetReleasesAfterVersion</code>, <code>Ping</code>.</p>"},{"location":"observability/#scraping","title":"Scraping","text":"<p>Configure Prometheus to scrape the metrics endpoint:</p> <pre><code>scrape_configs:\n  - job_name: 'updater'\n    scrape_interval: 15s\n    static_configs:\n      - targets: ['localhost:9090']\n</code></pre>"},{"location":"observability/#tracing","title":"Tracing","text":"<p>When tracing is enabled, the service creates trace spans for:</p> <ol> <li>HTTP requests -- Automatic spans via <code>otelmux</code> middleware for all API routes (health and metrics endpoints are filtered out)</li> <li>Storage operations -- Spans for every storage method call via <code>InstrumentedStorage</code>, including attributes like <code>app_id</code>, <code>version</code>, <code>platform</code>, and <code>arch</code></li> </ol>"},{"location":"observability/#exporters","title":"Exporters","text":""},{"location":"observability/#stdout","title":"stdout","text":"<p>Prints trace spans to stdout in a human-readable format. Useful for development and debugging.</p> <pre><code>observability:\n  tracing:\n    enabled: true\n    exporter: \"stdout\"\n</code></pre>"},{"location":"observability/#otlp-grpc","title":"OTLP gRPC","text":"<p>Exports traces to an OpenTelemetry Collector via gRPC. Use this for production deployments.</p> <pre><code>observability:\n  tracing:\n    enabled: true\n    exporter: \"otlp\"\n    otlp_endpoint: \"otel-collector:4317\"\n</code></pre>"},{"location":"observability/#sampling","title":"Sampling","text":"<p>The <code>sample_rate</code> controls what fraction of traces are recorded:</p> <ul> <li><code>1.0</code> -- Sample all traces (development)</li> <li><code>0.1</code> -- Sample 10% of traces (production)</li> <li><code>0.0</code> -- Disable sampling (no traces recorded)</li> </ul>"},{"location":"observability/#resource-attributes","title":"Resource Attributes","text":"<p>OpenTelemetry resource attributes provide context about the service instance. These attributes are automatically attached to all metrics and traces.</p>"},{"location":"observability/#standard-attributes-opentelemetry-semantic-conventions","title":"Standard Attributes (OpenTelemetry Semantic Conventions)","text":"Attribute Source Example Description <code>service.name</code> Configuration <code>updater</code> Service identifier from <code>observability.service_name</code> <code>service.version</code> Build metadata <code>v1.0.0</code> Version from git tags, injected at build time"},{"location":"observability/#custom-attributes","title":"Custom Attributes","text":"Attribute Source Example Description <code>service.instance.id</code> Runtime <code>550e8400-e29b-41d4-a716-446655440000</code> Unique UUID generated at startup <code>host.name</code> Runtime <code>updater-prod-01</code> System hostname from <code>os.Hostname()</code> <code>git.commit</code> Build metadata <code>a1b2c3d</code> Short git commit hash, injected at build time <code>build.date</code> Build metadata <code>2026-02-21T10:00:00Z</code> Build timestamp in RFC 3339 format <code>deployment.environment</code> Environment <code>production</code> Deployment environment from <code>ENVIRONMENT</code> or <code>DEPLOYMENT_ENV</code> env var (defaults to <code>development</code>)"},{"location":"observability/#build-metadata-injection","title":"Build Metadata Injection","text":"<p>Build-time attributes (version, git.commit, build.date) are injected via ldflags during compilation:</p> <pre><code>VERSION := $(shell git describe --tags --always --dirty)\nGIT_COMMIT := $(shell git rev-parse --short HEAD)\nBUILD_DATE := $(shell date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n\nLDFLAGS := -X 'updater/internal/version.Version=$(VERSION)' \\\n           -X 'updater/internal/version.GitCommit=$(GIT_COMMIT)' \\\n           -X 'updater/internal/version.BuildDate=$(BUILD_DATE)'\n\ngo build -ldflags \"$(LDFLAGS)\" ./cmd/updater\n</code></pre> <p>For Docker builds, pass build arguments:</p> <pre><code>docker build \\\n  --build-arg VERSION=$(git describe --tags --always) \\\n  --build-arg VCS_REF=$(git rev-parse --short HEAD) \\\n  --build-arg BUILD_DATE=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\") \\\n  -t updater:latest .\n</code></pre> <p>Note: The <code>scripts/docker-build.sh</code> script and <code>make docker-build</code> target handle build argument injection automatically.</p> <p>Local development builds will show \"unknown\" for these values, which is expected. CI/CD pipelines should always inject proper values.</p>"},{"location":"observability/#environment-detection","title":"Environment Detection","text":"<p>The <code>deployment.environment</code> attribute is determined from environment variables:</p> <ol> <li><code>ENVIRONMENT</code> environment variable (if set)</li> <li><code>DEPLOYMENT_ENV</code> environment variable (if set)</li> <li>Defaults to <code>development</code> if neither is set</li> </ol> <p>This allows easy differentiation between development, staging, and production traces.</p>"},{"location":"observability/#health-checks","title":"Health Checks","text":"<p>The <code>/health</code> endpoint performs real storage connectivity verification by calling <code>Ping()</code> on the storage backend.</p>"},{"location":"observability/#storage-ping-behavior","title":"Storage Ping Behavior","text":"Storage Type Ping Implementation Memory Always returns nil (in-process) JSON Always returns nil (file verified at init) PostgreSQL Executes <code>db.PingContext()</code> on the connection pool SQLite Executes <code>db.PingContext()</code> on the database connection"},{"location":"observability/#response-states","title":"Response States","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; healthy: Storage ping succeeds\n    [*] --&gt; degraded: Storage ping fails\n    healthy --&gt; [*]\n    degraded --&gt; [*]</code></pre> <ul> <li>healthy -- All components operational, storage ping succeeded</li> <li>degraded -- API is operational but storage ping failed; the storage component is reported as <code>unhealthy</code></li> </ul>"},{"location":"observability/#example-response-healthy","title":"Example Response (healthy)","text":"<pre><code>{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2026-02-15T10:30:00Z\",\n  \"version\": \"v1.0.0\",\n  \"components\": {\n    \"storage\": {\n      \"status\": \"healthy\",\n      \"message\": \"Storage is operational\",\n      \"timestamp\": \"2026-02-15T10:30:00Z\"\n    },\n    \"api\": {\n      \"status\": \"healthy\",\n      \"message\": \"API is operational\",\n      \"timestamp\": \"2026-02-15T10:30:00Z\"\n    }\n  }\n}\n</code></pre>"},{"location":"observability/#example-response-degraded","title":"Example Response (degraded)","text":"<pre><code>{\n  \"status\": \"degraded\",\n  \"timestamp\": \"2026-02-15T10:30:00Z\",\n  \"version\": \"1.0.0\",\n  \"components\": {\n    \"storage\": {\n      \"status\": \"unhealthy\",\n      \"message\": \"Storage ping failed: connection refused\",\n      \"timestamp\": \"2026-02-15T10:30:00Z\"\n    },\n    \"api\": {\n      \"status\": \"healthy\",\n      \"message\": \"API is operational\",\n      \"timestamp\": \"2026-02-15T10:30:00Z\"\n    }\n  }\n}\n</code></pre>"},{"location":"observability/#local-development-stack","title":"Local Development Stack","text":"<p>A Docker Compose-based observability stack is available for local development. It runs Jaeger, Prometheus, and Grafana alongside the updater service, providing trace visualization, metrics scraping, and dashboards without any external dependencies.</p>"},{"location":"observability/#quick-start","title":"Quick Start","text":"<pre><code>make docker-obs-up\n</code></pre> <p>This starts all four services:</p> Service URL Purpose Updater <code>http://localhost:8080</code> The update service API Updater Metrics <code>http://localhost:9090/metrics</code> Prometheus-format metrics endpoint Jaeger UI <code>http://localhost:16686</code> Trace visualization Prometheus <code>http://localhost:9091</code> Metrics querying and scrape status Grafana <code>http://localhost:3000</code> Dashboards (no login required) <p>To stop the stack:</p> <pre><code>make docker-obs-down\n</code></pre>"},{"location":"observability/#architecture_1","title":"Architecture","text":"<pre><code>graph LR\n    subgraph \"Docker Compose\"\n        Updater[\"Updater&lt;br/&gt;:8080 API&lt;br/&gt;:9090 Metrics\"]\n        Jaeger[\"Jaeger v2&lt;br/&gt;:16686 UI&lt;br/&gt;:4317 OTLP\"]\n        Prom[\"Prometheus&lt;br/&gt;:9091 UI\"]\n        Grafana[\"Grafana&lt;br/&gt;:3000 UI\"]\n    end\n\n    Updater -- \"OTLP gRPC :4317\" --&gt; Jaeger\n    Prom -- \"Scrape :9090/metrics\" --&gt; Updater\n    Grafana -- \"Query\" --&gt; Prom\n    Grafana -- \"Query\" --&gt; Jaeger</code></pre> <p>The updater sends traces directly to Jaeger v2 via OTLP gRPC (no separate OpenTelemetry Collector required). Prometheus scrapes the updater's metrics endpoint every 15 seconds. Grafana is pre-configured with both Prometheus and Jaeger as datasources.</p>"},{"location":"observability/#configuration_1","title":"Configuration","text":"<p>The observability stack uses <code>configs/dev-observability.yaml</code>, which configures:</p> <ul> <li>Storage: In-memory (no file or database dependencies)</li> <li>Auth: Disabled (simplifies local development)</li> <li>Metrics: Enabled on port 9090</li> <li>Tracing: OTLP exporter pointing to <code>jaeger:4317</code> with 100% sampling</li> <li>Logging: Debug level, text format</li> </ul>"},{"location":"observability/#verifying-traces","title":"Verifying Traces","text":"<ol> <li>Start the stack with <code>make docker-obs-up</code></li> <li> <p>Send a request to the API:</p> <pre><code>curl \"http://localhost:8080/api/v1/updates/test-app/check?current_version=1.0.0&amp;platform=windows&amp;architecture=amd64\"\n</code></pre> </li> <li> <p>Open the Jaeger UI at <code>http://localhost:16686</code></p> </li> <li>Select the <code>updater</code> service and click Find Traces</li> <li>Trace spans for the HTTP request and storage operations are visible</li> </ol>"},{"location":"observability/#verifying-metrics","title":"Verifying Metrics","text":"<ol> <li>Open Prometheus at <code>http://localhost:9091</code></li> <li>Navigate to Status &gt; Targets to confirm the updater target is in the <code>UP</code> state</li> <li>Query metrics such as <code>storage_operation_duration_seconds_bucket</code> or <code>http_server_request_duration_seconds_bucket</code></li> </ol>"},{"location":"observability/#files","title":"Files","text":"<pre><code>docker-compose.observability.yml           # Compose override (layered on docker-compose.yml)\nconfigs/dev-observability.yaml             # Updater config with OTLP tracing\ndocker/prometheus/prometheus.yml           # Prometheus scrape configuration\ndocker/grafana/provisioning/\n    datasources/datasources.yml            # Auto-provisioned Grafana datasources\n</code></pre>"},{"location":"observability/#package-structure","title":"Package Structure","text":"<pre><code>internal/observability/\n    observability.go       # SDK setup: TracerProvider, MeterProvider, shutdown\n    metrics.go             # Prometheus HTTP server on metrics port\n    storage.go             # InstrumentedStorage wrapper with tracing and metrics\n    observability_test.go  # Tests for SDK setup and shutdown\n    metrics_test.go        # Tests for metrics server\n    storage_test.go        # Tests for instrumented storage\n</code></pre>"},{"location":"observability/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>On application shutdown, the observability stack is cleaned up in order:</p> <ol> <li>Metrics server is shut down (stops accepting scrape requests)</li> <li>Main HTTP server is shut down (finishes in-flight requests)</li> <li>OpenTelemetry providers are shut down (flushes pending spans and metrics)</li> <li>Storage is closed</li> </ol> <p>This ensures all telemetry data from in-flight requests is exported before the providers are destroyed.</p>"},{"location":"openapi/","title":"OpenAPI Specification","text":"<p>The updater service ships with a machine-readable OpenAPI 3.0.3 specification embedded directly in the binary. The spec is served at runtime alongside an interactive Swagger UI.</p>"},{"location":"openapi/#endpoints","title":"Endpoints","text":"Path Description <code>GET /api/v1/openapi.yaml</code> Raw OpenAPI 3.0.3 YAML specification <code>GET /api/v1/docs</code> Interactive Swagger UI (loads spec from CDN) <p>Both endpoints are public and require no authentication.</p>"},{"location":"openapi/#accessing-the-spec","title":"Accessing the Spec","text":""},{"location":"openapi/#curl","title":"curl","text":"<p>Download the raw YAML:</p> <pre><code>curl http://localhost:8080/api/v1/openapi.yaml\n</code></pre> <p>Save it locally for offline use:</p> <pre><code>curl -o openapi.yaml http://localhost:8080/api/v1/openapi.yaml\n</code></pre>"},{"location":"openapi/#postman","title":"Postman","text":"<ol> <li>Open Postman and select Import.</li> <li>Choose Link and paste <code>http://localhost:8080/api/v1/openapi.yaml</code>.</li> <li>Postman will import all endpoints, parameters, and example request bodies.</li> </ol>"},{"location":"openapi/#code-generators","title":"Code generators","text":"<p>The spec can be used with any OpenAPI 3.0-compatible code generator.</p> <p>Go client (oapi-codegen):</p> <pre><code>oapi-codegen -package client -generate types,client openapi.yaml &gt; client/client.gen.go\n</code></pre> <p>TypeScript client (openapi-typescript):</p> <pre><code>npx openapi-typescript http://localhost:8080/api/v1/openapi.yaml -o types.d.ts\n</code></pre> <p>Python client (openapi-python-client):</p> <pre><code>openapi-python-client generate --url http://localhost:8080/api/v1/openapi.yaml\n</code></pre>"},{"location":"openapi/#interactive-ui","title":"Interactive UI","text":"<p>Open <code>http://localhost:8080/api/v1/docs</code> in a browser to access Swagger UI. The UI loads the spec from <code>/api/v1/openapi.yaml</code> and lets you browse every endpoint, inspect schemas, and execute live requests against the running server.</p> <p>Note: The interactive UI loads Swagger UI from the unpkg CDN. An active internet connection is required. For offline use, download the raw YAML with <code>curl</code> and open it with a local Swagger viewer or import it into Postman.</p>"},{"location":"openapi/#validation","title":"Validation","text":"<p>Validate the spec with Redocly CLI:</p> <pre><code>make openapi-validate\n</code></pre> <p>This runs <code>redocly/cli:latest</code> in Docker against <code>internal/api/openapi/openapi.yaml</code> and reports any lint violations without requiring a local Node.js installation.</p>"},{"location":"openapi/#architecture","title":"Architecture","text":"<p>The spec is embedded in the binary using Go's <code>embed</code> package. No external files are needed at runtime.</p> <pre><code>flowchart LR\n    F[internal/api/openapi/openapi.yaml] --&gt;|go:embed| B[handlers_openapi.go\\nopenAPISpec []byte]\n    B --&gt; S[ServeOpenAPISpec\\nGET /api/v1/openapi.yaml]\n    B --&gt; U[ServeSwaggerUI\\nGET /api/v1/docs]\n    S --&gt;|application/yaml| C1[curl / Postman / codegen]\n    U --&gt;|text/html| C2[Browser + unpkg CDN]</code></pre>"},{"location":"openapi/#spec-location","title":"Spec Location","text":"<p>The source YAML is at <code>internal/api/openapi/openapi.yaml</code>. Edit it to add or update endpoint documentation, then rebuild the binary so the new version is embedded:</p> <pre><code>make build\n</code></pre>"},{"location":"publishing/","title":"Publishing","text":"<p>The <code>publish</code> CI workflow builds the Docker image and pushes it to the GitHub Container Registry (GHCR) on every push to <code>main</code> and on every <code>v*</code> tag. Tagged pushes also create a GitHub release.</p>"},{"location":"publishing/#triggers","title":"Triggers","text":"Event Job Result Push to <code>main</code> <code>publish</code> Image tagged with short SHA and <code>latest</code> Push of <code>v*</code> tag <code>release</code> Image tagged with version and <code>latest</code>, GitHub release created"},{"location":"publishing/#workflows","title":"Workflows","text":""},{"location":"publishing/#push-to-main","title":"Push to main","text":"<pre><code>flowchart LR\n    push[Push to main] --&gt; login[Log in to GHCR]\n    login --&gt; build[make docker-push]\n    build --&gt; ghcr[(ghcr.io/OWNER/updater:SHA\\nghcr.io/OWNER/updater:latest)]</code></pre>"},{"location":"publishing/#tag-push","title":"Tag push","text":"<pre><code>flowchart LR\n    tag[Push v* tag] --&gt; login[Log in to GHCR]\n    login --&gt; build[make docker-push]\n    build --&gt; ghcr[(ghcr.io/OWNER/updater:v1.2.3\\nghcr.io/OWNER/updater:latest)]\n    build --&gt; rel[gh release create]\n    rel --&gt; release[GitHub release with auto-generated notes]</code></pre> <p>Both jobs use the built-in <code>GITHUB_TOKEN</code> for authentication \u2014 no secrets or external service accounts are needed.</p>"},{"location":"publishing/#permissions","title":"Permissions","text":"Job Permission Reason <code>publish</code> <code>contents: read</code> Checkout the repository <code>publish</code> <code>packages: write</code> Push images to GHCR <code>release</code> <code>contents: write</code> Create GitHub releases <code>release</code> <code>packages: write</code> Push images to GHCR"},{"location":"publishing/#image-naming","title":"Image naming","text":"<p>The <code>make docker-push</code> target delegates to <code>scripts/docker-build.sh --push</code>, which reads <code>DOCKER_REGISTRY</code> and <code>VERSION</code> from the environment.</p>"},{"location":"publishing/#push-to-main_1","title":"Push to main","text":"<p><code>VERSION</code> is not set, so the script defaults to <code>git rev-parse --short HEAD</code>:</p> <pre><code>ghcr.io/griffinskudder/updater:abc1234\nghcr.io/griffinskudder/updater:latest\n</code></pre>"},{"location":"publishing/#tag-push_1","title":"Tag push","text":"<p><code>VERSION</code> is set to <code>github.ref_name</code> (e.g. <code>v1.2.3</code>):</p> <pre><code>ghcr.io/griffinskudder/updater:v1.2.3\nghcr.io/griffinskudder/updater:latest\n</code></pre>"},{"location":"publishing/#creating-a-release","title":"Creating a release","text":"<p>Push a tag that starts with <code>v</code> to trigger the <code>release</code> job:</p> <pre><code>git tag v1.2.3\ngit push origin v1.2.3\n</code></pre> <p>The job will:</p> <ol> <li>Build and push the image tagged <code>v1.2.3</code> and <code>latest</code>.</li> <li>Create a GitHub release named <code>v1.2.3</code> with auto-generated notes summarising the pull requests merged since the previous tag.</li> </ol>"},{"location":"publishing/#image-visibility","title":"Image visibility","text":"<p>By default, packages pushed by a workflow inherit the visibility of the repository. Visibility can be changed in Settings &gt; Packages on GitHub.</p>"},{"location":"rate-limiting/","title":"Rate Limiting","text":"<p>Rate limiting is no longer handled by the updater service itself. It is the responsibility of the reverse proxy that sits in front of the service.</p> <p>See Reverse Proxy for nginx and Traefik examples that configure IP-based rate limiting at the proxy layer.</p>"},{"location":"reverse-proxy/","title":"Reverse Proxy","text":"<p>The updater service does not enforce CORS headers, rate limits, or TLS itself. These concerns must be configured at the reverse proxy layer for every production deployment.</p>"},{"location":"reverse-proxy/#why-a-reverse-proxy","title":"Why a reverse proxy?","text":"<p>A reverse proxy (nginx, Traefik, Caddy, Cloudflare) provides these features with more flexibility and less operational overhead than embedding them in the service:</p> <ul> <li>TLS termination and certificate renewal (Let's Encrypt)</li> <li>CORS header management per route and origin</li> <li>Rate limiting with IP-based and token-bucket strategies</li> <li>Security headers (HSTS, CSP, X-Frame-Options)</li> <li>Load balancing across multiple service replicas</li> </ul>"},{"location":"reverse-proxy/#example-configurations","title":"Example configurations","text":"<p>Ready-to-use configurations are provided in the <code>examples/</code> directory:</p> Directory Proxy What it provides <code>examples/nginx/</code> nginx TLS (manual certs), CORS, rate limiting, security headers <code>examples/traefik/</code> Traefik v3 TLS (Let's Encrypt), CORS middleware, rate limiting, security headers <p>Each directory contains an <code>nginx.conf</code> or <code>docker-compose.yml</code> ready to use with minor substitution of your domain and certificate paths.</p>"},{"location":"reverse-proxy/#real-client-ip-in-logs","title":"Real client IP in logs","text":"<p>When running behind a proxy, <code>r.RemoteAddr</code> in the service will be the proxy IP, not the client IP. The nginx and Traefik examples forward <code>X-Real-IP</code> and <code>X-Forwarded-For</code>. If you need the client IP in service logs, read the <code>X-Real-IP</code> header in your application or configure your proxy to replace <code>RemoteAddr</code> directly.</p>"},{"location":"reverse-proxy/#tls","title":"TLS","text":"<p>Both example configurations terminate TLS at the proxy and forward plain HTTP to the service on port 8080. Do not expose port 8080 directly to the internet.</p>"},{"location":"reverse-proxy/#migrating-from-previous-config","title":"Migrating from previous config","text":"<p>If your <code>config.yaml</code> contains any of the following keys, they are no longer used. The service logs a warning on startup and continues running. Remove them from your config and configure the equivalent at your proxy instead.</p> Removed config key Proxy equivalent <code>server.cors</code> <code>add_header Access-Control-*</code> (nginx) or <code>headers</code> middleware (Traefik) <code>security.rate_limit</code> <code>limit_req_zone</code> (nginx) or <code>rateLimit</code> middleware (Traefik) <code>security.trusted_proxies</code> Proxy trust is unconditional -- remove this key <code>security.jwt_secret</code> Not used -- remove this key"},{"location":"storage/","title":"Storage","text":"<p>The updater service uses a pluggable storage layer that supports multiple backends for persisting application and release metadata. All providers implement the same <code>Storage</code> interface, enabling seamless switching between backends based on deployment needs.</p>"},{"location":"storage/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Storage Interface] --&gt; B[JSON File Storage]\n    A --&gt; C[Memory Storage]\n    A --&gt; D[PostgreSQL Storage]\n    A --&gt; E[SQLite Storage]\n    F[Factory] --&gt; A\n    G[Configuration] --&gt; F\n    D --&gt; H[sqlc Generated Queries]\n    E --&gt; I[sqlc Generated Queries]\n    H --&gt; J[PostgreSQL Database]\n    I --&gt; K[SQLite Database]</code></pre>"},{"location":"storage/#provider-comparison","title":"Provider Comparison","text":"Feature JSON Memory SQLite PostgreSQL Persistence File-based None (in-memory) File-based Server-based Concurrency Thread-safe with caching Thread-safe (RWMutex) Single writer (WAL mode) Full concurrent access Setup No external dependencies No setup needed No external dependencies Requires PostgreSQL server Performance Good for small datasets Fastest (no I/O) Good for medium datasets Best for large datasets Use Case Development, small deployments Testing, development Single-server deployments Production, multi-server CGO Required No No No (pure Go driver) No Schema Management Automatic Automatic Automatic (embedded DDL) Manual migration required"},{"location":"storage/#storage-interface","title":"Storage Interface","text":"<p>All providers implement 15 methods covering application, release, and API key CRUD operations, plus health and lifecycle management:</p> <pre><code>classDiagram\n    class Storage {\n        &lt;&lt;interface&gt;&gt;\n        +Applications(ctx) []*Application, error\n        +GetApplication(ctx, appID) *Application, error\n        +SaveApplication(ctx, app) error\n        +DeleteApplication(ctx, appID) error\n        +Releases(ctx, appID) []*Release, error\n        +GetRelease(ctx, appID, version, platform, arch) *Release, error\n        +SaveRelease(ctx, release) error\n        +DeleteRelease(ctx, appID, version, platform, arch) error\n        +GetLatestRelease(ctx, appID, platform, arch) *Release, error\n        +GetReleasesAfterVersion(ctx, appID, version, platform, arch) []*Release, error\n        +Ping(ctx) error\n        +Close() error\n        +CreateAPIKey(ctx, key) error\n        +GetAPIKeyByHash(ctx, hash) *APIKey, error\n        +ListAPIKeys(ctx) []*APIKey, error\n        +UpdateAPIKey(ctx, key) error\n        +DeleteAPIKey(ctx, id) error\n    }</code></pre>"},{"location":"storage/#configuration","title":"Configuration","text":""},{"location":"storage/#json-storage","title":"JSON Storage","text":"<pre><code>storage:\n  type: json\n  path: ./data/releases.json\n</code></pre>"},{"location":"storage/#memory-storage","title":"Memory Storage","text":"<pre><code>storage:\n  type: memory\n</code></pre>"},{"location":"storage/#sqlite-storage","title":"SQLite Storage","text":"<pre><code>storage:\n  type: sqlite\n  database:\n    dsn: ./data/updater.db\n</code></pre>"},{"location":"storage/#postgresql-storage","title":"PostgreSQL Storage","text":"<pre><code>storage:\n  type: postgres\n  database:\n    dsn: postgres://user:password@localhost:5432/updater?sslmode=disable\n</code></pre>"},{"location":"storage/#provider-details","title":"Provider Details","text":""},{"location":"storage/#json-file-storage","title":"JSON File Storage","text":"<p>Stores all data in a single JSON file with an in-memory cache. Thread-safe using read-write mutexes with configurable cache TTL. Best suited for development and small deployments with limited data.</p>"},{"location":"storage/#memory-storage_1","title":"Memory Storage","text":"<p>Stores data in Go maps protected by <code>sync.RWMutex</code>. Returns copies of all data to prevent external mutation. Data is lost on service restart. Ideal for testing and development environments.</p>"},{"location":"storage/#sqlite-storage_1","title":"SQLite Storage","text":"<p>Uses the <code>modernc.org/sqlite</code> pure-Go driver (no CGO required). The schema is automatically created on startup using an embedded SQL file with <code>IF NOT EXISTS</code> guards. Key characteristics:</p> <ul> <li>WAL mode enabled for better concurrent read performance</li> <li>Foreign keys enabled for referential integrity</li> <li>Single connection to prevent concurrency issues with SQLite's single-writer model</li> <li>Semantic version comparison performed in Go after fetching results</li> <li>Upsert pattern: check-then-create/update for <code>SaveApplication</code> and <code>SaveRelease</code></li> </ul>"},{"location":"storage/#postgresql-storage_1","title":"PostgreSQL Storage","text":"<p>Uses <code>pgx/v5</code> with connection pooling via <code>pgxpool</code>. All queries are generated by sqlc for type safety. Key characteristics:</p> <ul> <li>Connection pooling for efficient resource usage</li> <li>JSONB columns for platforms, config, and metadata fields</li> <li>Timestamptz for proper timezone-aware timestamps</li> <li>Cascade deletes from applications to releases</li> <li>Semantic version comparison performed in Go after fetching results</li> <li>Upsert pattern: check-then-create/update for <code>SaveApplication</code> and <code>SaveRelease</code></li> </ul>"},{"location":"storage/#database-schema","title":"Database Schema","text":"<p>Both database providers share the same logical schema with engine-specific type differences:</p> <pre><code>erDiagram\n    applications {\n        TEXT id PK\n        TEXT name\n        TEXT description\n        JSON platforms\n        JSON config\n        TIMESTAMP created_at\n        TIMESTAMP updated_at\n    }\n    releases {\n        TEXT id PK\n        TEXT application_id FK\n        TEXT version\n        TEXT platform\n        TEXT architecture\n        TEXT download_url\n        TEXT checksum\n        TEXT checksum_type\n        BIGINT file_size\n        TEXT release_notes\n        TIMESTAMP release_date\n        BOOLEAN required\n        TEXT minimum_version\n        JSON metadata\n        TIMESTAMP created_at\n    }\n    api_keys {\n        TEXT id PK\n        TEXT name\n        TEXT key_hash UK\n        TEXT prefix\n        TEXT permissions\n        INTEGER enabled\n        TIMESTAMP created_at\n        TIMESTAMP updated_at\n    }\n    applications ||--o{ releases : \"has many\"</code></pre> <p>The <code>api_keys.permissions</code> column stores a JSON array of permission strings (e.g. <code>[\"admin\"]</code>). The <code>enabled</code> column uses <code>INTEGER</code> (0/1) in SQLite and <code>BOOLEAN</code> in PostgreSQL.</p>"},{"location":"storage/#type-differences","title":"Type Differences","text":"Model Type PostgreSQL SQLite JSON fields <code>JSONB</code> (binary, indexed) <code>TEXT</code> (string) Timestamps <code>TIMESTAMPTZ</code> <code>TEXT</code> (ISO8601) Large integers <code>BIGINT</code> <code>INTEGER</code> Nullable strings <code>pgtype.Text</code> <code>sql.NullString</code>"},{"location":"storage/#type-conversion","title":"Type Conversion","text":"<p>Shared conversion helpers in <code>dbconvert.go</code> handle JSON marshaling for:</p> <ul> <li>Platforms: <code>[]string</code> to/from JSON</li> <li>Config: <code>ApplicationConfig</code> struct to/from JSON</li> <li>Metadata: <code>map[string]string</code> to/from JSON</li> </ul> <p>Each provider has additional helpers for engine-specific type conversions (e.g., <code>pgtype.Text</code> for PostgreSQL, <code>sql.NullString</code> for SQLite).</p>"},{"location":"storage/#factory-pattern","title":"Factory Pattern","text":"<p>The <code>Factory</code> type provides centralized provider instantiation:</p> <pre><code>factory := storage.NewFactory()\nstore, err := factory.Create(config.Storage)\n</code></pre> <p>The factory validates configuration before creating providers and supports all four backend types.</p>"},{"location":"storage/#database-schema-docs","title":"Database Schema Docs","text":"<p>The auto-generated schema reference (including ER diagrams per table) lives in the Database section. It is generated from the live PostgreSQL schema by running:</p> <pre><code>make docs-db\n</code></pre>"},{"location":"storage/#testing","title":"Testing","text":"<ul> <li>Memory: Full CRUD tests with concurrency testing</li> <li>JSON: File I/O tests with caching and concurrent access</li> <li>SQLite: Full CRUD tests using <code>:memory:</code> (always runs, no external DB)</li> <li>PostgreSQL: Full CRUD tests skipped unless <code>POSTGRES_TEST_DSN</code> env var is set</li> </ul>"},{"location":"use-cases/","title":"Use Cases","text":"<p>The updater service solves a common problem: delivering software updates reliably to desktop applications across platforms. This page walks through five realistic scenarios that demonstrate how the service fits into real-world workflows. Each scenario identifies a pain point, shows the relevant API interactions, and highlights the features that address the problem. Whether you are evaluating the service for a single application or planning a multi-app deployment, these examples provide a concrete starting point.</p>"},{"location":"use-cases/#delivering-updates-to-a-cross-platform-desktop-application","title":"Delivering Updates to a Cross-Platform Desktop Application","text":""},{"location":"use-cases/#the-problem","title":"The Problem","text":"<p>Teams maintaining desktop applications for Windows, macOS, and Linux face a recurring challenge: each platform needs version-comparison logic, download metadata, and integrity verification. Without a central service, teams often maintain hand-edited JSON files or per-platform update scripts that drift out of sync.</p>"},{"location":"use-cases/#how-the-updater-service-solves-it","title":"How the Updater Service Solves It","text":"<p>The service accepts platform and architecture as query parameters, performs server-side version comparison, and returns structured metadata including download URL, checksum, and file size. The application downloads the binary directly from existing CDN infrastructure -- the updater service handles routing, not file hosting.</p> <pre><code>sequenceDiagram\n    participant App as Desktop App\n    participant Svc as Updater Service\n    participant CDN as CDN / File Host\n\n    App-&gt;&gt;Svc: GET /api/v1/updates/photo-editor/check&lt;br/&gt;?platform=windows&amp;architecture=amd64&lt;br/&gt;&amp;current_version=1.5.0\n    Svc--&gt;&gt;App: UpdateCheckResponse (JSON)\n    App-&gt;&gt;CDN: Download binary from download_url\n    CDN--&gt;&gt;App: Binary file\n    App-&gt;&gt;App: Verify checksum, install update</code></pre>"},{"location":"use-cases/#example-checking-for-updates-across-platforms","title":"Example: Checking for Updates Across Platforms","text":"Windows (amd64)macOS (arm64)Linux (amd64) <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=1.5.0\"\n</code></pre> <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=darwin&amp;architecture=arm64&amp;current_version=1.5.0\"\n</code></pre> <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=linux&amp;architecture=amd64&amp;current_version=1.5.0\"\n</code></pre>"},{"location":"use-cases/#example-response","title":"Example Response","text":"<pre><code>{\n  \"update_available\": true,\n  \"latest_version\": \"2.0.0\",\n  \"current_version\": \"1.5.0\",\n  \"download_url\": \"https://cdn.example.com/photo-editor/2.0.0/photo-editor-windows-amd64.exe\",\n  \"checksum\": \"a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2\",\n  \"checksum_type\": \"sha256\",\n  \"file_size\": 52428800,\n  \"release_notes\": \"New RAW processing engine with 3x faster export times.\",\n  \"release_date\": \"2026-02-10T14:30:00Z\",\n  \"required\": false,\n  \"minimum_version\": \"\"\n}\n</code></pre>"},{"location":"use-cases/#key-points","title":"Key Points","text":"<ul> <li>Platform routing is server-side. The client sends its platform and architecture; the service determines which release to offer. No client-side branching logic needed.</li> <li>Checksum and file size are delivered with every response. Clients can verify integrity before installation and show accurate download progress.</li> <li>Download files stay on existing infrastructure. The service stores metadata and <code>download_url</code> references; it does not proxy or host binaries.</li> </ul>"},{"location":"use-cases/#enforcing-a-critical-security-patch","title":"Enforcing a Critical Security Patch","text":""},{"location":"use-cases/#the-problem_1","title":"The Problem","text":"<p>A vulnerability is discovered in a shipped version of the application. Users on affected versions must be updated immediately -- they should not be able to dismiss or skip the update.</p>"},{"location":"use-cases/#how-the-updater-service-solves-it_1","title":"How the Updater Service Solves It","text":"<p>The <code>required</code> field is a first-class attribute on every release. When a release is registered with <code>required: true</code>, the check endpoint returns that flag to affected clients. The <code>minimum_version</code> field scopes which versions are affected: clients already running a version at or above the minimum receive no update prompt.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; AppLaunch\n    AppLaunch --&gt; CheckForUpdate\n    CheckForUpdate --&gt; EvaluateResponse\n\n    state EvaluateResponse &lt;&lt;choice&gt;&gt;\n    EvaluateResponse --&gt; MandatoryUpdate: required = true\n    EvaluateResponse --&gt; OptionalUpdate: update_available = true,&lt;br/&gt;required = false\n    EvaluateResponse --&gt; NormalOperation: update_available = false\n\n    MandatoryUpdate --&gt; BlockUntilUpdated\n    BlockUntilUpdated --&gt; [*]\n\n    OptionalUpdate --&gt; ShowUpdatePrompt\n    ShowUpdatePrompt --&gt; NormalOperation: User dismisses\n    ShowUpdatePrompt --&gt; [*]: User updates\n\n    NormalOperation --&gt; [*]</code></pre>"},{"location":"use-cases/#example-registering-a-required-security-patch","title":"Example: Registering a Required Security Patch","text":"<pre><code>curl -X POST \"https://updates.example.com/api/v1/updates/photo-editor/register\" \\\n  -H \"Authorization: Bearer ${RELEASE_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"application_id\": \"photo-editor\",\n    \"version\": \"1.5.1\",\n    \"platform\": \"windows\",\n    \"architecture\": \"amd64\",\n    \"download_url\": \"https://cdn.example.com/photo-editor/1.5.1/photo-editor-windows-amd64.exe\",\n    \"checksum\": \"b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3\",\n    \"checksum_type\": \"sha256\",\n    \"file_size\": 52430000,\n    \"release_notes\": \"Security fix for CVE-2026-12345. All users on 1.x must update.\",\n    \"required\": true,\n    \"minimum_version\": \"1.0.0\"\n  }'\n</code></pre>"},{"location":"use-cases/#example-affected-client-receives-the-patch","title":"Example: Affected Client Receives the Patch","text":"<p>A client running version 1.2.0 (below the patched version) receives the required update:</p> <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=1.2.0\"\n</code></pre> <pre><code>{\n  \"update_available\": true,\n  \"latest_version\": \"1.5.1\",\n  \"current_version\": \"1.2.0\",\n  \"download_url\": \"https://cdn.example.com/photo-editor/1.5.1/photo-editor-windows-amd64.exe\",\n  \"checksum\": \"b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3\",\n  \"checksum_type\": \"sha256\",\n  \"file_size\": 52430000,\n  \"release_notes\": \"Security fix for CVE-2026-12345. All users on 1.x must update.\",\n  \"release_date\": \"2026-02-12T09:00:00Z\",\n  \"required\": true,\n  \"minimum_version\": \"1.0.0\"\n}\n</code></pre>"},{"location":"use-cases/#example-current-client-sees-no-update","title":"Example: Current Client Sees No Update","text":"<p>A client already running version 2.0.0 is unaffected:</p> <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=2.0.0\"\n</code></pre> <pre><code>{\n  \"update_available\": false,\n  \"current_version\": \"2.0.0\",\n  \"required\": false\n}\n</code></pre>"},{"location":"use-cases/#key-points_1","title":"Key Points","text":"<ul> <li><code>required</code> is a first-class field on the release. It is returned directly in the check response so clients can enforce mandatory update UI without extra logic.</li> <li><code>minimum_version</code> scopes which versions are affected. Only clients running versions below the minimum receive the required update.</li> <li>The check endpoint is public. No API key is needed to check for updates, ensuring every client can reach the security patch. Write operations (registering the release) require authentication.</li> <li>Audit logging captures the registration. Security-sensitive operations are logged with <code>\"event\": \"security_audit\"</code> for compliance and forensic purposes.</li> </ul>"},{"location":"use-cases/#progressive-rollout-with-pre-release-channels","title":"Progressive Rollout with Pre-Release Channels","text":""},{"location":"use-cases/#the-problem_2","title":"The Problem","text":"<p>A team wants beta testers to receive version 2.0.0-beta.1 while stable-channel users remain on version 1.5.0. Running a separate server or maintaining a parallel data store for the beta channel adds unwanted operational complexity.</p>"},{"location":"use-cases/#how-the-updater-service-solves-it_2","title":"How the Updater Service Solves It","text":"<p>Semantic versioning pre-release labels (e.g., <code>-beta.1</code>, <code>-rc.1</code>) are the gating mechanism. The <code>allow_prerelease</code> query parameter controls whether a client sees pre-release versions. Both populations query the same service and the same data store.</p> <pre><code>graph LR\n    subgraph Clients\n        A[Stable Users&lt;br/&gt;allow_prerelease=false]\n        B[Beta Users&lt;br/&gt;allow_prerelease=true]\n    end\n\n    subgraph Updater Service\n        C[Version Comparison&lt;br/&gt;Engine]\n    end\n\n    subgraph Releases\n        D[1.5.0 stable]\n        E[2.0.0-beta.1]\n    end\n\n    A --&gt;|check| C\n    B --&gt;|check| C\n    C --&gt; D\n    C --&gt; E\n    C --&gt;|stable only| A\n    C --&gt;|beta offered| B</code></pre>"},{"location":"use-cases/#example-registering-a-beta-release","title":"Example: Registering a Beta Release","text":"<pre><code>curl -X POST \"https://updates.example.com/api/v1/updates/photo-editor/register\" \\\n  -H \"Authorization: Bearer ${RELEASE_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"application_id\": \"photo-editor\",\n    \"version\": \"2.0.0-beta.1\",\n    \"platform\": \"windows\",\n    \"architecture\": \"amd64\",\n    \"download_url\": \"https://cdn.example.com/photo-editor/2.0.0-beta.1/photo-editor-windows-amd64.exe\",\n    \"checksum\": \"c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\",\n    \"checksum_type\": \"sha256\",\n    \"file_size\": 53500000,\n    \"release_notes\": \"Beta: New collaboration features. Please report issues.\"\n  }'\n</code></pre>"},{"location":"use-cases/#example-stable-user-sees-no-update","title":"Example: Stable User Sees No Update","text":"<pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=1.5.0&amp;allow_prerelease=false\"\n</code></pre> <pre><code>{\n  \"update_available\": false,\n  \"current_version\": \"1.5.0\",\n  \"required\": false\n}\n</code></pre>"},{"location":"use-cases/#example-beta-user-receives-the-beta","title":"Example: Beta User Receives the Beta","text":"<pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=1.5.0&amp;allow_prerelease=true\"\n</code></pre> <pre><code>{\n  \"update_available\": true,\n  \"latest_version\": \"2.0.0-beta.1\",\n  \"current_version\": \"1.5.0\",\n  \"download_url\": \"https://cdn.example.com/photo-editor/2.0.0-beta.1/photo-editor-windows-amd64.exe\",\n  \"checksum\": \"c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4\",\n  \"checksum_type\": \"sha256\",\n  \"file_size\": 53500000,\n  \"release_notes\": \"Beta: New collaboration features. Please report issues.\",\n  \"release_date\": \"2026-02-14T10:00:00Z\",\n  \"required\": false\n}\n</code></pre>"},{"location":"use-cases/#key-points_2","title":"Key Points","text":"<ul> <li>The semver pre-release label is the gating mechanism. No separate channel configuration or data set is needed. The version string itself carries the channel semantics.</li> <li>No separate servers or data stores. Both stable and beta users query the same service instance and the same storage backend.</li> <li>When stable 2.0.0 ships, both populations converge automatically. Once 2.0.0 (without a pre-release label) is registered, it becomes the latest stable version for all users.</li> </ul>"},{"location":"use-cases/#automating-release-publishing-from-cicd","title":"Automating Release Publishing from CI/CD","text":""},{"location":"use-cases/#the-problem_3","title":"The Problem","text":"<p>After a successful build, someone must manually update a hosted metadata file or run a script to publish the new release. This manual step is error-prone, delays releases, and does not fit naturally into automated pipelines. The CI system needs a scoped credential that can register releases but cannot manage API keys or application configuration.</p>"},{"location":"use-cases/#how-the-updater-service-solves-it_3","title":"How the Updater Service Solves It","text":"<p>The write permission allows registering releases and listing them but does not grant administrative access. A dedicated API key scoped to write permission can be stored as a CI secret. A separate read-only key can be used by monitoring or dashboards to verify the release was published.</p> <pre><code>sequenceDiagram\n    participant CI as CI Pipeline\n    participant CDN as CDN / Artifact Store\n    participant Svc as Updater Service\n    participant Mon as Monitoring\n\n    CI-&gt;&gt;CDN: Upload binary artifact\n    CI-&gt;&gt;Svc: POST /api/v1/updates/photo-editor/register&lt;br/&gt;(write key)\n    Svc--&gt;&gt;CI: 201 Created\n    Mon-&gt;&gt;Svc: GET /api/v1/updates/photo-editor/releases&lt;br/&gt;(read key)\n    Svc--&gt;&gt;Mon: Release list including new version</code></pre>"},{"location":"use-cases/#example-security-configuration-with-scoped-keys","title":"Example: Security Configuration with Scoped Keys","text":"<pre><code>security:\n  enable_auth: true\n  api_keys:\n    - key: \"${CI_RELEASE_KEY}\"\n      name: \"CI Release Publisher\"\n      permissions: [\"read\", \"write\"]\n      enabled: true\n\n    - key: \"${MONITOR_KEY}\"\n      name: \"Release Monitor\"\n      permissions: [\"read\"]\n      enabled: true\n</code></pre>"},{"location":"use-cases/#example-ci-pipeline-registers-a-release","title":"Example: CI Pipeline Registers a Release","text":"<pre><code>curl -X POST \"https://updates.example.com/api/v1/updates/photo-editor/register\" \\\n  -H \"Authorization: Bearer ${CI_RELEASE_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"application_id\": \"photo-editor\",\n    \"version\": \"2.1.0\",\n    \"platform\": \"windows\",\n    \"architecture\": \"amd64\",\n    \"download_url\": \"https://cdn.example.com/photo-editor/2.1.0/photo-editor-windows-amd64.exe\",\n    \"checksum\": \"d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5\",\n    \"checksum_type\": \"sha256\",\n    \"file_size\": 54000000,\n    \"release_notes\": \"Performance improvements and bug fixes.\"\n  }'\n</code></pre>"},{"location":"use-cases/#example-monitoring-confirms-the-release","title":"Example: Monitoring Confirms the Release","text":"<pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/releases\" \\\n  -H \"Authorization: Bearer ${MONITOR_KEY}\"\n</code></pre> <pre><code>{\n  \"releases\": [\n    {\n      \"id\": \"rel_abc123\",\n      \"version\": \"2.1.0\",\n      \"platform\": \"windows\",\n      \"architecture\": \"amd64\",\n      \"download_url\": \"https://cdn.example.com/photo-editor/2.1.0/photo-editor-windows-amd64.exe\",\n      \"checksum\": \"d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5\",\n      \"checksum_type\": \"sha256\",\n      \"file_size\": 54000000,\n      \"release_notes\": \"Performance improvements and bug fixes.\",\n      \"release_date\": \"2026-02-15T08:00:00Z\",\n      \"required\": false\n    }\n  ],\n  \"total_count\": 1,\n  \"page\": 1,\n  \"page_size\": 50,\n  \"has_more\": false\n}\n</code></pre>"},{"location":"use-cases/#key-points_3","title":"Key Points","text":"<ul> <li>Write permission cannot manage keys or application configuration. The CI key can register and list releases but cannot modify security settings or create applications. This follows the principle of least privilege.</li> <li>Each platform/architecture combination is a separate register call. This fits naturally into CI matrix builds where each job publishes its own artifact.</li> <li>A read-only key enables monitoring and auditing. Dashboards and alerting systems can verify releases without write access.</li> </ul>"},{"location":"use-cases/#operating-a-shared-update-service-for-multiple-applications","title":"Operating a Shared Update Service for Multiple Applications","text":""},{"location":"use-cases/#the-problem_4","title":"The Problem","text":"<p>An organization maintains several desktop applications. Running separate update infrastructure per application (separate servers, separate configuration, separate monitoring) creates operational overhead that scales linearly with the number of applications.</p>"},{"location":"use-cases/#how-the-updater-service-solves-it_4","title":"How the Updater Service Solves It","text":"<p>The <code>app_id</code> path segment in every URL provides namespace isolation. A single service instance serves all applications. Scoped API keys restrict each team to managing only their own releases while an admin key handles cross-cutting operations.</p> <pre><code>graph TB\n    subgraph Operations\n        Admin[Ops Team&lt;br/&gt;admin key]\n    end\n\n    subgraph Updater Service\n        Svc[Single Instance&lt;br/&gt;/health endpoint]\n    end\n\n    subgraph App Teams\n        T1[Photo Editor Team&lt;br/&gt;write key: photo-editor]\n        T2[Video Editor Team&lt;br/&gt;write key: video-editor]\n        T3[Audio Editor Team&lt;br/&gt;write key: audio-editor]\n    end\n\n    subgraph Client Populations\n        C1[Photo Editor Users&lt;br/&gt;app_id: photo-editor]\n        C2[Video Editor Users&lt;br/&gt;app_id: video-editor]\n        C3[Audio Editor Users&lt;br/&gt;app_id: audio-editor]\n    end\n\n    Admin --&gt; Svc\n    T1 --&gt; Svc\n    T2 --&gt; Svc\n    T3 --&gt; Svc\n    C1 --&gt; Svc\n    C2 --&gt; Svc\n    C3 --&gt; Svc</code></pre>"},{"location":"use-cases/#example-security-configuration-with-per-team-keys","title":"Example: Security Configuration with Per-Team Keys","text":"<pre><code>security:\n  enable_auth: true\n  api_keys:\n    - key: \"${OPS_ADMIN_KEY}\"\n      name: \"Operations Admin\"\n      permissions: [\"admin\"]\n      enabled: true\n\n    - key: \"${PHOTO_EDITOR_KEY}\"\n      name: \"Photo Editor CI\"\n      permissions: [\"read\", \"write\"]\n      enabled: true\n\n    - key: \"${VIDEO_EDITOR_KEY}\"\n      name: \"Video Editor CI\"\n      permissions: [\"read\", \"write\"]\n      enabled: true\n\n    - key: \"${AUDIO_EDITOR_KEY}\"\n      name: \"Audio Editor CI\"\n      permissions: [\"read\", \"write\"]\n      enabled: true\n</code></pre>"},{"location":"use-cases/#example-each-application-has-its-own-namespace","title":"Example: Each Application Has Its Own Namespace","text":"Photo EditorVideo EditorAudio Editor <pre><code>curl \"https://updates.example.com/api/v1/updates/photo-editor/check\\\n?platform=windows&amp;architecture=amd64&amp;current_version=2.0.0\"\n</code></pre> <pre><code>curl \"https://updates.example.com/api/v1/updates/video-editor/check\\\n?platform=darwin&amp;architecture=arm64&amp;current_version=3.1.0\"\n</code></pre> <pre><code>curl \"https://updates.example.com/api/v1/updates/audio-editor/check\\\n?platform=linux&amp;architecture=amd64&amp;current_version=1.0.0\"\n</code></pre>"},{"location":"use-cases/#example-postgresql-storage-for-production-scale","title":"Example: PostgreSQL Storage for Production Scale","text":"<pre><code>storage:\n  provider: \"postgres\"\n  postgres:\n    connection_string: \"${DATABASE_URL}\"\n    max_open_conns: 25\n    max_idle_conns: 5\n    conn_max_lifetime: \"5m\"\n</code></pre>"},{"location":"use-cases/#key-points_4","title":"Key Points","text":"<ul> <li><code>app_id</code> in the URL path provides namespace isolation. Each application's releases are independent. A single service instance serves any number of applications without configuration changes per application.</li> <li>Scoped write keys restrict teams to their own releases. Each team receives a key with write permission. The admin key is reserved for the operations team for cross-cutting management.</li> <li>PostgreSQL is recommended for multi-app production deployments. It provides concurrent access, connection pooling, and scales well with multiple applications and high query volumes.</li> <li>A single <code>/health</code> endpoint covers the entire service. Operations teams monitor one health check per deployment rather than one per application.</li> </ul>"},{"location":"use-cases/#summary","title":"Summary","text":"Scenario Key Feature Recommended Storage Auth Required Cross-platform desktop app Platform/arch routing JSON or SQLite No (check endpoint is public) Critical security patch <code>required</code> flag Any Write (to register the release) Pre-release channels Semver pre-release filtering Any Write (to register the release) CI/CD integration Scoped write API key SQLite or PostgreSQL Write (to register the release) Multi-app shared service <code>app_id</code> namespacing PostgreSQL Admin + scoped write"},{"location":"db/","title":"updater","text":""},{"location":"db/#tables","title":"Tables","text":"Name Columns Comment Type public.applications 7 BASE TABLE public.releases 15 BASE TABLE public.api_keys 8 BASE TABLE"},{"location":"db/#stored-procedures-and-functions","title":"Stored procedures and functions","text":"Name ReturnType Arguments Type public.update_updated_at_column trigger FUNCTION"},{"location":"db/#relations","title":"Relations","text":"<p>Generated by tbls</p>"},{"location":"db/public.api_keys/","title":"public.api_keys","text":""},{"location":"db/public.api_keys/#description","title":"Description","text":""},{"location":"db/public.api_keys/#columns","title":"Columns","text":"Name Type Default Nullable Children Parents Comment id text false name text false key_hash text false prefix text false permissions jsonb '[]'::jsonb false enabled boolean true false created_at timestamp with time zone now() false updated_at timestamp with time zone now() false"},{"location":"db/public.api_keys/#constraints","title":"Constraints","text":"Name Type Definition api_keys_pkey PRIMARY KEY PRIMARY KEY (id) api_keys_key_hash_key UNIQUE UNIQUE (key_hash)"},{"location":"db/public.api_keys/#indexes","title":"Indexes","text":"Name Definition api_keys_pkey CREATE UNIQUE INDEX api_keys_pkey ON public.api_keys USING btree (id) api_keys_key_hash_key CREATE UNIQUE INDEX api_keys_key_hash_key ON public.api_keys USING btree (key_hash) idx_api_keys_hash CREATE INDEX idx_api_keys_hash ON public.api_keys USING btree (key_hash)"},{"location":"db/public.api_keys/#triggers","title":"Triggers","text":"Name Definition update_api_keys_updated_at CREATE TRIGGER update_api_keys_updated_at BEFORE UPDATE ON public.api_keys FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"},{"location":"db/public.api_keys/#relations","title":"Relations","text":"<p>Generated by tbls</p>"},{"location":"db/public.applications/","title":"public.applications","text":""},{"location":"db/public.applications/#description","title":"Description","text":""},{"location":"db/public.applications/#columns","title":"Columns","text":"Name Type Default Nullable Children Parents Comment id text false public.releases name text false description text true platforms jsonb '[]'::jsonb false config jsonb '{}'::jsonb false created_at timestamp with time zone now() false updated_at timestamp with time zone now() false"},{"location":"db/public.applications/#constraints","title":"Constraints","text":"Name Type Definition applications_pkey PRIMARY KEY PRIMARY KEY (id)"},{"location":"db/public.applications/#indexes","title":"Indexes","text":"Name Definition applications_pkey CREATE UNIQUE INDEX applications_pkey ON public.applications USING btree (id) idx_applications_name CREATE INDEX idx_applications_name ON public.applications USING btree (name) idx_applications_platforms CREATE INDEX idx_applications_platforms ON public.applications USING gin (platforms)"},{"location":"db/public.applications/#triggers","title":"Triggers","text":"Name Definition update_applications_updated_at CREATE TRIGGER update_applications_updated_at BEFORE UPDATE ON public.applications FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"},{"location":"db/public.applications/#relations","title":"Relations","text":"<p>Generated by tbls</p>"},{"location":"db/public.releases/","title":"public.releases","text":""},{"location":"db/public.releases/#description","title":"Description","text":""},{"location":"db/public.releases/#columns","title":"Columns","text":"Name Type Default Nullable Children Parents Comment id text false application_id text false public.applications version text false platform text false architecture text false download_url text false checksum text false checksum_type text 'sha256'::text false file_size bigint false release_notes text true release_date timestamp with time zone false required boolean false false minimum_version text true metadata jsonb '{}'::jsonb true created_at timestamp with time zone now() false"},{"location":"db/public.releases/#constraints","title":"Constraints","text":"Name Type Definition releases_application_id_fkey FOREIGN KEY FOREIGN KEY (application_id) REFERENCES applications(id) ON DELETE RESTRICT releases_pkey PRIMARY KEY PRIMARY KEY (id) releases_application_id_version_platform_architecture_key UNIQUE UNIQUE (application_id, version, platform, architecture)"},{"location":"db/public.releases/#indexes","title":"Indexes","text":"Name Definition releases_pkey CREATE UNIQUE INDEX releases_pkey ON public.releases USING btree (id) releases_application_id_version_platform_architecture_key CREATE UNIQUE INDEX releases_application_id_version_platform_architecture_key ON public.releases USING btree (application_id, version, platform, architecture) idx_releases_app_platform_arch CREATE INDEX idx_releases_app_platform_arch ON public.releases USING btree (application_id, platform, architecture) idx_releases_version CREATE INDEX idx_releases_version ON public.releases USING btree (version) idx_releases_date CREATE INDEX idx_releases_date ON public.releases USING btree (release_date DESC) idx_releases_required CREATE INDEX idx_releases_required ON public.releases USING btree (required) idx_releases_required_date CREATE INDEX idx_releases_required_date ON public.releases USING btree (required, release_date DESC) idx_releases_metadata_gin CREATE INDEX idx_releases_metadata_gin ON public.releases USING gin (metadata) idx_releases_app_version CREATE INDEX idx_releases_app_version ON public.releases USING btree (application_id, version)"},{"location":"db/public.releases/#relations","title":"Relations","text":"<p>Generated by tbls</p>"},{"location":"models/","title":"Models Documentation Index","text":"<p>The updater service models provide a comprehensive type system for managing software updates, version control, and service configuration. This documentation is organized into focused components for easy navigation and understanding.</p>"},{"location":"models/#model-reference","title":"Model Reference","text":"<p>The complete type reference for <code>internal/models</code> is auto-generated from Go doc comments and always reflects the current code:</p> <p>Model Reference (auto-generated)</p> <p>Key types:</p> Type Description <code>Application</code> Application metadata, platform support, configuration <code>ApplicationConfig</code> Per-application update policy settings <code>Release</code> Release metadata, checksum validation, filtering <code>ReleaseFilter</code> Criteria for filtering release queries <code>APIKey</code> Storage-backed API key with permission checking <code>Config</code> Root service configuration with all sub-configs <code>SecurityConfig</code> Auth settings: bootstrap key, rate limiting, trusted proxies <code>RateLimitConfig</code> Two-tier token-bucket rate limiting (anonymous + authenticated) Request types <code>CheckUpdateRequest</code>, <code>RegisterReleaseRequest</code>, <code>CreateApplicationRequest</code>, etc. Response types <code>UpdateCheckResponse</code>, <code>LatestVersionResponse</code>, <code>HealthResponse</code>, etc."},{"location":"models/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"models/#for-api-integration","title":"For API Integration","text":"<ol> <li>Start with the Model Reference for request/response contracts</li> <li>Review the <code>UpdateCheckRequest</code>, <code>RegisterReleaseRequest</code> types</li> <li>Check platform and architecture constants in the reference</li> </ol>"},{"location":"models/#for-service-deployment","title":"For Service Deployment","text":"<ol> <li>Read the <code>Config</code>, <code>SecurityConfig</code>, and <code>RateLimitConfig</code> sections in the reference</li> <li>See Security for the API key management workflow</li> </ol>"},{"location":"models/#for-client-development","title":"For Client Development","text":"<ol> <li>Study request/response types in the Model Reference</li> <li>Use the <code>Version</code> semver comparison helpers for local update checks</li> </ol>"},{"location":"models/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"API Layer (COMPLETE)\"\n        api[HTTP Handlers &amp; Routing]\n    end\n\n    subgraph \"Business Logic (COMPLETE)\"\n        logic[Update Determination &amp; Version Comparison]\n    end\n\n    subgraph \"Models Layer (COMPLETE)\"\n        subgraph \"Core Models\"\n            version[Version Models]\n            platform[Platform Models]\n            release[Release Models]\n            apimodels[API Models]\n        end\n        config[Configuration Models]\n    end\n\n    subgraph \"Storage Layer (COMPLETE)\"\n        storage[Data Persistence &amp; Retrieval]\n    end\n\n    api --&gt; logic\n    logic --&gt; version\n    logic --&gt; platform\n    logic --&gt; release\n    logic --&gt; apimodels\n    logic --&gt; config\n    version --&gt; storage\n    platform --&gt; storage\n    release --&gt; storage\n    config --&gt; storage\n\n    classDef complete fill:#4caf50,stroke:#2e7d32,color:#fff\n\n    class version,platform,release,apimodels,config complete\n    class api,logic,storage complete</code></pre>"},{"location":"models/#design-principles","title":"Design Principles","text":""},{"location":"models/#security-first","title":"Security First","text":"<ul> <li>Strong cryptographic validation (SHA256 checksums)</li> <li>Comprehensive input validation and sanitization</li> <li>Safe defaults with security-conscious configuration</li> <li>Privacy-first approach (analytics disabled by default)</li> </ul>"},{"location":"models/#developer-experience","title":"Developer Experience","text":"<ul> <li>Clear error messages with actionable feedback</li> <li>Consistent naming following Go conventions</li> <li>Comprehensive examples and usage patterns</li> <li>Type safety to prevent runtime errors</li> </ul>"},{"location":"models/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Memory-efficient struct design and field ordering</li> <li>Caching-friendly response structures</li> <li>Pagination support for large datasets</li> <li>Minimal external dependencies</li> </ul>"},{"location":"models/#extensibility","title":"Extensibility","text":"<ul> <li>Forward-compatible API design</li> <li>Extensible metadata systems</li> <li>Plugin-like configuration architecture</li> <li>Support for future enhancements</li> </ul>"},{"location":"models/#implementation-status","title":"Implementation Status","text":"Component Status Documentation Tests Notes Version Models Complete Auto-generated Complete Semantic versioning support Platform Models Complete Auto-generated Complete Multi-platform support Release Models Complete Auto-generated Complete Security &amp; integrity API Models Complete Auto-generated Complete Request/response contracts Config Models Complete Auto-generated Complete Service configuration API Key Models Complete Auto-generated Complete Storage-backed key management"},{"location":"models/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - Complete system design and API specification</li> <li>Storage Providers - Storage backend implementations and configuration</li> <li>Security - Security architecture and threat mitigation</li> <li>Observability - Metrics, tracing, and monitoring</li> <li>Logging - Structured logging configuration</li> </ul>"},{"location":"models/#development-workflow","title":"Development Workflow","text":""},{"location":"models/#adding-new-models","title":"Adding New Models","text":"<ol> <li>Implement the Go struct in appropriate <code>internal/models/*.go</code> file</li> <li>Add exported Go doc comments on the type and each exported field</li> <li>Include validation methods and business logic</li> <li>Update this <code>index.md</code> overview table with the new type</li> <li>Run <code>make docs-generate</code> to regenerate <code>docs/models/auto/models.md</code></li> <li>Write unit tests</li> </ol>"},{"location":"models/#modifying-existing-models","title":"Modifying Existing Models","text":"<ol> <li>Ensure backward compatibility for API changes</li> <li>Update Go doc comments to reflect the change</li> <li>Run <code>make docs-generate</code> to regenerate the reference</li> </ol>"},{"location":"models/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Write Go doc comments in the source files \u2014 the reference is auto-generated from them</li> <li>Include design rationale in the Overview section of this file, not in Go doc comments</li> <li>Document security considerations in Security</li> </ul> <p>Tip: Each documentation file is self-contained but cross-references related components. Start with the component most relevant to your use case, then explore related areas as needed.</p>"},{"location":"models/auto/models/","title":"Reference","text":""},{"location":"models/auto/models/#models","title":"models","text":"<pre><code>import \"updater/internal/models\"\n</code></pre> <p>Package models - Application and platform management. This file defines application metadata, platform support, and configuration structures.</p> <p>Design Decisions: - Platform-agnostic design supporting multiple operating systems and architectures - Flexible configuration system allowing per-application customization - Strong validation to ensure data integrity and security - Normalized platform/architecture identifiers for consistency</p> <p>Package models - Service configuration and operational settings. This file defines comprehensive configuration structures for all service components.</p> <p>Configuration Philosophy: - Hierarchical configuration with logical grouping (server, storage, security, etc.) - Environment-friendly defaults that work out of the box - Comprehensive validation to catch misconfigurations early - Support for multiple deployment scenarios (development, production, cloud) - Security-first approach with safe defaults - Extensible design for future enhancements</p> <p>Package models - Release management and integrity verification. This file handles software release metadata, checksum validation, and release filtering.</p> <p>Security Design Principles: - Strong cryptographic checksums (SHA256 preferred) for integrity verification - URL validation to prevent malicious download links - Comprehensive input validation for all release metadata - Support for multiple checksum algorithms for backward compatibility - Immutable release identification for audit trails</p> <p>Package models - API request types and input validation. This file defines all incoming API request structures with comprehensive validation.</p> <p>Validation Philosophy: - Fail fast with clear error messages for invalid input - Normalize input data for consistent processing (lowercase platforms, trimmed strings) - Validate business rules (version formats, platform support, constraints) - Provide sensible defaults where appropriate - Separate validation from normalization for clear error reporting</p> <p>Package models - API response types and error handling. This file defines all outgoing API response structures with consistent formatting.</p> <p>Response Design Principles: - Consistent JSON structure across all endpoints - Optional fields use omitempty to reduce response size - Rich error information with codes and details for debugging - Standardized pagination with metadata - Helper methods for easy response construction - RFC3339 timestamps for international compatibility</p>"},{"location":"models/auto/models/#index","title":"Index","text":"<ul> <li>Constants</li> <li>Variables</li> <li>func GenerateAPIKey() (string, error)</li> <li>func HashAPIKey(rawKey string) string</li> <li>func NewKeyID() string</li> <li>func NormalizeArchitecture(arch string) string</li> <li>func NormalizePlatform(platform string) string</li> <li>type APIKey</li> <li>func NewAPIKey(id, name, rawKey string, permissions []string) *APIKey</li> <li>func (ak *APIKey) HasPermission(required string) bool</li> <li>type ActivityItem</li> <li>type Application</li> <li>func NewApplication(id, name string, platforms []string) *Application</li> <li>func (a *Application) SupportsArchitecture(platform, arch string) bool</li> <li>func (a *Application) SupportsPlatform(platform string) bool</li> <li>func (a *Application) Validate() error</li> <li>type ApplicationConfig</li> <li>func (ac *ApplicationConfig) Validate() error</li> <li>type ApplicationInfoResponse</li> <li>type ApplicationStats</li> <li>type ApplicationSummary</li> <li>func (as *ApplicationSummary) FromApplication(app *Application)</li> <li>type CacheConfig</li> <li>func (cc *CacheConfig) Validate() error</li> <li>type ComponentHealth</li> <li>type Config</li> <li>func NewDefaultConfig() *Config</li> <li>func (c *Config) Validate() error</li> <li>type CreateApplicationRequest</li> <li>func (r *CreateApplicationRequest) Normalize()</li> <li>func (r *CreateApplicationRequest) Validate() error</li> <li>type CreateApplicationResponse</li> <li>type DatabaseConfig</li> <li>type DeleteReleaseRequest</li> <li>type DeleteReleaseResponse</li> <li>type ErrorResponse</li> <li>func NewErrorResponse(message string, code string) *ErrorResponse</li> <li>type HealthCheckRequest</li> <li>type HealthCheckResponse</li> <li>func NewHealthCheckResponse(status string) *HealthCheckResponse</li> <li>func (h *HealthCheckResponse) AddComponent(name, status, message string)</li> <li>func (h *HealthCheckResponse) AddMetric(name string, value interface{})</li> <li>type LatestVersionRequest</li> <li>func (r *LatestVersionRequest) Normalize()</li> <li>func (r *LatestVersionRequest) Validate() error</li> <li>type LatestVersionResponse</li> <li>func (r *LatestVersionResponse) FromRelease(release *Release)</li> <li>type ListApplicationsResponse</li> <li>type ListReleasesRequest</li> <li>func (r *ListReleasesRequest) Normalize()</li> <li>func (r *ListReleasesRequest) Validate() error</li> <li>type ListReleasesResponse</li> <li>type LoggingConfig</li> <li>func (lc *LoggingConfig) Validate() error</li> <li>type MemoryConfig</li> <li>type MetricsConfig</li> <li>func (mc *MetricsConfig) Validate() error</li> <li>type ObservabilityConfig</li> <li>func (oc *ObservabilityConfig) Validate() error</li> <li>type PlatformInfo</li> <li>func (pi *PlatformInfo) String() string</li> <li>func (pi *PlatformInfo) Validate() error</li> <li>type RedisConfig</li> <li>type RegisterReleaseRequest</li> <li>func (r *RegisterReleaseRequest) Normalize()</li> <li>func (r *RegisterReleaseRequest) Validate() error</li> <li>type RegisterReleaseResponse</li> <li>type Release</li> <li>func NewRelease(appID, version, platform, arch, downloadURL string) *Release</li> <li>func (r *Release) GenerateChecksum(data []byte) string</li> <li>func (r *Release) GetMetadata(key string) (string, bool)</li> <li>func (r *Release) GetPlatformInfo() PlatformInfo</li> <li>func (r *Release) IsCompatibleWith(platform, arch string) bool</li> <li>func (r *Release) IsNewerThan(other *Release) (bool, error)</li> <li>func (r *Release) MeetsMinimumVersion(currentVersion string) (bool, error)</li> <li>func (r *Release) SetMetadata(key, value string)</li> <li>func (r *Release) Validate() error</li> <li>func (r *Release) ValidateDownloadURL() error</li> <li>func (r *Release) VerifyChecksum(data []byte) bool</li> <li>type ReleaseFilter</li> <li>func (rf *ReleaseFilter) Validate() error</li> <li>type ReleaseInfo</li> <li>func (ri *ReleaseInfo) FromRelease(release *Release)</li> <li>type ReleaseMetadata</li> <li>type ReleaseStats</li> <li>type SecurityConfig</li> <li>func (sec *SecurityConfig) Validate() error</li> <li>type ServerConfig</li> <li>func (sc *ServerConfig) Validate() error</li> <li>type StatsResponse</li> <li>type StorageConfig</li> <li>func (stc *StorageConfig) Validate() error</li> <li>type TracingConfig</li> <li>type UpdateApplicationRequest</li> <li>func (r *UpdateApplicationRequest) Normalize()</li> <li>func (r *UpdateApplicationRequest) Validate() error</li> <li>type UpdateApplicationResponse</li> <li>type UpdateCheckRequest</li> <li>func (r *UpdateCheckRequest) Normalize()</li> <li>func (r *UpdateCheckRequest) Validate() error</li> <li>type UpdateCheckResponse</li> <li>func (r *UpdateCheckResponse) SetNoUpdateAvailable(currentVersion string)</li> <li>func (r *UpdateCheckResponse) SetUpdateAvailable(release *Release)</li> <li>type ValidationErrorResponse</li> <li>func NewValidationErrorResponse(errors map[string]string) *ValidationErrorResponse</li> </ul>"},{"location":"models/auto/models/#constants","title":"Constants","text":"<p>Platform and Architecture Constants</p> <p>Design Rationale: - Uses Go's GOOS naming convention for consistency with build system - Covers major desktop and mobile platforms for broad compatibility - Architecture names follow Go's GOARCH convention - Lowercase naming ensures consistent URL and file naming</p> <pre><code>const (\n    // Supported Operating Systems\n    PlatformWindows = \"windows\" // Microsoft Windows\n    PlatformLinux   = \"linux\"   // Linux distributions\n    PlatformDarwin  = \"darwin\"  // macOS (Apple's Darwin kernel)\n    PlatformAndroid = \"android\" // Android mobile OS\n    PlatformIOS     = \"ios\"     // Apple iOS\n\n    // Supported CPU Architectures\n    ArchAMD64 = \"amd64\" // 64-bit x86 (Intel/AMD)\n    ArchARM64 = \"arm64\" // 64-bit ARM (Apple Silicon, ARM servers)\n    Arch386   = \"386\"   // 32-bit x86 (legacy support)\n    ArchARM   = \"arm\"   // 32-bit ARM (Raspberry Pi, older mobile)\n)\n</code></pre> <p>Storage type constants</p> <pre><code>const (\n    StorageTypeJSON     = \"json\"\n    StorageTypeMemory   = \"memory\"\n    StorageTypePostgres = \"postgres\"\n    StorageTypeSQLite   = \"sqlite\"\n)\n</code></pre> <p>Checksum Algorithm Constants</p> <p>Security Considerations: - SHA256 is preferred for strong cryptographic integrity - MD5 and SHA1 are supported for legacy compatibility but discouraged - Future algorithms can be added without breaking existing releases</p> <pre><code>const (\n    ChecksumTypeSHA256 = \"sha256\" // Recommended: Strong cryptographic hash\n    ChecksumTypeMD5    = \"md5\"    // Legacy: Weak, use only for compatibility\n    ChecksumTypeSHA1   = \"sha1\"   // Legacy: Weak, use only for compatibility\n)\n</code></pre> <p>Health Status Constants</p> <p>Health Monitoring: - Healthy: All systems operational - Degraded: Partial functionality (some features may be slow/limited) - Unhealthy: Major issues affecting core functionality - Unknown: Health status cannot be determined</p> <pre><code>const (\n    StatusHealthy   = \"healthy\"   // All systems operational\n    StatusUnhealthy = \"unhealthy\" // Major system issues\n    StatusDegraded  = \"degraded\"  // Partial functionality\n    StatusUnknown   = \"unknown\"   // Status indeterminate\n)\n</code></pre> <p>Standard HTTP Error Codes</p> <p>Error Code Strategy: - Upper-case with underscores for consistency - Maps to standard HTTP status codes - Machine-readable for client error handling - Extensible for service-specific errors</p> <pre><code>const (\n    ErrorCodeNotFound            = \"NOT_FOUND\"             // 404: Resource doesn't exist\n    ErrorCodeApplicationNotFound = \"APPLICATION_NOT_FOUND\" // 404: Application doesn't exist\n    ErrorCodeBadRequest          = \"BAD_REQUEST\"           // 400: Invalid request format\n    ErrorCodeInvalidRequest      = \"INVALID_REQUEST\"       // 400: Invalid request data\n    ErrorCodeValidation          = \"VALIDATION_ERROR\"      // 422: Input validation failed\n    ErrorCodeInternalError       = \"INTERNAL_ERROR\"        // 500: Server-side error\n    ErrorCodeUnauthorized        = \"UNAUTHORIZED\"          // 401: Authentication required\n    ErrorCodeForbidden           = \"FORBIDDEN\"             // 403: Permission denied\n    ErrorCodeConflict            = \"CONFLICT\"              // 409: Resource conflict\n    ErrorCodeServiceUnavailable  = \"SERVICE_UNAVAILABLE\"   // 503: Service temporarily down\n)\n</code></pre>"},{"location":"models/auto/models/#variables","title":"Variables","text":"<pre><code>var (\n    SupportedPlatforms = []string{\n        PlatformWindows,\n        PlatformLinux,\n        PlatformDarwin,\n        PlatformAndroid,\n        PlatformIOS,\n    }\n\n    SupportedArchitectures = []string{\n        ArchAMD64,\n        ArchARM64,\n        Arch386,\n        ArchARM,\n    }\n)\n</code></pre> <pre><code>var SupportedChecksumTypes = []string{\n    ChecksumTypeSHA256,\n    ChecksumTypeMD5,\n    ChecksumTypeSHA1,\n}\n</code></pre>"},{"location":"models/auto/models/#func-generateapikey","title":"func GenerateAPIKey","text":"<pre><code>func GenerateAPIKey() (string, error)\n</code></pre> <p>GenerateAPIKey produces a new random API key in the format upd_\\&lt;44 url-safe base64 chars&gt;.</p> <p></p>"},{"location":"models/auto/models/#func-hashapikey","title":"func HashAPIKey","text":"<pre><code>func HashAPIKey(rawKey string) string\n</code></pre> <p>HashAPIKey computes the SHA-256 hex digest of a raw API key.</p> <p></p>"},{"location":"models/auto/models/#func-newkeyid","title":"func NewKeyID","text":"<pre><code>func NewKeyID() string\n</code></pre> <p>NewKeyID generates a new UUID v4 for use as an APIKey ID.</p> <p></p>"},{"location":"models/auto/models/#func-normalizearchitecture","title":"func NormalizeArchitecture","text":"<pre><code>func NormalizeArchitecture(arch string) string\n</code></pre>"},{"location":"models/auto/models/#func-normalizeplatform","title":"func NormalizePlatform","text":"<pre><code>func NormalizePlatform(platform string) string\n</code></pre>"},{"location":"models/auto/models/#type-apikey","title":"type APIKey","text":"<p>APIKey represents a stored API key.</p> <p>The raw key value is never persisted; only the SHA-256 hex digest (KeyHash) and an 8-character display prefix (Prefix) are stored. The raw key is returned exactly once \u2014 at creation time \u2014 and cannot be recovered afterwards.</p> <p>Keys are generated by GenerateAPIKey and follow the format upd_\\&lt;44 base64url chars&gt;. Auth middleware resolves incoming Bearer tokens via GetAPIKeyByHash.</p> <pre><code>type APIKey struct {\n    // ID is a UUID v4 that uniquely identifies the key.\n    ID  string `json:\"id\"`\n    // Name is a human-readable label for the key (e.g. \"CI Publisher\").\n    Name string `json:\"name\"`\n    // KeyHash is the SHA-256 hex digest of the raw key. Used for authentication lookups.\n    KeyHash string `json:\"key_hash\"`\n    // Prefix is the first 8 characters of the raw key, shown in the admin UI for identification.\n    Prefix string `json:\"prefix\"`\n    // Permissions lists the permission levels granted to this key (\"read\", \"write\", \"admin\", or \"*\").\n    Permissions []string `json:\"permissions\"`\n    // Enabled controls whether the key is accepted. Disabled keys are rejected at auth time.\n    Enabled   bool      `json:\"enabled\"`\n    CreatedAt time.Time `json:\"created_at\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-newapikey","title":"func NewAPIKey","text":"<pre><code>func NewAPIKey(id, name, rawKey string, permissions []string) *APIKey\n</code></pre> <p>NewAPIKey creates a new APIKey from a raw key string.</p> <p></p>"},{"location":"models/auto/models/#func-apikey-haspermission","title":"func (*APIKey) HasPermission","text":"<pre><code>func (ak *APIKey) HasPermission(required string) bool\n</code></pre> <p>HasPermission returns true when the key is enabled and possesses the required permission.</p> <p></p>"},{"location":"models/auto/models/#type-activityitem","title":"type ActivityItem","text":"<pre><code>type ActivityItem struct {\n    Type        string            `json:\"type\"`\n    Description string            `json:\"description\"`\n    Timestamp   time.Time         `json:\"timestamp\"`\n    Metadata    map[string]string `json:\"metadata,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-application","title":"type Application","text":"<p>Application represents a software application that can receive updates.</p> <p>Design Principles: - ID serves as unique identifier and is used in API URLs (must be URL-safe) - Platforms array supports multi-platform applications - Configuration is embedded for easy access and serialization - Timestamps as strings for flexibility with different storage backends - Validation tags provide input validation constraints</p> <pre><code>type Application struct {\n    ID          string            `json:\"id\" validate:\"required\"`              // Unique application identifier (URL-safe)\n    Name        string            `json:\"name\" validate:\"required\"`            // Human-readable application name\n    Description string            `json:\"description\"`                         // Optional application description\n    Platforms   []string          `json:\"platforms\" validate:\"required,min=1\"` // Supported platforms (windows, linux, etc.)\n    Config      ApplicationConfig `json:\"config\"`                              // Application-specific configuration\n    CreatedAt   string            `json:\"created_at,omitempty\"`                // Creation timestamp (RFC3339 format)\n    UpdatedAt   string            `json:\"updated_at,omitempty\"`                // Last modification timestamp\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-newapplication","title":"func NewApplication","text":"<pre><code>func NewApplication(id, name string, platforms []string) *Application\n</code></pre> <p>NewApplication creates a new Application with sensible defaults.</p> <p>Default Configuration: - Auto-update disabled for safety - 1-hour update check interval - No required updates (user choice) - Pre-release versions disabled - Analytics disabled (privacy first) - Empty custom fields map initialized</p> <p></p>"},{"location":"models/auto/models/#func-application-supportsarchitecture","title":"func (*Application) SupportsArchitecture","text":"<pre><code>func (a *Application) SupportsArchitecture(platform, arch string) bool\n</code></pre>"},{"location":"models/auto/models/#func-application-supportsplatform","title":"func (*Application) SupportsPlatform","text":"<pre><code>func (a *Application) SupportsPlatform(platform string) bool\n</code></pre>"},{"location":"models/auto/models/#func-application-validate","title":"func (*Application) Validate","text":"<pre><code>func (a *Application) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-applicationconfig","title":"type ApplicationConfig","text":"<p>ApplicationConfig contains application-specific settings for update behavior.</p> <p>Design Considerations: - Flexible update policies (auto-update, intervals, required updates) - Version constraints for compatibility management - Webhook support for integration with external systems - Privacy-conscious analytics (disabled by default) - Extensible via CustomFields for application-specific metadata</p> <pre><code>type ApplicationConfig struct {\n    UpdateCheckURL   string            `json:\"update_check_url,omitempty\"` // Custom update check endpoint override\n    AutoUpdate       bool              `json:\"auto_update\"`                // Enable automatic updates\n    UpdateInterval   int               `json:\"update_interval\"`            // Update check interval in seconds\n    RequiredUpdate   bool              `json:\"required_update\"`            // Force updates (security patches)\n    MinVersion       string            `json:\"min_version,omitempty\"`      // Minimum supported version\n    MaxVersion       string            `json:\"max_version,omitempty\"`      // Maximum supported version\n    AllowPrerelease  bool              `json:\"allow_prerelease\"`           // Include pre-release versions\n    CustomFields     map[string]string `json:\"custom_fields,omitempty\"`    // Application-specific metadata\n    NotificationURL  string            `json:\"notification_url,omitempty\"` // Webhook for update notifications\n    AnalyticsEnabled bool              `json:\"analytics_enabled\"`          // Privacy-conscious usage analytics\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-applicationconfig-validate","title":"func (*ApplicationConfig) Validate","text":"<pre><code>func (ac *ApplicationConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-applicationinforesponse","title":"type ApplicationInfoResponse","text":"<pre><code>type ApplicationInfoResponse struct {\n    ID          string            `json:\"id\"`\n    Name        string            `json:\"name\"`\n    Description string            `json:\"description\"`\n    Platforms   []string          `json:\"platforms\"`\n    Config      ApplicationConfig `json:\"config\"`\n    Stats       ApplicationStats  `json:\"stats\"`\n    CreatedAt   time.Time         `json:\"created_at\"`\n    UpdatedAt   time.Time         `json:\"updated_at\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-applicationstats","title":"type ApplicationStats","text":"<pre><code>type ApplicationStats struct {\n    TotalReleases     int        `json:\"total_releases\"`\n    LatestVersion     string     `json:\"latest_version,omitempty\"`\n    LatestReleaseDate *time.Time `json:\"latest_release_date,omitempty\"`\n    PlatformCount     int        `json:\"platform_count\"`\n    RequiredReleases  int        `json:\"required_releases\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-applicationsummary","title":"type ApplicationSummary","text":"<pre><code>type ApplicationSummary struct {\n    ID          string    `json:\"id\"`\n    Name        string    `json:\"name\"`\n    Description string    `json:\"description\"`\n    Platforms   []string  `json:\"platforms\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n    UpdatedAt   time.Time `json:\"updated_at\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-applicationsummary-fromapplication","title":"func (*ApplicationSummary) FromApplication","text":"<pre><code>func (as *ApplicationSummary) FromApplication(app *Application)\n</code></pre>"},{"location":"models/auto/models/#type-cacheconfig","title":"type CacheConfig","text":"<pre><code>type CacheConfig struct {\n    Enabled bool          `yaml:\"enabled\" json:\"enabled\"`\n    Type    string        `yaml:\"type\" json:\"type\"`\n    TTL     time.Duration `yaml:\"ttl\" json:\"ttl\"`\n    Redis   RedisConfig   `yaml:\"redis\" json:\"redis\"`\n    Memory  MemoryConfig  `yaml:\"memory\" json:\"memory\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-cacheconfig-validate","title":"func (*CacheConfig) Validate","text":"<pre><code>func (cc *CacheConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-componenthealth","title":"type ComponentHealth","text":"<pre><code>type ComponentHealth struct {\n    Status    string                 `json:\"status\"`\n    Message   string                 `json:\"message,omitempty\"`\n    Details   map[string]interface{} `json:\"details,omitempty\"`\n    Timestamp time.Time              `json:\"timestamp\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-config","title":"type Config","text":"<p>Config is the root configuration structure containing all service settings.</p> <p>Configuration Structure: - Server: HTTP server and network settings - Storage: Database and file storage configuration - Security: Authentication and authorization - Logging: Structured logging and output configuration - Cache: Performance caching settings - Metrics: Monitoring and observability</p> <p>Design Benefits: - Single source of truth for all configuration - Clear separation of concerns by component - Easy to serialize/deserialize from YAML/JSON - Comprehensive validation across all components</p> <pre><code>type Config struct {\n    Server        ServerConfig        `yaml:\"server\" json:\"server\"`               // HTTP server configuration\n    Storage       StorageConfig       `yaml:\"storage\" json:\"storage\"`             // Data persistence settings\n    Security      SecurityConfig      `yaml:\"security\" json:\"security\"`           // Authentication and authorization\n    Logging       LoggingConfig       `yaml:\"logging\" json:\"logging\"`             // Logging and output configuration\n    Cache         CacheConfig         `yaml:\"cache\" json:\"cache\"`                 // Performance caching\n    Metrics       MetricsConfig       `yaml:\"metrics\" json:\"metrics\"`             // Monitoring and metrics\n    Observability ObservabilityConfig `yaml:\"observability\" json:\"observability\"` // OpenTelemetry observability\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-newdefaultconfig","title":"func NewDefaultConfig","text":"<pre><code>func NewDefaultConfig() *Config\n</code></pre> <p>NewDefaultConfig creates a configuration with production-ready defaults.</p> <p>Default Configuration Principles: - Security-first: Authentication disabled but ready, HTTPS preferred - Performance: Reasonable timeouts and connection limits - Reliability: Conservative rate limits, structured logging - Observability: Metrics enabled by default for monitoring - Development-friendly: JSON file storage, permissive CORS for testing - Production-ready: Easy to override for deployment-specific needs</p> <p>Default Values Rationale: - Port 8080: Standard non-privileged HTTP port - 30-second timeouts: Balance between user experience and resource protection - JSON storage: Simple setup without external dependencies - Structured logging: Better for log aggregation and analysis - Memory caching: Good performance without external dependencies</p> <p></p>"},{"location":"models/auto/models/#func-config-validate","title":"func (*Config) Validate","text":"<pre><code>func (c *Config) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-createapplicationrequest","title":"type CreateApplicationRequest","text":"<pre><code>type CreateApplicationRequest struct {\n    ID          string            `json:\"id\" validate:\"required\"`\n    Name        string            `json:\"name\" validate:\"required\"`\n    Description string            `json:\"description\"`\n    Platforms   []string          `json:\"platforms\" validate:\"required,min=1\"`\n    Config      ApplicationConfig `json:\"config\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-createapplicationrequest-normalize","title":"func (*CreateApplicationRequest) Normalize","text":"<pre><code>func (r *CreateApplicationRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-createapplicationrequest-validate","title":"func (*CreateApplicationRequest) Validate","text":"<pre><code>func (r *CreateApplicationRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-createapplicationresponse","title":"type CreateApplicationResponse","text":"<pre><code>type CreateApplicationResponse struct {\n    ID        string    `json:\"id\"`\n    Message   string    `json:\"message\"`\n    CreatedAt time.Time `json:\"created_at\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-databaseconfig","title":"type DatabaseConfig","text":"<pre><code>type DatabaseConfig struct {\n    Driver          string        `yaml:\"driver\" json:\"driver\"`\n    DSN             string        `yaml:\"dsn\" json:\"dsn\"`\n    MaxOpenConns    int           `yaml:\"max_open_conns\" json:\"max_open_conns\"`\n    MaxIdleConns    int           `yaml:\"max_idle_conns\" json:\"max_idle_conns\"`\n    ConnMaxLifetime time.Duration `yaml:\"conn_max_lifetime\" json:\"conn_max_lifetime\"`\n    ConnMaxIdleTime time.Duration `yaml:\"conn_max_idle_time\" json:\"conn_max_idle_time\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-deletereleaserequest","title":"type DeleteReleaseRequest","text":"<pre><code>type DeleteReleaseRequest struct {\n    ApplicationID string `json:\"application_id\" validate:\"required\"`\n    ReleaseID     string `json:\"release_id\" validate:\"required\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-deletereleaseresponse","title":"type DeleteReleaseResponse","text":"<pre><code>type DeleteReleaseResponse struct {\n    ID      string `json:\"id\"`\n    Message string `json:\"message\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-errorresponse","title":"type ErrorResponse","text":"<p>ErrorResponse provides structured error information with debugging context.</p> <p>Error Handling Design: - Consistent error structure across all endpoints - Machine-readable error codes for programmatic handling - Human-readable messages for user interfaces - Details map for field-specific validation errors - Request ID for distributed tracing and support - Timestamps for debugging and audit trails</p> <p>Error Categories: - Validation errors: Input format/constraint violations - Not found errors: Resource doesn't exist - Authorization errors: Authentication/permission failures - Internal errors: Server-side issues</p> <pre><code>type ErrorResponse struct {\n    Error     string            `json:\"error\"`                // Error type (always \"error\")\n    Message   string            `json:\"message\"`              // Human-readable error description\n    Code      string            `json:\"code,omitempty\"`       // Machine-readable error code\n    Details   map[string]string `json:\"details,omitempty\"`    // Field-specific error details\n    Timestamp time.Time         `json:\"timestamp\"`            // Error occurrence time\n    RequestID string            `json:\"request_id,omitempty\"` // Unique request identifier\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-newerrorresponse","title":"func NewErrorResponse","text":"<pre><code>func NewErrorResponse(message string, code string) *ErrorResponse\n</code></pre>"},{"location":"models/auto/models/#type-healthcheckrequest","title":"type HealthCheckRequest","text":"<pre><code>type HealthCheckRequest struct {\n    Component string `json:\"component,omitempty\"`\n    Deep      bool   `json:\"deep\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-healthcheckresponse","title":"type HealthCheckResponse","text":"<pre><code>type HealthCheckResponse struct {\n    Status     string                     `json:\"status\"`\n    Timestamp  time.Time                  `json:\"timestamp\"`\n    Version    string                     `json:\"version,omitempty\"`\n    Uptime     string                     `json:\"uptime,omitempty\"`\n    Components map[string]ComponentHealth `json:\"components,omitempty\"`\n    Metrics    map[string]interface{}     `json:\"metrics,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-newhealthcheckresponse","title":"func NewHealthCheckResponse","text":"<pre><code>func NewHealthCheckResponse(status string) *HealthCheckResponse\n</code></pre>"},{"location":"models/auto/models/#func-healthcheckresponse-addcomponent","title":"func (*HealthCheckResponse) AddComponent","text":"<pre><code>func (h *HealthCheckResponse) AddComponent(name, status, message string)\n</code></pre>"},{"location":"models/auto/models/#func-healthcheckresponse-addmetric","title":"func (*HealthCheckResponse) AddMetric","text":"<pre><code>func (h *HealthCheckResponse) AddMetric(name string, value interface{})\n</code></pre>"},{"location":"models/auto/models/#type-latestversionrequest","title":"type LatestVersionRequest","text":"<pre><code>type LatestVersionRequest struct {\n    ApplicationID   string `json:\"application_id\" validate:\"required\"`\n    Platform        string `json:\"platform\" validate:\"required\"`\n    Architecture    string `json:\"architecture\" validate:\"required\"`\n    AllowPrerelease bool   `json:\"allow_prerelease\"`\n    IncludeMetadata bool   `json:\"include_metadata\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-latestversionrequest-normalize","title":"func (*LatestVersionRequest) Normalize","text":"<pre><code>func (r *LatestVersionRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-latestversionrequest-validate","title":"func (*LatestVersionRequest) Validate","text":"<pre><code>func (r *LatestVersionRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-latestversionresponse","title":"type LatestVersionResponse","text":"<pre><code>type LatestVersionResponse struct {\n    Version      string            `json:\"version\"`\n    DownloadURL  string            `json:\"download_url\"`\n    Checksum     string            `json:\"checksum\"`\n    ChecksumType string            `json:\"checksum_type\"`\n    FileSize     int64             `json:\"file_size\"`\n    ReleaseNotes string            `json:\"release_notes\"`\n    ReleaseDate  time.Time         `json:\"release_date\"`\n    Required     bool              `json:\"required\"`\n    Metadata     map[string]string `json:\"metadata,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-latestversionresponse-fromrelease","title":"func (*LatestVersionResponse) FromRelease","text":"<pre><code>func (r *LatestVersionResponse) FromRelease(release *Release)\n</code></pre>"},{"location":"models/auto/models/#type-listapplicationsresponse","title":"type ListApplicationsResponse","text":"<pre><code>type ListApplicationsResponse struct {\n    Applications []ApplicationSummary `json:\"applications\"`\n    TotalCount   int                  `json:\"total_count\"`\n    Page         int                  `json:\"page\"`\n    PageSize     int                  `json:\"page_size\"`\n    HasMore      bool                 `json:\"has_more\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-listreleasesrequest","title":"type ListReleasesRequest","text":"<pre><code>type ListReleasesRequest struct {\n    ApplicationID string   `json:\"application_id\" validate:\"required\"`\n    Platform      string   `json:\"platform,omitempty\"`\n    Architecture  string   `json:\"architecture,omitempty\"`\n    Version       string   `json:\"version,omitempty\"`\n    Required      *bool    `json:\"required,omitempty\"`\n    Limit         int      `json:\"limit,omitempty\"`\n    Offset        int      `json:\"offset,omitempty\"`\n    SortBy        string   `json:\"sort_by,omitempty\"`\n    SortOrder     string   `json:\"sort_order,omitempty\"`\n    Platforms     []string `json:\"platforms,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-listreleasesrequest-normalize","title":"func (*ListReleasesRequest) Normalize","text":"<pre><code>func (r *ListReleasesRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-listreleasesrequest-validate","title":"func (*ListReleasesRequest) Validate","text":"<pre><code>func (r *ListReleasesRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-listreleasesresponse","title":"type ListReleasesResponse","text":"<pre><code>type ListReleasesResponse struct {\n    Releases   []ReleaseInfo `json:\"releases\"`\n    TotalCount int           `json:\"total_count\"`\n    Page       int           `json:\"page\"`\n    PageSize   int           `json:\"page_size\"`\n    HasMore    bool          `json:\"has_more\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-loggingconfig","title":"type LoggingConfig","text":"<pre><code>type LoggingConfig struct {\n    Level      string `yaml:\"level\" json:\"level\"`\n    Format     string `yaml:\"format\" json:\"format\"`\n    Output     string `yaml:\"output\" json:\"output\"`\n    FilePath   string `yaml:\"file_path\" json:\"file_path\"`\n    MaxSize    int    `yaml:\"max_size\" json:\"max_size\"`\n    MaxBackups int    `yaml:\"max_backups\" json:\"max_backups\"`\n    MaxAge     int    `yaml:\"max_age\" json:\"max_age\"`\n    Compress   bool   `yaml:\"compress\" json:\"compress\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-loggingconfig-validate","title":"func (*LoggingConfig) Validate","text":"<pre><code>func (lc *LoggingConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-memoryconfig","title":"type MemoryConfig","text":"<pre><code>type MemoryConfig struct {\n    MaxSize         int           `yaml:\"max_size\" json:\"max_size\"`\n    CleanupInterval time.Duration `yaml:\"cleanup_interval\" json:\"cleanup_interval\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-metricsconfig","title":"type MetricsConfig","text":"<pre><code>type MetricsConfig struct {\n    Enabled bool   `yaml:\"enabled\" json:\"enabled\"`\n    Path    string `yaml:\"path\" json:\"path\"`\n    Port    int    `yaml:\"port\" json:\"port\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-metricsconfig-validate","title":"func (*MetricsConfig) Validate","text":"<pre><code>func (mc *MetricsConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-observabilityconfig","title":"type ObservabilityConfig","text":"<p>ObservabilityConfig holds configuration for OpenTelemetry-based observability. Note: ServiceVersion is now set at build time via ldflags, not via configuration.</p> <pre><code>type ObservabilityConfig struct {\n    ServiceName string        `yaml:\"service_name\" json:\"service_name\"`\n    Tracing     TracingConfig `yaml:\"tracing\" json:\"tracing\"`\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-observabilityconfig-validate","title":"func (*ObservabilityConfig) Validate","text":"<pre><code>func (oc *ObservabilityConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-platforminfo","title":"type PlatformInfo","text":"<p>PlatformInfo represents a platform/architecture combination.</p> <p>Usage: - Used for filtering releases by target platform - Validates platform/architecture compatibility - Provides string representation for file naming and URLs</p> <p>Example: PlatformInfo{\"windows\", \"amd64\"} -&gt; \"windows-amd64\"</p> <pre><code>type PlatformInfo struct {\n    Platform     string `json:\"platform\"`     // Operating system (windows, linux, darwin, etc.)\n    Architecture string `json:\"architecture\"` // CPU architecture (amd64, arm64, 386, arm)\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-platforminfo-string","title":"func (*PlatformInfo) String","text":"<pre><code>func (pi *PlatformInfo) String() string\n</code></pre>"},{"location":"models/auto/models/#func-platforminfo-validate","title":"func (*PlatformInfo) Validate","text":"<pre><code>func (pi *PlatformInfo) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-redisconfig","title":"type RedisConfig","text":"<pre><code>type RedisConfig struct {\n    Addr     string `yaml:\"addr\" json:\"addr\"`\n    Password string `yaml:\"password\" json:\"password\"`\n    DB       int    `yaml:\"db\" json:\"db\"`\n    PoolSize int    `yaml:\"pool_size\" json:\"pool_size\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-registerreleaserequest","title":"type RegisterReleaseRequest","text":"<p>RegisterReleaseRequest represents a request to register a new release (admin operation).</p> <p>Administrative API Design: - Complete release information required for proper distribution - URL validation ensures download links are accessible and safe - Checksum and size validation for integrity verification - Flexible metadata support for extensibility - Required flag enables critical security update workflows - MinimumVersion supports controlled upgrade paths</p> <p>Security Considerations: - This is an admin-only operation requiring authentication - All URLs are validated to prevent malicious links - Checksums must be provided to ensure integrity - File size helps detect corruption and manage storage</p> <pre><code>type RegisterReleaseRequest struct {\n    ApplicationID  string            `json:\"application_id\" validate:\"required\"`   // Target application\n    Version        string            `json:\"version\" validate:\"required\"`          // Release version (semantic)\n    Platform       string            `json:\"platform\" validate:\"required\"`         // Target platform\n    Architecture   string            `json:\"architecture\" validate:\"required\"`     // Target architecture\n    DownloadURL    string            `json:\"download_url\" validate:\"required,url\"` // External download location\n    Checksum       string            `json:\"checksum\" validate:\"required\"`         // File integrity hash\n    ChecksumType   string            `json:\"checksum_type\" validate:\"required\"`    // Hash algorithm\n    FileSize       int64             `json:\"file_size\" validate:\"min=0\"`           // File size in bytes\n    ReleaseNotes   string            `json:\"release_notes\"`                        // Change description\n    Required       bool              `json:\"required\"`                             // Force update flag\n    MinimumVersion string            `json:\"minimum_version,omitempty\"`            // Required current version\n    Metadata       map[string]string `json:\"metadata,omitempty\"`                   // Additional metadata\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-registerreleaserequest-normalize","title":"func (*RegisterReleaseRequest) Normalize","text":"<pre><code>func (r *RegisterReleaseRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-registerreleaserequest-validate","title":"func (*RegisterReleaseRequest) Validate","text":"<pre><code>func (r *RegisterReleaseRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-registerreleaseresponse","title":"type RegisterReleaseResponse","text":"<pre><code>type RegisterReleaseResponse struct {\n    ID        string    `json:\"id\"`\n    Message   string    `json:\"message\"`\n    CreatedAt time.Time `json:\"created_at\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-release","title":"type Release","text":"<p>Release represents a software release with complete metadata and security information.</p> <p>Design Rationale: - Composite ID ensures uniqueness across app/version/platform/arch combinations - External download URLs support CDN distribution and scaling - Cryptographic checksums ensure download integrity - File size enables progress tracking and storage planning - Required flag supports security patch distribution - MinimumVersion enforces upgrade paths and compatibility - Extensible metadata for future needs (signatures, mirrors, etc.) - Audit trail with creation and update timestamps</p> <pre><code>type Release struct {\n    ID             string            `json:\"id\" validate:\"required\"`               // Unique release identifier (app-version-platform-arch)\n    ApplicationID  string            `json:\"application_id\" validate:\"required\"`   // Parent application identifier\n    Version        string            `json:\"version\" validate:\"required\"`          // Semantic version string\n    Platform       string            `json:\"platform\" validate:\"required\"`         // Target operating system\n    Architecture   string            `json:\"architecture\" validate:\"required\"`     // Target CPU architecture\n    DownloadURL    string            `json:\"download_url\" validate:\"required,url\"` // External download location\n    Checksum       string            `json:\"checksum\" validate:\"required\"`         // Cryptographic hash for integrity\n    ChecksumType   string            `json:\"checksum_type\" validate:\"required\"`    // Hash algorithm (sha256, md5, sha1)\n    FileSize       int64             `json:\"file_size\" validate:\"min=0\"`           // File size in bytes\n    ReleaseNotes   string            `json:\"release_notes\"`                        // Human-readable change description\n    ReleaseDate    time.Time         `json:\"release_date\"`                         // Official release timestamp\n    Required       bool              `json:\"required\"`                             // Force update (security patches)\n    MinimumVersion string            `json:\"minimum_version,omitempty\"`            // Required current version for upgrade\n    Metadata       map[string]string `json:\"metadata,omitempty\"`                   // Extensible key-value metadata\n    CreatedAt      time.Time         `json:\"created_at\"`                           // Record creation timestamp\n    UpdatedAt      time.Time         `json:\"updated_at\"`                           // Last modification timestamp\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-newrelease","title":"func NewRelease","text":"<pre><code>func NewRelease(appID, version, platform, arch, downloadURL string) *Release\n</code></pre> <p>NewRelease creates a new Release with secure defaults.</p> <p>Security Defaults: - Generated composite ID for uniqueness and predictability - SHA256 checksum algorithm for strong integrity verification - Current timestamp for audit trails - Non-required update (safety first - let users choose) - Initialized metadata map for extensibility</p> <p></p>"},{"location":"models/auto/models/#func-release-generatechecksum","title":"func (*Release) GenerateChecksum","text":"<pre><code>func (r *Release) GenerateChecksum(data []byte) string\n</code></pre>"},{"location":"models/auto/models/#func-release-getmetadata","title":"func (*Release) GetMetadata","text":"<pre><code>func (r *Release) GetMetadata(key string) (string, bool)\n</code></pre>"},{"location":"models/auto/models/#func-release-getplatforminfo","title":"func (*Release) GetPlatformInfo","text":"<pre><code>func (r *Release) GetPlatformInfo() PlatformInfo\n</code></pre>"},{"location":"models/auto/models/#func-release-iscompatiblewith","title":"func (*Release) IsCompatibleWith","text":"<pre><code>func (r *Release) IsCompatibleWith(platform, arch string) bool\n</code></pre>"},{"location":"models/auto/models/#func-release-isnewerthan","title":"func (*Release) IsNewerThan","text":"<pre><code>func (r *Release) IsNewerThan(other *Release) (bool, error)\n</code></pre>"},{"location":"models/auto/models/#func-release-meetsminimumversion","title":"func (*Release) MeetsMinimumVersion","text":"<pre><code>func (r *Release) MeetsMinimumVersion(currentVersion string) (bool, error)\n</code></pre>"},{"location":"models/auto/models/#func-release-setmetadata","title":"func (*Release) SetMetadata","text":"<pre><code>func (r *Release) SetMetadata(key, value string)\n</code></pre>"},{"location":"models/auto/models/#func-release-validate","title":"func (*Release) Validate","text":"<pre><code>func (r *Release) Validate() error\n</code></pre>"},{"location":"models/auto/models/#func-release-validatedownloadurl","title":"func (*Release) ValidateDownloadURL","text":"<pre><code>func (r *Release) ValidateDownloadURL() error\n</code></pre>"},{"location":"models/auto/models/#func-release-verifychecksum","title":"func (*Release) VerifyChecksum","text":"<pre><code>func (r *Release) VerifyChecksum(data []byte) bool\n</code></pre>"},{"location":"models/auto/models/#type-releasefilter","title":"type ReleaseFilter","text":"<p>ReleaseFilter provides flexible querying and pagination for release lists.</p> <p>Query Design: - Supports filtering by any combination of fields - Pagination with limit/offset for large datasets - Flexible sorting by multiple fields - Multi-platform queries for cross-platform applications - Boolean pointer for Required allows three states: true, false, nil (don't care)</p> <pre><code>type ReleaseFilter struct {\n    ApplicationID string   `json:\"application_id,omitempty\"` // Filter by application\n    Platform      string   `json:\"platform,omitempty\"`       // Filter by single platform\n    Architecture  string   `json:\"architecture,omitempty\"`   // Filter by architecture\n    Version       string   `json:\"version,omitempty\"`        // Filter by specific version\n    Required      *bool    `json:\"required,omitempty\"`       // Filter by required status (nil = all)\n    Limit         int      `json:\"limit,omitempty\"`          // Maximum results to return\n    Offset        int      `json:\"offset,omitempty\"`         // Results to skip (pagination)\n    SortBy        string   `json:\"sort_by,omitempty\"`        // Field to sort by\n    SortOrder     string   `json:\"sort_order,omitempty\"`     // Sort direction (asc/desc)\n    Platforms     []string `json:\"platforms,omitempty\"`      // Filter by multiple platforms\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-releasefilter-validate","title":"func (*ReleaseFilter) Validate","text":"<pre><code>func (rf *ReleaseFilter) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-releaseinfo","title":"type ReleaseInfo","text":"<pre><code>type ReleaseInfo struct {\n    ID             string            `json:\"id\"`\n    Version        string            `json:\"version\"`\n    Platform       string            `json:\"platform\"`\n    Architecture   string            `json:\"architecture\"`\n    DownloadURL    string            `json:\"download_url\"`\n    Checksum       string            `json:\"checksum\"`\n    ChecksumType   string            `json:\"checksum_type\"`\n    FileSize       int64             `json:\"file_size\"`\n    ReleaseNotes   string            `json:\"release_notes\"`\n    ReleaseDate    time.Time         `json:\"release_date\"`\n    Required       bool              `json:\"required\"`\n    MinimumVersion string            `json:\"minimum_version,omitempty\"`\n    Metadata       map[string]string `json:\"metadata,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-releaseinfo-fromrelease","title":"func (*ReleaseInfo) FromRelease","text":"<pre><code>func (ri *ReleaseInfo) FromRelease(release *Release)\n</code></pre>"},{"location":"models/auto/models/#type-releasemetadata","title":"type ReleaseMetadata","text":"<p>ReleaseMetadata contains additional file and security information for releases.</p> <p>Extended Metadata: - FileName for original file naming and client-side handling - ContentType for proper MIME handling and security - Signature for future cryptographic verification (code signing) - Publisher for trust and accountability</p> <pre><code>type ReleaseMetadata struct {\n    FileName    string `json:\"file_name,omitempty\"`    // Original filename for download\n    ContentType string `json:\"content_type,omitempty\"` // MIME type for proper handling\n    Signature   string `json:\"signature,omitempty\"`    // Cryptographic signature (future)\n    Publisher   string `json:\"publisher,omitempty\"`    // Publisher/signer identity\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#type-releasestats","title":"type ReleaseStats","text":"<pre><code>type ReleaseStats struct {\n    TotalReleases     int       `json:\"total_releases\"`\n    LatestVersion     string    `json:\"latest_version\"`\n    LatestReleaseDate time.Time `json:\"latest_release_date\"`\n    PlatformCount     int       `json:\"platform_count\"`\n    RequiredReleases  int       `json:\"required_releases\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-securityconfig","title":"type SecurityConfig","text":"<p>SecurityConfig holds authentication and authorisation settings.</p> <pre><code>type SecurityConfig struct {\n    // BootstrapKey is the initial admin API key seeded into storage on first startup\n    // when the api_keys table is empty. Required when EnableAuth is true.\n    // Set via the UPDATER_BOOTSTRAP_KEY environment variable or security.bootstrap_key\n    // in the config file. After the first startup, keys are managed via the REST API.\n    BootstrapKey string `yaml:\"bootstrap_key\" json:\"bootstrap_key\"`\n    // EnableAuth toggles API key authentication. When false all endpoints are public.\n    EnableAuth bool `yaml:\"enable_auth\" json:\"enable_auth\"`\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-securityconfig-validate","title":"func (*SecurityConfig) Validate","text":"<pre><code>func (sec *SecurityConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-serverconfig","title":"type ServerConfig","text":"<pre><code>type ServerConfig struct {\n    Port         int           `yaml:\"port\" json:\"port\"`\n    Host         string        `yaml:\"host\" json:\"host\"`\n    ReadTimeout  time.Duration `yaml:\"read_timeout\" json:\"read_timeout\"`\n    WriteTimeout time.Duration `yaml:\"write_timeout\" json:\"write_timeout\"`\n    IdleTimeout  time.Duration `yaml:\"idle_timeout\" json:\"idle_timeout\"`\n    TLSEnabled   bool          `yaml:\"tls_enabled\" json:\"tls_enabled\"`\n    TLSCertFile  string        `yaml:\"tls_cert_file\" json:\"tls_cert_file\"`\n    TLSKeyFile   string        `yaml:\"tls_key_file\" json:\"tls_key_file\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-serverconfig-validate","title":"func (*ServerConfig) Validate","text":"<pre><code>func (sc *ServerConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-statsresponse","title":"type StatsResponse","text":"<pre><code>type StatsResponse struct {\n    TotalApplications int                    `json:\"total_applications\"`\n    TotalReleases     int                    `json:\"total_releases\"`\n    PlatformStats     map[string]int         `json:\"platform_stats\"`\n    VersionStats      map[string]int         `json:\"version_stats\"`\n    RecentActivity    []ActivityItem         `json:\"recent_activity\"`\n    SystemInfo        map[string]interface{} `json:\"system_info\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-storageconfig","title":"type StorageConfig","text":"<pre><code>type StorageConfig struct {\n    Type     string            `yaml:\"type\" json:\"type\"`\n    Path     string            `yaml:\"path\" json:\"path\"`\n    Database DatabaseConfig    `yaml:\"database\" json:\"database\"`\n    Options  map[string]string `yaml:\"options\" json:\"options\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-storageconfig-validate","title":"func (*StorageConfig) Validate","text":"<pre><code>func (stc *StorageConfig) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-tracingconfig","title":"type TracingConfig","text":"<p>TracingConfig holds configuration for distributed tracing.</p> <pre><code>type TracingConfig struct {\n    Enabled      bool    `yaml:\"enabled\" json:\"enabled\"`\n    Exporter     string  `yaml:\"exporter\" json:\"exporter\"`\n    SampleRate   float64 `yaml:\"sample_rate\" json:\"sample_rate\"`\n    OTLPEndpoint string  `yaml:\"otlp_endpoint\" json:\"otlp_endpoint\"`\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#type-updateapplicationrequest","title":"type UpdateApplicationRequest","text":"<pre><code>type UpdateApplicationRequest struct {\n    Name        *string            `json:\"name,omitempty\"`\n    Description *string            `json:\"description,omitempty\"`\n    Platforms   []string           `json:\"platforms,omitempty\"`\n    Config      *ApplicationConfig `json:\"config,omitempty\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-updateapplicationrequest-normalize","title":"func (*UpdateApplicationRequest) Normalize","text":"<pre><code>func (r *UpdateApplicationRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-updateapplicationrequest-validate","title":"func (*UpdateApplicationRequest) Validate","text":"<pre><code>func (r *UpdateApplicationRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-updateapplicationresponse","title":"type UpdateApplicationResponse","text":"<pre><code>type UpdateApplicationResponse struct {\n    ID        string    `json:\"id\"`\n    Message   string    `json:\"message\"`\n    UpdatedAt time.Time `json:\"updated_at\"`\n}\n</code></pre>"},{"location":"models/auto/models/#type-updatecheckrequest","title":"type UpdateCheckRequest","text":"<p>UpdateCheckRequest represents a request to check for available updates.</p> <p>Core API Design: - Required fields ensure we have minimum information for meaningful responses - Platform/Architecture pair determines compatibility matching - AllowPrerelease enables beta testing workflows - IncludeMetadata controls response size (metadata can be large) - UserAgent and ClientID support analytics and debugging (optional)</p> <p>Security Notes: - No sensitive information should be included - All fields are validated before processing - Version format is strictly validated to prevent injection</p> <pre><code>type UpdateCheckRequest struct {\n    ApplicationID   string `json:\"application_id\" validate:\"required\"`  // Target application identifier\n    CurrentVersion  string `json:\"current_version\" validate:\"required\"` // Client's current version\n    Platform        string `json:\"platform\" validate:\"required\"`        // Target OS (windows, linux, darwin)\n    Architecture    string `json:\"architecture\" validate:\"required\"`    // Target arch (amd64, arm64, 386, arm)\n    AllowPrerelease bool   `json:\"allow_prerelease\"`                    // Include pre-release versions\n    IncludeMetadata bool   `json:\"include_metadata\"`                    // Include release metadata in response\n    UserAgent       string `json:\"user_agent,omitempty\"`                // Client identification (optional)\n    ClientID        string `json:\"client_id,omitempty\"`                 // Unique client ID (optional analytics)\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-updatecheckrequest-normalize","title":"func (*UpdateCheckRequest) Normalize","text":"<pre><code>func (r *UpdateCheckRequest) Normalize()\n</code></pre>"},{"location":"models/auto/models/#func-updatecheckrequest-validate","title":"func (*UpdateCheckRequest) Validate","text":"<pre><code>func (r *UpdateCheckRequest) Validate() error\n</code></pre>"},{"location":"models/auto/models/#type-updatecheckresponse","title":"type UpdateCheckResponse","text":"<p>UpdateCheckResponse provides complete information about available updates.</p> <p>Response Strategy: - UpdateAvailable is the primary decision field for clients - All download information is provided when updates are available - CurrentVersion echoes the request for client verification - Required flag indicates critical security updates - Metadata is optional to control response size - UpgradeInstructions support complex update workflows</p> <p>Client Usage: - Check UpdateAvailable first - Use Required flag to determine update urgency - Verify checksums before installation - Display ReleaseNotes to users for informed decisions</p> <pre><code>type UpdateCheckResponse struct {\n    UpdateAvailable     bool              `json:\"update_available\"`               // Primary decision flag\n    LatestVersion       string            `json:\"latest_version,omitempty\"`       // Available version (if update exists)\n    CurrentVersion      string            `json:\"current_version\"`                // Client's current version (echoed)\n    DownloadURL         string            `json:\"download_url,omitempty\"`         // Download location (if update exists)\n    Checksum            string            `json:\"checksum,omitempty\"`             // File integrity hash\n    ChecksumType        string            `json:\"checksum_type,omitempty\"`        // Hash algorithm\n    FileSize            int64             `json:\"file_size,omitempty\"`            // File size for progress tracking\n    ReleaseNotes        string            `json:\"release_notes,omitempty\"`        // Human-readable changes\n    ReleaseDate         *time.Time        `json:\"release_date,omitempty\"`         // Release timestamp\n    Required            bool              `json:\"required\"`                       // Critical update flag\n    MinimumVersion      string            `json:\"minimum_version,omitempty\"`      // Required current version\n    Metadata            map[string]string `json:\"metadata,omitempty\"`             // Extended metadata (optional)\n    UpgradeInstructions string            `json:\"upgrade_instructions,omitempty\"` // Custom upgrade steps\n}\n</code></pre> <p></p>"},{"location":"models/auto/models/#func-updatecheckresponse-setnoupdateavailable","title":"func (*UpdateCheckResponse) SetNoUpdateAvailable","text":"<pre><code>func (r *UpdateCheckResponse) SetNoUpdateAvailable(currentVersion string)\n</code></pre>"},{"location":"models/auto/models/#func-updatecheckresponse-setupdateavailable","title":"func (*UpdateCheckResponse) SetUpdateAvailable","text":"<pre><code>func (r *UpdateCheckResponse) SetUpdateAvailable(release *Release)\n</code></pre>"},{"location":"models/auto/models/#type-validationerrorresponse","title":"type ValidationErrorResponse","text":"<pre><code>type ValidationErrorResponse struct {\n    Error  string            `json:\"error\"`\n    Errors map[string]string `json:\"errors\"`\n}\n</code></pre>"},{"location":"models/auto/models/#func-newvalidationerrorresponse","title":"func NewValidationErrorResponse","text":"<pre><code>func NewValidationErrorResponse(errors map[string]string) *ValidationErrorResponse\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"plans/2026-02-15-application-management-api-design/","title":"Application Management API Design","text":"<p>Date: 2026-02-15 Status: Approved</p>"},{"location":"plans/2026-02-15-application-management-api-design/#problem","title":"Problem","text":"<p>The updater service has no HTTP API for managing applications. Models (<code>CreateApplicationRequest</code>, <code>UpdateApplicationRequest</code>, etc.) and storage methods (<code>SaveApplication</code>, <code>GetApplication</code>, <code>Applications</code>) exist, but there are zero HTTP handlers or routes. Operators cannot create, list, update, or delete applications through the API -- they can only write directly to the storage backend.</p> <p>Additionally, the <code>DeleteRelease</code> storage method exists in all backends but has no HTTP endpoint.</p>"},{"location":"plans/2026-02-15-application-management-api-design/#goals","title":"Goals","text":"<ol> <li>Add full CRUD endpoints for application management</li> <li>Add a delete endpoint for releases</li> <li>Follow existing architectural patterns (service layer, typed errors, audit logging)</li> <li>Enforce referential integrity when deleting applications that have releases</li> </ol>"},{"location":"plans/2026-02-15-application-management-api-design/#design","title":"Design","text":""},{"location":"plans/2026-02-15-application-management-api-design/#api-endpoints","title":"API Endpoints","text":"<p>Six new endpoints under <code>/api/v1</code>:</p> Method Path Auth Description <code>POST</code> <code>/api/v1/applications</code> write Create application <code>GET</code> <code>/api/v1/applications</code> read List applications (paginated) <code>GET</code> <code>/api/v1/applications/{app_id}</code> read Get application with stats <code>PUT</code> <code>/api/v1/applications/{app_id}</code> admin Update application <code>DELETE</code> <code>/api/v1/applications/{app_id}</code> admin Delete application <code>DELETE</code> <code>/api/v1/updates/{app_id}/releases/{version}/{platform}/{arch}</code> admin Delete release <p>Permission levels follow the existing hierarchy: <code>read &lt; write &lt; admin</code>. Creating an application requires <code>write</code> (same as registering a release). Updating and deleting require <code>admin</code> since these are destructive or high-impact operations.</p> <p>The delete release path uses <code>{version}/{platform}/{arch}</code> because that is the compound key in the storage interface.</p>"},{"location":"plans/2026-02-15-application-management-api-design/#service-interface-extensions","title":"Service Interface Extensions","text":"<p>Five new methods added to <code>ServiceInterface</code>, one for delete release:</p> <pre><code>type ServiceInterface interface {\n    // Existing methods\n    CheckForUpdate(ctx context.Context, req *models.UpdateCheckRequest) (*models.UpdateCheckResponse, error)\n    GetLatestVersion(ctx context.Context, req *models.LatestVersionRequest) (*models.LatestVersionResponse, error)\n    ListReleases(ctx context.Context, req *models.ListReleasesRequest) (*models.ListReleasesResponse, error)\n    RegisterRelease(ctx context.Context, req *models.RegisterReleaseRequest) (*models.RegisterReleaseResponse, error)\n\n    // New methods\n    CreateApplication(ctx context.Context, req *models.CreateApplicationRequest) (*models.CreateApplicationResponse, error)\n    GetApplication(ctx context.Context, appID string) (*models.ApplicationInfoResponse, error)\n    ListApplications(ctx context.Context, limit, offset int) (*models.ListApplicationsResponse, error)\n    UpdateApplication(ctx context.Context, appID string, req *models.UpdateApplicationRequest) (*models.UpdateApplicationResponse, error)\n    DeleteApplication(ctx context.Context, appID string) error\n    DeleteRelease(ctx context.Context, req *models.DeleteReleaseRequest) (*models.DeleteReleaseResponse, error)\n}\n</code></pre> <p>Business rules:</p> <ul> <li><code>CreateApplication</code> -- validate request, check for duplicate ID (return <code>409 Conflict</code>), populate <code>CreatedAt</code>/<code>UpdatedAt</code> timestamps, save</li> <li><code>GetApplication</code> -- fetch application and compute <code>ApplicationStats</code> (total releases, latest version, platform count) by querying storage</li> <li><code>ListApplications</code> -- fetch all applications, apply pagination, populate summaries</li> <li><code>UpdateApplication</code> -- verify application exists (return <code>404</code>), merge partial update fields, update <code>UpdatedAt</code> timestamp</li> <li><code>DeleteApplication</code> -- verify application exists, enforce referential integrity (see below), delete</li> <li><code>DeleteRelease</code> -- verify release exists (return <code>404</code>), delete, audit log</li> </ul>"},{"location":"plans/2026-02-15-application-management-api-design/#storage-layer-changes","title":"Storage Layer Changes","text":"<p>New method on the <code>Storage</code> interface:</p> <pre><code>DeleteApplication(ctx context.Context, appID string) error\n</code></pre> <p>Two-tier referential integrity enforcement:</p> Backend Referential integrity Mechanism PostgreSQL <code>ON DELETE RESTRICT</code> foreign key on <code>releases.application_id</code> Database rejects deletion, returns error SQLite <code>ON DELETE RESTRICT</code> foreign key on <code>releases.application_id</code> Database rejects deletion, returns error Memory Service layer checks <code>Releases(ctx, appID)</code> before delete Application code rejects deletion JSON Service layer checks <code>Releases(ctx, appID)</code> before delete Application code rejects deletion <p>Database migrations:</p> <p>New migration files (<code>002_add_release_fk.sql</code>) in each engine's schema directory to add the FK constraint.</p> <p>PostgreSQL:</p> <pre><code>ALTER TABLE releases\n  ADD CONSTRAINT fk_releases_application\n  FOREIGN KEY (application_id) REFERENCES applications(id)\n  ON DELETE RESTRICT;\n</code></pre> <p>SQLite requires recreating the table since <code>ALTER TABLE ADD CONSTRAINT</code> is not supported. The FK is added inline in the new table definition.</p> <p>Database backends detect FK constraint violations from the driver error and return a <code>storage.ErrHasDependencies</code> sentinel error. The service layer checks for this with <code>errors.Is()</code> and maps it to a <code>409 Conflict</code> response.</p> <p>For memory/JSON backends, the service layer calls <code>Releases(ctx, appID)</code> before <code>DeleteApplication</code>. If releases exist, it returns the same typed error, keeping behavior consistent across all backends.</p> <p>New sqlc queries:</p> <ul> <li><code>DeleteApplication :exec</code> in both PostgreSQL and SQLite query directories</li> <li>sqlc regeneration after schema/query changes</li> </ul>"},{"location":"plans/2026-02-15-application-management-api-design/#handler-implementation","title":"Handler Implementation","text":"<p>A new file <code>internal/api/handlers_applications.go</code> to keep application handlers separate.</p> <p>Handler methods on the existing <code>Handlers</code> struct:</p> <ul> <li><code>CreateApplication(w, r)</code> -- parse JSON body, call service, return <code>201 Created</code></li> <li><code>GetApplication(w, r)</code> -- extract <code>{app_id}</code> from path, call service, return <code>200 OK</code></li> <li><code>ListApplications(w, r)</code> -- parse <code>limit</code>/<code>offset</code> query params with defaults, call service, return <code>200 OK</code></li> <li><code>UpdateApplication(w, r)</code> -- extract <code>{app_id}</code>, parse JSON body, call service, return <code>200 OK</code></li> <li><code>DeleteApplication(w, r)</code> -- extract <code>{app_id}</code>, call service, return <code>204 No Content</code></li> <li><code>DeleteRelease(w, r)</code> -- extract <code>{app_id}/{version}/{platform}/{arch}</code>, call service, return <code>200 OK</code></li> </ul> <p>Patterns carried forward:</p> <ul> <li>Security audit logging on all write/admin operations (<code>slog.Warn</code> with <code>\"event\", \"security_audit\"</code> tag)</li> <li><code>Content-Type</code> validation on POST/PUT bodies</li> <li><code>writeServiceErrorResponse</code> for error mapping</li> <li><code>GetSecurityContext(r)</code> for audit log enrichment</li> <li><code>mux.Vars(r)</code> for path parameter extraction</li> </ul> <p>Route registration in <code>routes.go</code>:</p> <pre><code>// Application management endpoints\nappAPI := api.PathPrefix(\"/applications\").Subrouter()\nappAPI.Use(authMiddleware(config))\n\nappAPI.HandleFunc(\"\", RequirePermission(PermissionWrite, handlers.CreateApplication)).Methods(\"POST\")\nappAPI.HandleFunc(\"\", RequirePermission(PermissionRead, handlers.ListApplications)).Methods(\"GET\")\nappAPI.HandleFunc(\"/{app_id}\", RequirePermission(PermissionRead, handlers.GetApplication)).Methods(\"GET\")\nappAPI.HandleFunc(\"/{app_id}\", RequirePermission(PermissionAdmin, handlers.UpdateApplication)).Methods(\"PUT\")\nappAPI.HandleFunc(\"/{app_id}\", RequirePermission(PermissionAdmin, handlers.DeleteApplication)).Methods(\"DELETE\")\n\n// Release deletion (alongside existing release endpoints)\nprotectedAPI.HandleFunc(\"/updates/{app_id}/releases/{version}/{platform}/{arch}\",\n    RequirePermission(PermissionAdmin, handlers.DeleteRelease)).Methods(\"DELETE\")\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-design/#error-handling","title":"Error Handling","text":"<p>New conflict error constructor in <code>internal/update/errors.go</code>:</p> <pre><code>func NewConflictError(message string) *ServiceError {\n    return &amp;ServiceError{\n        Code:       models.ErrorCodeConflict,\n        Message:    message,\n        StatusCode: http.StatusConflict,\n    }\n}\n</code></pre> <p>Error mapping:</p> Scenario Error HTTP Status Create app with duplicate ID <code>NewConflictError(\"application already exists\")</code> <code>409</code> Get/update/delete non-existent app <code>NewApplicationNotFoundError(appID)</code> <code>404</code> Delete app with existing releases <code>NewConflictError(\"cannot delete application with existing releases\")</code> <code>409</code> Delete non-existent release <code>NewNotFoundError(\"release not found\")</code> <code>404</code> Invalid request body <code>NewValidationError(...)</code> <code>400</code> Database FK violation Storage maps to <code>NewConflictError</code> <code>409</code>"},{"location":"plans/2026-02-15-application-management-api-design/#testing","title":"Testing","text":"<p>Unit tests (table-driven, co-located):</p> File Coverage <code>internal/update/service_test.go</code> All six new service methods: create (success, duplicate, validation), get (success, not found), list (empty, pagination), update (success, not found, partial), delete app (success, not found, has releases), delete release (success, not found) <code>internal/api/handlers_applications_test.go</code> Handler tests via <code>httptest</code>: status codes, JSON responses, auth/permission enforcement, content-type validation, audit logging <code>internal/models/request_test.go</code> Validation for <code>CreateApplicationRequest</code> and <code>UpdateApplicationRequest</code> <code>internal/storage/memory_test.go</code> <code>DeleteApplication</code>: success, not found <code>internal/storage/json_test.go</code> Same as memory <code>internal/storage/postgres_test.go</code> <code>DeleteApplication</code>: success, FK violation returns typed error <code>internal/storage/sqlite_test.go</code> Same as postgres <p>Integration tests (extend <code>internal/integration/integration_test.go</code>):</p> <ul> <li>Full application lifecycle: create, get, list, update, delete</li> <li>Referential integrity: create app, register release, attempt delete app (expect <code>409</code>), delete release, delete app (expect success)</li> <li>Permission enforcement: read-only key cannot create/update/delete, write key can create but not delete</li> </ul>"},{"location":"plans/2026-02-15-application-management-api-design/#documentation","title":"Documentation","text":"<ul> <li><code>docs/api.md</code> (new) -- Full API reference for all endpoints including existing update endpoints and new application management endpoints. Request/response examples, authentication, error codes.</li> <li><code>docs/ARCHITECTURE.md</code> -- Update endpoint table and architecture overview.</li> <li><code>mkdocs.yml</code> -- Add <code>- API: api.md</code> to nav.</li> </ul>"},{"location":"plans/2026-02-15-application-management-api-implementation/","title":"Application Management API Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add full CRUD HTTP endpoints for managing applications and a delete endpoint for releases, with referential integrity enforcement.</p> <p>Architecture: Extend the existing <code>ServiceInterface</code> with six new methods, add <code>DeleteApplication</code> to the <code>Storage</code> interface, implement across all four backends, create HTTP handlers in a new file, and register routes with appropriate auth/permission middleware. Database schemas get a migration to change FK from <code>CASCADE</code> to <code>RESTRICT</code>.</p> <p>Tech Stack: Go 1.25, gorilla/mux, sqlc, pgx/v5 (PostgreSQL), go-sqlite3 (SQLite), httptest (testing)</p>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-1-add-deleteapplication-to-storage-interface-and-errors","title":"Task 1: Add <code>DeleteApplication</code> to Storage Interface and Errors","text":"<p>Files: - Modify: <code>internal/storage/interface.go:11-43</code> - Create: <code>internal/storage/errors.go</code> - Modify: <code>internal/update/errors.go:28-63</code></p> <p>Step 1: Add <code>DeleteApplication</code> to the Storage interface</p> <p>Add the following method to the <code>Storage</code> interface in <code>internal/storage/interface.go</code>, after the <code>SaveApplication</code> method (line 19):</p> <pre><code>// DeleteApplication removes an application by its ID\nDeleteApplication(ctx context.Context, appID string) error\n</code></pre> <p>Step 2: Create storage sentinel errors</p> <p>Create <code>internal/storage/errors.go</code>:</p> <pre><code>package storage\n\nimport \"errors\"\n\n// ErrHasDependencies indicates a resource cannot be deleted because other resources depend on it.\nvar ErrHasDependencies = errors.New(\"resource has dependent records\")\n</code></pre> <p>Step 3: Add <code>NewConflictError</code> and <code>NewNotFoundError</code> to service errors</p> <p>Add to <code>internal/update/errors.go</code>:</p> <pre><code>func NewConflictError(message string) *ServiceError {\n    return &amp;ServiceError{\n        Code:       models.ErrorCodeConflict,\n        Message:    message,\n        StatusCode: http.StatusConflict,\n    }\n}\n\nfunc NewNotFoundError(message string) *ServiceError {\n    return &amp;ServiceError{\n        Code:       models.ErrorCodeNotFound,\n        Message:    message,\n        StatusCode: http.StatusNotFound,\n    }\n}\n</code></pre> <p>Step 4: Verify compilation</p> <p>Run: <code>go build ./...</code> Expected: Compilation fails because four storage backends and the <code>InstrumentedStorage</code> wrapper do not implement <code>DeleteApplication</code>. This is expected -- we will fix it in the next tasks.</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/interface.go internal/storage/errors.go internal/update/errors.go\ngit commit -m \"feat: add DeleteApplication to Storage interface and error types\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-2-implement-deleteapplication-in-memory-storage","title":"Task 2: Implement <code>DeleteApplication</code> in Memory Storage","text":"<p>Files: - Modify: <code>internal/storage/memory.go</code> - Modify: <code>internal/storage/memory_test.go</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>internal/storage/memory_test.go</code>:</p> <pre><code>func TestMemoryStorage_DeleteApplication(t *testing.T) {\n    tests := []struct {\n        name      string\n        setup     func(t *testing.T, s *MemoryStorage)\n        appID     string\n        wantErr   bool\n        errSubstr string\n    }{\n        {\n            name: \"delete existing application\",\n            setup: func(t *testing.T, s *MemoryStorage) {\n                app := models.NewApplication(\"test-app\", \"Test App\", []string{\"windows\"})\n                err := s.SaveApplication(context.Background(), app)\n                if err != nil {\n                    t.Fatal(err)\n                }\n            },\n            appID:   \"test-app\",\n            wantErr: false,\n        },\n        {\n            name:      \"delete non-existent application\",\n            setup:     func(t *testing.T, s *MemoryStorage) {},\n            appID:     \"non-existent\",\n            wantErr:   true,\n            errSubstr: \"not found\",\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            s, _ := NewMemoryStorage(Config{})\n            tt.setup(t, s)\n\n            err := s.DeleteApplication(context.Background(), tt.appID)\n            if tt.wantErr {\n                if err == nil {\n                    t.Fatal(\"expected error, got nil\")\n                }\n                if tt.errSubstr != \"\" &amp;&amp; !strings.Contains(err.Error(), tt.errSubstr) {\n                    t.Errorf(\"error %q should contain %q\", err.Error(), tt.errSubstr)\n                }\n                return\n            }\n            if err != nil {\n                t.Fatalf(\"unexpected error: %v\", err)\n            }\n\n            // Verify application is gone\n            _, err = s.GetApplication(context.Background(), tt.appID)\n            if err == nil {\n                t.Fatal(\"expected error when getting deleted application\")\n            }\n        })\n    }\n}\n</code></pre> <p>Ensure <code>\"strings\"</code> and <code>\"context\"</code> are in the import list of the test file.</p> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>go test ./internal/storage/ -run TestMemoryStorage_DeleteApplication -v</code> Expected: FAIL -- <code>DeleteApplication</code> method does not exist on <code>MemoryStorage</code>.</p> <p>Step 3: Implement <code>DeleteApplication</code> on <code>MemoryStorage</code></p> <p>Add to <code>internal/storage/memory.go</code>, after the <code>SaveApplication</code> method:</p> <pre><code>// DeleteApplication removes an application by its ID\nfunc (m *MemoryStorage) DeleteApplication(ctx context.Context, appID string) error {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    if _, exists := m.applications[appID]; !exists {\n        return fmt.Errorf(\"application %s not found\", appID)\n    }\n\n    delete(m.applications, appID)\n    return nil\n}\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>go test ./internal/storage/ -run TestMemoryStorage_DeleteApplication -v</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/memory.go internal/storage/memory_test.go\ngit commit -m \"feat: implement DeleteApplication on MemoryStorage\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-3-implement-deleteapplication-in-json-storage","title":"Task 3: Implement <code>DeleteApplication</code> in JSON Storage","text":"<p>Files: - Modify: <code>internal/storage/json.go</code> - Modify: <code>internal/storage/json_test.go</code></p> <p>Step 1: Write the failing test</p> <p>Add to <code>internal/storage/json_test.go</code> a test similar to <code>TestMemoryStorage_DeleteApplication</code> but using <code>NewJSONStorage</code>. Use a temp directory for the JSON file:</p> <pre><code>func TestJSONStorage_DeleteApplication(t *testing.T) {\n    tests := []struct {\n        name      string\n        setup     func(t *testing.T, s *JSONStorage)\n        appID     string\n        wantErr   bool\n        errSubstr string\n    }{\n        {\n            name: \"delete existing application\",\n            setup: func(t *testing.T, s *JSONStorage) {\n                app := models.NewApplication(\"test-app\", \"Test App\", []string{\"windows\"})\n                err := s.SaveApplication(context.Background(), app)\n                if err != nil {\n                    t.Fatal(err)\n                }\n            },\n            appID:   \"test-app\",\n            wantErr: false,\n        },\n        {\n            name:      \"delete non-existent application\",\n            setup:     func(t *testing.T, s *JSONStorage) {},\n            appID:     \"non-existent\",\n            wantErr:   true,\n            errSubstr: \"not found\",\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            tmpDir := t.TempDir()\n            s, err := NewJSONStorage(Config{Path: tmpDir + \"/test.json\"})\n            if err != nil {\n                t.Fatal(err)\n            }\n            defer s.Close()\n            tt.setup(t, s)\n\n            err = s.DeleteApplication(context.Background(), tt.appID)\n            if tt.wantErr {\n                if err == nil {\n                    t.Fatal(\"expected error, got nil\")\n                }\n                if tt.errSubstr != \"\" &amp;&amp; !strings.Contains(err.Error(), tt.errSubstr) {\n                    t.Errorf(\"error %q should contain %q\", err.Error(), tt.errSubstr)\n                }\n                return\n            }\n            if err != nil {\n                t.Fatalf(\"unexpected error: %v\", err)\n            }\n\n            // Verify application is gone\n            _, err = s.GetApplication(context.Background(), tt.appID)\n            if err == nil {\n                t.Fatal(\"expected error when getting deleted application\")\n            }\n        })\n    }\n}\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>go test ./internal/storage/ -run TestJSONStorage_DeleteApplication -v</code> Expected: FAIL</p> <p>Step 3: Implement <code>DeleteApplication</code> on <code>JSONStorage</code></p> <p>Add to <code>internal/storage/json.go</code>, after the <code>SaveApplication</code> method. Follow the existing pattern -- acquire write lock, load data, modify, save:</p> <pre><code>// DeleteApplication removes an application by its ID\nfunc (j *JSONStorage) DeleteApplication(ctx context.Context, appID string) error {\n    j.mu.Lock()\n    defer j.mu.Unlock()\n\n    if err := j.loadData(); err != nil {\n        return fmt.Errorf(\"failed to load data: %w\", err)\n    }\n\n    found := false\n    for i, app := range j.data.Applications {\n        if app.ID == appID {\n            j.data.Applications = append(j.data.Applications[:i], j.data.Applications[i+1:]...)\n            found = true\n            break\n        }\n    }\n\n    if !found {\n        return fmt.Errorf(\"application %s not found\", appID)\n    }\n\n    return j.saveData(j.data)\n}\n</code></pre> <p>Check the <code>JSONData</code> struct and <code>loadData</code>/<code>saveData</code> patterns in <code>json.go</code> to match the exact field names and patterns used.</p> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>go test ./internal/storage/ -run TestJSONStorage_DeleteApplication -v</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/json.go internal/storage/json_test.go\ngit commit -m \"feat: implement DeleteApplication on JSONStorage\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-4-implement-deleteapplication-in-postgresql-and-sqlite-storage","title":"Task 4: Implement <code>DeleteApplication</code> in PostgreSQL and SQLite Storage","text":"<p>Files: - Modify: <code>internal/storage/postgres.go</code> - Modify: <code>internal/storage/sqlite.go</code> - Modify: <code>internal/storage/postgres_test.go</code> - Modify: <code>internal/storage/sqlite_test.go</code></p> <p>Important context: The sqlc-generated <code>DeleteApplication</code> method already exists in both <code>internal/storage/sqlc/postgres/applications.sql.go</code> and <code>internal/storage/sqlc/sqlite/applications.sql.go</code>. The existing schemas already have <code>FOREIGN KEY (application_id) REFERENCES applications(id) ON DELETE CASCADE</code>.</p> <p>Step 1: Implement <code>DeleteApplication</code> on <code>PostgresStorage</code></p> <p>Add to <code>internal/storage/postgres.go</code>, after the <code>SaveApplication</code> method:</p> <pre><code>// DeleteApplication removes an application by its ID.\nfunc (ps *PostgresStorage) DeleteApplication(ctx context.Context, appID string) error {\n    err := ps.queries.DeleteApplication(ctx, appID)\n    if err != nil {\n        return fmt.Errorf(\"failed to delete application %s: %w\", appID, err)\n    }\n    return nil\n}\n</code></pre> <p>Step 2: Implement <code>DeleteApplication</code> on <code>SQLiteStorage</code></p> <p>Add to <code>internal/storage/sqlite.go</code>, after the <code>SaveApplication</code> method:</p> <pre><code>// DeleteApplication removes an application by its ID.\nfunc (ss *SQLiteStorage) DeleteApplication(ctx context.Context, appID string) error {\n    err := ss.queries.DeleteApplication(ctx, appID)\n    if err != nil {\n        return fmt.Errorf(\"failed to delete application %s: %w\", appID, err)\n    }\n    return nil\n}\n</code></pre> <p>Check the exact query method signature in the generated sqlc code to ensure the parameter type matches (should be <code>string</code>).</p> <p>Step 3: Add tests for both backends</p> <p>Add tests to <code>internal/storage/postgres_test.go</code> and <code>internal/storage/sqlite_test.go</code> if database test infrastructure exists. If these tests require a running database, add a <code>t.Skip</code> guard:</p> <pre><code>func TestPostgresStorage_DeleteApplication(t *testing.T) {\n    // Skip if no database available\n    connStr := os.Getenv(\"TEST_POSTGRES_URL\")\n    if connStr == \"\" {\n        t.Skip(\"TEST_POSTGRES_URL not set, skipping PostgreSQL tests\")\n    }\n    // ... test implementation similar to memory test\n}\n</code></pre> <p>Step 4: Verify compilation</p> <p>Run: <code>go build ./...</code> Expected: Still fails because <code>InstrumentedStorage</code> does not implement <code>DeleteApplication</code>.</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/postgres.go internal/storage/sqlite.go internal/storage/postgres_test.go internal/storage/sqlite_test.go\ngit commit -m \"feat: implement DeleteApplication on PostgreSQL and SQLite storage\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-5-implement-deleteapplication-on-instrumentedstorage","title":"Task 5: Implement <code>DeleteApplication</code> on InstrumentedStorage","text":"<p>Files: - Modify: <code>internal/observability/storage.go</code> - Modify: <code>internal/observability/storage_test.go</code></p> <p>Step 1: Add <code>DeleteApplication</code> to <code>InstrumentedStorage</code></p> <p>Add to <code>internal/observability/storage.go</code>, after the <code>SaveApplication</code> method (follow the exact same tracing pattern as the other methods):</p> <pre><code>func (s *InstrumentedStorage) DeleteApplication(ctx context.Context, appID string) error {\n    ctx, span := s.startSpan(ctx, \"DeleteApplication\",\n        attribute.String(\"app_id\", appID),\n    )\n    start := time.Now()\n    err := s.wrapped.DeleteApplication(ctx, appID)\n    s.record(ctx, span, \"DeleteApplication\", start, err)\n    return err\n}\n</code></pre> <p>Check the exact import for <code>attribute</code> and match the pattern used by the existing methods in the file.</p> <p>Step 2: Verify compilation succeeds</p> <p>Run: <code>go build ./...</code> Expected: SUCCESS -- all implementations of <code>Storage</code> interface now include <code>DeleteApplication</code>.</p> <p>Step 3: Run all tests</p> <p>Run: <code>go test ./...</code> Expected: All existing tests pass.</p> <p>Step 4: Commit</p> <pre><code>git add internal/observability/storage.go internal/observability/storage_test.go\ngit commit -m \"feat: add DeleteApplication to InstrumentedStorage wrapper\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-6-add-database-migration-for-fk-restrict","title":"Task 6: Add Database Migration for FK RESTRICT","text":"<p>Files: - Create: <code>internal/storage/sqlc/schema/postgres/003_fk_restrict.sql</code> - Create: <code>internal/storage/sqlc/schema/sqlite/003_fk_restrict.sql</code></p> <p>Important context: The existing schemas use <code>ON DELETE CASCADE</code>. The approved design requires <code>ON DELETE RESTRICT</code> so that deleting an application with existing releases is rejected by the database.</p> <p>Step 1: Create PostgreSQL migration</p> <p>Create <code>internal/storage/sqlc/schema/postgres/003_fk_restrict.sql</code>:</p> <pre><code>-- Change releases FK from CASCADE to RESTRICT\n-- This prevents deleting an application that still has releases\nALTER TABLE releases DROP CONSTRAINT releases_application_id_fkey;\nALTER TABLE releases ADD CONSTRAINT releases_application_id_fkey\n    FOREIGN KEY (application_id) REFERENCES applications(id) ON DELETE RESTRICT;\n</code></pre> <p>Note: Check the exact constraint name by looking at the PostgreSQL default naming convention or the <code>001_initial.sql</code>. The default name for an unnamed FK in PostgreSQL is <code>{table}_{column}_fkey</code>.</p> <p>Step 2: Create SQLite migration</p> <p>SQLite does not support <code>ALTER TABLE ... DROP CONSTRAINT</code>. For SQLite, the FK behavior is enforced at the application level (the service checks for releases before deleting). Create a placeholder migration:</p> <p>Create <code>internal/storage/sqlc/schema/sqlite/003_fk_restrict.sql</code>:</p> <pre><code>-- SQLite does not support altering FK constraints.\n-- Referential integrity for DeleteApplication is enforced at the service layer.\n-- This file exists for migration numbering parity with PostgreSQL.\n</code></pre> <p>Step 3: Regenerate sqlc code</p> <p>Run: <code>sqlc generate</code> Expected: Code regenerates successfully. The generated Go code should not change since the queries are the same.</p> <p>Step 4: Verify compilation and tests</p> <p>Run: <code>go build ./... &amp;&amp; go test ./...</code> Expected: All pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/sqlc/\ngit commit -m \"feat: add migration to change FK from CASCADE to RESTRICT\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-7-add-application-crud-methods-to-service","title":"Task 7: Add Application CRUD Methods to Service","text":"<p>Files: - Modify: <code>internal/update/interface.go</code> - Modify: <code>internal/update/service.go</code> - Modify: <code>internal/update/service_test.go</code></p> <p>Step 1: Write failing tests for <code>CreateApplication</code></p> <p>Add to <code>internal/update/service_test.go</code>:</p> <pre><code>func TestService_CreateApplication(t *testing.T) {\n    tests := []struct {\n        name      string\n        setup     func(t *testing.T, s storage.Storage)\n        req       *models.CreateApplicationRequest\n        wantErr   bool\n        wantCode  int\n    }{\n        {\n            name:  \"create valid application\",\n            setup: func(t *testing.T, s storage.Storage) {},\n            req: &amp;models.CreateApplicationRequest{\n                ID:        \"my-app\",\n                Name:      \"My App\",\n                Platforms: []string{\"windows\", \"linux\"},\n            },\n            wantErr: false,\n        },\n        {\n            name: \"create duplicate application\",\n            setup: func(t *testing.T, s storage.Storage) {\n                app := models.NewApplication(\"my-app\", \"Existing App\", []string{\"windows\"})\n                s.SaveApplication(context.Background(), app)\n            },\n            req: &amp;models.CreateApplicationRequest{\n                ID:        \"my-app\",\n                Name:      \"My App\",\n                Platforms: []string{\"windows\"},\n            },\n            wantErr:  true,\n            wantCode: http.StatusConflict,\n        },\n        {\n            name:  \"create with invalid request - missing name\",\n            setup: func(t *testing.T, s storage.Storage) {},\n            req: &amp;models.CreateApplicationRequest{\n                ID:        \"my-app\",\n                Name:      \"\",\n                Platforms: []string{\"windows\"},\n            },\n            wantErr:  true,\n            wantCode: http.StatusUnprocessableEntity,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            store, _ := storage.NewMemoryStorage(storage.Config{})\n            tt.setup(t, store)\n            svc := NewService(store)\n\n            resp, err := svc.CreateApplication(context.Background(), tt.req)\n            if tt.wantErr {\n                if err == nil {\n                    t.Fatal(\"expected error, got nil\")\n                }\n                var svcErr *ServiceError\n                if errors.As(err, &amp;svcErr) &amp;&amp; tt.wantCode != 0 {\n                    if svcErr.StatusCode != tt.wantCode {\n                        t.Errorf(\"expected status %d, got %d\", tt.wantCode, svcErr.StatusCode)\n                    }\n                }\n                return\n            }\n            if err != nil {\n                t.Fatalf(\"unexpected error: %v\", err)\n            }\n            if resp.ID != tt.req.ID {\n                t.Errorf(\"expected ID %q, got %q\", tt.req.ID, resp.ID)\n            }\n        })\n    }\n}\n</code></pre> <p>Step 2: Write failing tests for remaining methods</p> <p>Add similar table-driven tests for: - <code>TestService_GetApplication</code> -- success, not found - <code>TestService_ListApplications</code> -- empty list, multiple apps, pagination - <code>TestService_UpdateApplication</code> -- success, not found, partial update (only name) - <code>TestService_DeleteApplication</code> -- success, not found, has releases (expect conflict) - <code>TestService_DeleteRelease</code> -- success, not found</p> <p>Each test should follow the same pattern: create memory storage, setup test data, call service method, assert result.</p> <p>For <code>DeleteApplication</code> with releases, the test should: 1. Save an application 2. Save a release for that application 3. Call <code>DeleteApplication</code> 4. Assert error is <code>409 Conflict</code></p> <p>Step 3: Run tests to verify they fail</p> <p>Run: <code>go test ./internal/update/ -run \"TestService_(Create|Get|List|Update|Delete)\" -v</code> Expected: FAIL -- methods do not exist on <code>Service</code>.</p> <p>Step 4: Extend <code>ServiceInterface</code></p> <p>Update <code>internal/update/interface.go</code> to add the new methods:</p> <pre><code>type ServiceInterface interface {\n    CheckForUpdate(ctx context.Context, req *models.UpdateCheckRequest) (*models.UpdateCheckResponse, error)\n    GetLatestVersion(ctx context.Context, req *models.LatestVersionRequest) (*models.LatestVersionResponse, error)\n    ListReleases(ctx context.Context, req *models.ListReleasesRequest) (*models.ListReleasesResponse, error)\n    RegisterRelease(ctx context.Context, req *models.RegisterReleaseRequest) (*models.RegisterReleaseResponse, error)\n\n    CreateApplication(ctx context.Context, req *models.CreateApplicationRequest) (*models.CreateApplicationResponse, error)\n    GetApplication(ctx context.Context, appID string) (*models.ApplicationInfoResponse, error)\n    ListApplications(ctx context.Context, limit, offset int) (*models.ListApplicationsResponse, error)\n    UpdateApplication(ctx context.Context, appID string, req *models.UpdateApplicationRequest) (*models.UpdateApplicationResponse, error)\n    DeleteApplication(ctx context.Context, appID string) error\n    DeleteRelease(ctx context.Context, req *models.DeleteReleaseRequest) (*models.DeleteReleaseResponse, error)\n}\n</code></pre> <p>Step 5: Implement all six methods on <code>Service</code></p> <p>Add to <code>internal/update/service.go</code>. Key implementations:</p> <p>CreateApplication: <pre><code>func (s *Service) CreateApplication(ctx context.Context, req *models.CreateApplicationRequest) (*models.CreateApplicationResponse, error) {\n    if err := req.Validate(); err != nil {\n        return nil, NewValidationError(\"invalid request\", err)\n    }\n    req.Normalize()\n\n    // Check for duplicate\n    existing, err := s.storage.GetApplication(ctx, req.ID)\n    if err == nil &amp;&amp; existing != nil {\n        return nil, NewConflictError(fmt.Sprintf(\"application '%s' already exists\", req.ID))\n    }\n\n    app := models.NewApplication(req.ID, req.Name, req.Platforms)\n    app.Description = req.Description\n    app.Config = req.Config\n    now := time.Now()\n    app.CreatedAt = now.Format(time.RFC3339)\n    app.UpdatedAt = now.Format(time.RFC3339)\n\n    if err := s.storage.SaveApplication(ctx, app); err != nil {\n        return nil, NewInternalError(\"failed to save application\", err)\n    }\n\n    return &amp;models.CreateApplicationResponse{\n        ID:        app.ID,\n        Message:   fmt.Sprintf(\"Application '%s' created successfully\", app.Name),\n        CreatedAt: now,\n    }, nil\n}\n</code></pre></p> <p>GetApplication: <pre><code>func (s *Service) GetApplication(ctx context.Context, appID string) (*models.ApplicationInfoResponse, error) {\n    app, err := s.storage.GetApplication(ctx, appID)\n    if err != nil {\n        return nil, NewApplicationNotFoundError(appID)\n    }\n\n    // Compute stats\n    releases, err := s.storage.Releases(ctx, appID)\n    if err != nil {\n        return nil, NewInternalError(\"failed to get releases\", err)\n    }\n\n    stats := models.ApplicationStats{\n        TotalReleases: len(releases),\n    }\n\n    platforms := make(map[string]bool)\n    var latestRelease *models.Release\n    requiredCount := 0\n    for _, r := range releases {\n        platforms[r.Platform] = true\n        if r.Required {\n            requiredCount++\n        }\n        if latestRelease == nil {\n            latestRelease = r\n            continue\n        }\n        latestVer, err1 := semver.NewVersion(latestRelease.Version)\n        releaseVer, err2 := semver.NewVersion(r.Version)\n        if err1 == nil &amp;&amp; err2 == nil &amp;&amp; releaseVer.GreaterThan(latestVer) {\n            latestRelease = r\n        }\n    }\n    stats.PlatformCount = len(platforms)\n    stats.RequiredReleases = requiredCount\n    if latestRelease != nil {\n        stats.LatestVersion = latestRelease.Version\n        stats.LatestReleaseDate = &amp;latestRelease.ReleaseDate\n    }\n\n    // Parse timestamps\n    createdAt, _ := time.Parse(time.RFC3339, app.CreatedAt)\n    updatedAt, _ := time.Parse(time.RFC3339, app.UpdatedAt)\n\n    return &amp;models.ApplicationInfoResponse{\n        ID:          app.ID,\n        Name:        app.Name,\n        Description: app.Description,\n        Platforms:   app.Platforms,\n        Config:      app.Config,\n        Stats:       stats,\n        CreatedAt:   createdAt,\n        UpdatedAt:   updatedAt,\n    }, nil\n}\n</code></pre></p> <p>ListApplications: <pre><code>func (s *Service) ListApplications(ctx context.Context, limit, offset int) (*models.ListApplicationsResponse, error) {\n    if limit &lt;= 0 {\n        limit = 50\n    }\n    if offset &lt; 0 {\n        offset = 0\n    }\n\n    allApps, err := s.storage.Applications(ctx)\n    if err != nil {\n        return nil, NewInternalError(\"failed to get applications\", err)\n    }\n\n    totalCount := len(allApps)\n    start := offset\n    end := start + limit\n    if start &gt; totalCount {\n        start = totalCount\n    }\n    if end &gt; totalCount {\n        end = totalCount\n    }\n\n    paginatedApps := allApps[start:end]\n    summaries := make([]models.ApplicationSummary, len(paginatedApps))\n    for i, app := range paginatedApps {\n        summaries[i].FromApplication(app)\n        createdAt, _ := time.Parse(time.RFC3339, app.CreatedAt)\n        updatedAt, _ := time.Parse(time.RFC3339, app.UpdatedAt)\n        summaries[i].CreatedAt = createdAt\n        summaries[i].UpdatedAt = updatedAt\n    }\n\n    return &amp;models.ListApplicationsResponse{\n        Applications: summaries,\n        TotalCount:   totalCount,\n        Page:         (offset / limit) + 1,\n        PageSize:     limit,\n        HasMore:      end &lt; totalCount,\n    }, nil\n}\n</code></pre></p> <p>UpdateApplication: <pre><code>func (s *Service) UpdateApplication(ctx context.Context, appID string, req *models.UpdateApplicationRequest) (*models.UpdateApplicationResponse, error) {\n    if err := req.Validate(); err != nil {\n        return nil, NewValidationError(\"invalid request\", err)\n    }\n    req.Normalize()\n\n    app, err := s.storage.GetApplication(ctx, appID)\n    if err != nil {\n        return nil, NewApplicationNotFoundError(appID)\n    }\n\n    // Apply partial updates\n    if req.Name != nil {\n        app.Name = *req.Name\n    }\n    if req.Description != nil {\n        app.Description = *req.Description\n    }\n    if req.Platforms != nil {\n        app.Platforms = req.Platforms\n    }\n    if req.Config != nil {\n        app.Config = *req.Config\n    }\n    now := time.Now()\n    app.UpdatedAt = now.Format(time.RFC3339)\n\n    if err := s.storage.SaveApplication(ctx, app); err != nil {\n        return nil, NewInternalError(\"failed to update application\", err)\n    }\n\n    return &amp;models.UpdateApplicationResponse{\n        ID:        app.ID,\n        Message:   fmt.Sprintf(\"Application '%s' updated successfully\", app.Name),\n        UpdatedAt: now,\n    }, nil\n}\n</code></pre></p> <p>DeleteApplication: <pre><code>func (s *Service) DeleteApplication(ctx context.Context, appID string) error {\n    // Verify application exists\n    _, err := s.storage.GetApplication(ctx, appID)\n    if err != nil {\n        return NewApplicationNotFoundError(appID)\n    }\n\n    // Check for existing releases (service-layer enforcement for memory/JSON backends)\n    releases, err := s.storage.Releases(ctx, appID)\n    if err != nil {\n        return NewInternalError(\"failed to check releases\", err)\n    }\n    if len(releases) &gt; 0 {\n        return NewConflictError(fmt.Sprintf(\"cannot delete application '%s': has %d existing releases\", appID, len(releases)))\n    }\n\n    // Attempt delete (database backends enforce FK RESTRICT as a second layer)\n    if err := s.storage.DeleteApplication(ctx, appID); err != nil {\n        if errors.Is(err, storage.ErrHasDependencies) {\n            return NewConflictError(fmt.Sprintf(\"cannot delete application '%s': has existing releases\", appID))\n        }\n        return NewInternalError(\"failed to delete application\", err)\n    }\n\n    return nil\n}\n</code></pre></p> <p>DeleteRelease: <pre><code>func (s *Service) DeleteRelease(ctx context.Context, req *models.DeleteReleaseRequest) (*models.DeleteReleaseResponse, error) {\n    // Verify the release exists\n    release, err := s.storage.GetRelease(ctx, req.ApplicationID, req.ReleaseID, \"\", \"\")\n    if err != nil {\n        // The DeleteReleaseRequest uses ReleaseID but storage uses version/platform/arch compound key.\n        // We need to reconsider how to identify releases for deletion.\n        return nil, NewNotFoundError(fmt.Sprintf(\"release not found: %s\", req.ReleaseID))\n    }\n\n    if err := s.storage.DeleteRelease(ctx, release.ApplicationID, release.Version, release.Platform, release.Architecture); err != nil {\n        return nil, NewInternalError(\"failed to delete release\", err)\n    }\n\n    return &amp;models.DeleteReleaseResponse{\n        ID:      release.ID,\n        Message: fmt.Sprintf(\"Release %s deleted successfully\", release.Version),\n    }, nil\n}\n</code></pre></p> <p>Important: The <code>DeleteReleaseRequest</code> model uses <code>ApplicationID</code> and <code>ReleaseID</code>, but the storage <code>DeleteRelease</code> method uses <code>appID, version, platform, arch</code>. The HTTP handler will extract these from the URL path (<code>{version}/{platform}/{arch}</code>) and call storage directly. Adjust the service method to accept the compound key instead:</p> <pre><code>func (s *Service) DeleteRelease(ctx context.Context, appID, version, platform, arch string) (*models.DeleteReleaseResponse, error) {\n    // Verify the release exists\n    release, err := s.storage.GetRelease(ctx, appID, version, platform, arch)\n    if err != nil {\n        return nil, NewNotFoundError(fmt.Sprintf(\"release not found: %s@%s-%s-%s\", appID, version, platform, arch))\n    }\n\n    if err := s.storage.DeleteRelease(ctx, appID, version, platform, arch); err != nil {\n        return nil, NewInternalError(\"failed to delete release\", err)\n    }\n\n    return &amp;models.DeleteReleaseResponse{\n        ID:      release.ID,\n        Message: fmt.Sprintf(\"Release %s for %s-%s deleted successfully\", version, platform, arch),\n    }, nil\n}\n</code></pre> <p>Update <code>ServiceInterface</code> accordingly -- change <code>DeleteRelease</code> signature to use the compound key.</p> <p>Add <code>\"time\"</code> and <code>\"errors\"</code> to the imports in <code>service.go</code>. Add <code>\"updater/internal/storage\"</code> for the <code>ErrHasDependencies</code> sentinel.</p> <p>Step 6: Run tests to verify they pass</p> <p>Run: <code>go test ./internal/update/ -v</code> Expected: All tests pass.</p> <p>Step 7: Commit</p> <pre><code>git add internal/update/interface.go internal/update/service.go internal/update/service_test.go\ngit commit -m \"feat: add application CRUD and delete release to service layer\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-8-create-application-management-http-handlers","title":"Task 8: Create Application Management HTTP Handlers","text":"<p>Files: - Create: <code>internal/api/handlers_applications.go</code> - Create: <code>internal/api/handlers_applications_test.go</code></p> <p>Step 1: Write failing handler tests</p> <p>Create <code>internal/api/handlers_applications_test.go</code> with tests for each handler. Use <code>httptest.NewRecorder</code> and a real <code>Handlers</code> instance with memory storage. Pattern:</p> <pre><code>func TestHandlers_CreateApplication(t *testing.T) {\n    store, _ := storage.NewMemoryStorage(storage.Config{})\n    svc := update.NewService(store)\n    h := NewHandlers(svc, WithStorage(store))\n\n    tests := []struct {\n        name       string\n        body       string\n        wantStatus int\n    }{\n        {\n            name:       \"valid create\",\n            body:       `{\"id\":\"test-app\",\"name\":\"Test App\",\"platforms\":[\"windows\"]}`,\n            wantStatus: http.StatusCreated,\n        },\n        {\n            name:       \"invalid json\",\n            body:       `{invalid`,\n            wantStatus: http.StatusBadRequest,\n        },\n        {\n            name:       \"missing required field\",\n            body:       `{\"id\":\"test-app\",\"name\":\"\",\"platforms\":[\"windows\"]}`,\n            wantStatus: http.StatusUnprocessableEntity,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            req := httptest.NewRequest(\"POST\", \"/api/v1/applications\", strings.NewReader(tt.body))\n            req.Header.Set(\"Content-Type\", \"application/json\")\n            w := httptest.NewRecorder()\n\n            h.CreateApplication(w, req)\n\n            if w.Code != tt.wantStatus {\n                t.Errorf(\"expected status %d, got %d: %s\", tt.wantStatus, w.Code, w.Body.String())\n            }\n        })\n    }\n}\n</code></pre> <p>Add similar tests for <code>GetApplication</code>, <code>ListApplications</code>, <code>UpdateApplication</code>, <code>DeleteApplication</code>, and <code>DeleteRelease</code>. For path variable tests, use <code>mux.SetURLVars</code> to inject route variables:</p> <pre><code>req = mux.SetURLVars(req, map[string]string{\"app_id\": \"test-app\"})\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>go test ./internal/api/ -run \"TestHandlers_(Create|Get|List|Update|Delete)Application\" -v</code> Expected: FAIL -- handler methods do not exist.</p> <p>Step 3: Implement handlers</p> <p>Create <code>internal/api/handlers_applications.go</code>:</p> <pre><code>package api\n\nimport (\n    \"encoding/json\"\n    \"log/slog\"\n    \"net/http\"\n    \"strconv\"\n    \"strings\"\n    \"updater/internal/models\"\n\n    \"github.com/gorilla/mux\"\n)\n\n// CreateApplication handles application creation requests\n// POST /api/v1/applications\nfunc (h *Handlers) CreateApplication(w http.ResponseWriter, r *http.Request) {\n    securityContext := GetSecurityContext(r)\n\n    slog.Warn(\"Application creation attempt\",\n        \"event\", \"security_audit\",\n        \"api_key\", getAPIKeyName(securityContext),\n        \"client_ip\", getClientIP(r))\n\n    contentType := r.Header.Get(\"Content-Type\")\n    if contentType == \"\" || !strings.HasPrefix(contentType, \"application/json\") {\n        h.writeErrorResponse(w, http.StatusUnsupportedMediaType, models.ErrorCodeBadRequest, \"Content-Type must be application/json\")\n        return\n    }\n\n    var req models.CreateApplicationRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        h.writeErrorResponse(w, http.StatusBadRequest, models.ErrorCodeInvalidRequest, \"Invalid JSON body\")\n        return\n    }\n\n    response, err := h.updateService.CreateApplication(r.Context(), &amp;req)\n    if err != nil {\n        slog.Warn(\"Application creation failed\",\n            \"event\", \"security_audit\",\n            \"app_id\", req.ID,\n            \"api_key\", getAPIKeyName(securityContext),\n            \"error\", err.Error())\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    slog.Info(\"Application created successfully\",\n        \"event\", \"security_audit\",\n        \"app_id\", req.ID,\n        \"api_key\", getAPIKeyName(securityContext))\n\n    h.writeJSONResponse(w, http.StatusCreated, response)\n}\n\n// GetApplication handles application retrieval requests\n// GET /api/v1/applications/{app_id}\nfunc (h *Handlers) GetApplication(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    appID := vars[\"app_id\"]\n\n    response, err := h.updateService.GetApplication(r.Context(), appID)\n    if err != nil {\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    h.writeJSONResponse(w, http.StatusOK, response)\n}\n\n// ListApplications handles application listing requests\n// GET /api/v1/applications\nfunc (h *Handlers) ListApplications(w http.ResponseWriter, r *http.Request) {\n    limit := 50\n    offset := 0\n\n    if limitParam := r.URL.Query().Get(\"limit\"); limitParam != \"\" {\n        if l, err := strconv.Atoi(limitParam); err == nil &amp;&amp; l &gt; 0 {\n            limit = l\n        }\n    }\n\n    if offsetParam := r.URL.Query().Get(\"offset\"); offsetParam != \"\" {\n        if o, err := strconv.Atoi(offsetParam); err == nil &amp;&amp; o &gt;= 0 {\n            offset = o\n        }\n    }\n\n    response, err := h.updateService.ListApplications(r.Context(), limit, offset)\n    if err != nil {\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    h.writeJSONResponse(w, http.StatusOK, response)\n}\n\n// UpdateApplication handles application update requests\n// PUT /api/v1/applications/{app_id}\nfunc (h *Handlers) UpdateApplication(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    appID := vars[\"app_id\"]\n\n    securityContext := GetSecurityContext(r)\n\n    slog.Warn(\"Application update attempt\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"api_key\", getAPIKeyName(securityContext),\n        \"client_ip\", getClientIP(r))\n\n    contentType := r.Header.Get(\"Content-Type\")\n    if contentType == \"\" || !strings.HasPrefix(contentType, \"application/json\") {\n        h.writeErrorResponse(w, http.StatusUnsupportedMediaType, models.ErrorCodeBadRequest, \"Content-Type must be application/json\")\n        return\n    }\n\n    var req models.UpdateApplicationRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        h.writeErrorResponse(w, http.StatusBadRequest, models.ErrorCodeInvalidRequest, \"Invalid JSON body\")\n        return\n    }\n\n    response, err := h.updateService.UpdateApplication(r.Context(), appID, &amp;req)\n    if err != nil {\n        slog.Warn(\"Application update failed\",\n            \"event\", \"security_audit\",\n            \"app_id\", appID,\n            \"api_key\", getAPIKeyName(securityContext),\n            \"error\", err.Error())\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    slog.Info(\"Application updated successfully\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"api_key\", getAPIKeyName(securityContext))\n\n    h.writeJSONResponse(w, http.StatusOK, response)\n}\n\n// DeleteApplication handles application deletion requests\n// DELETE /api/v1/applications/{app_id}\nfunc (h *Handlers) DeleteApplication(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    appID := vars[\"app_id\"]\n\n    securityContext := GetSecurityContext(r)\n\n    slog.Warn(\"Application deletion attempt\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"api_key\", getAPIKeyName(securityContext),\n        \"client_ip\", getClientIP(r))\n\n    err := h.updateService.DeleteApplication(r.Context(), appID)\n    if err != nil {\n        slog.Warn(\"Application deletion failed\",\n            \"event\", \"security_audit\",\n            \"app_id\", appID,\n            \"api_key\", getAPIKeyName(securityContext),\n            \"error\", err.Error())\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    slog.Info(\"Application deleted successfully\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"api_key\", getAPIKeyName(securityContext))\n\n    w.WriteHeader(http.StatusNoContent)\n}\n\n// DeleteRelease handles release deletion requests\n// DELETE /api/v1/updates/{app_id}/releases/{version}/{platform}/{arch}\nfunc (h *Handlers) DeleteRelease(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    appID := vars[\"app_id\"]\n    version := vars[\"version\"]\n    platform := vars[\"platform\"]\n    arch := vars[\"arch\"]\n\n    securityContext := GetSecurityContext(r)\n\n    slog.Warn(\"Release deletion attempt\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"version\", version,\n        \"platform\", platform,\n        \"architecture\", arch,\n        \"api_key\", getAPIKeyName(securityContext),\n        \"client_ip\", getClientIP(r))\n\n    response, err := h.updateService.DeleteRelease(r.Context(), appID, version, platform, arch)\n    if err != nil {\n        slog.Warn(\"Release deletion failed\",\n            \"event\", \"security_audit\",\n            \"app_id\", appID,\n            \"version\", version,\n            \"api_key\", getAPIKeyName(securityContext),\n            \"error\", err.Error())\n        h.writeServiceErrorResponse(w, err)\n        return\n    }\n\n    slog.Info(\"Release deleted successfully\",\n        \"event\", \"security_audit\",\n        \"app_id\", appID,\n        \"version\", version,\n        \"api_key\", getAPIKeyName(securityContext))\n\n    h.writeJSONResponse(w, http.StatusOK, response)\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>go test ./internal/api/ -run \"TestHandlers_(Create|Get|List|Update|Delete)\" -v</code> Expected: All pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_applications.go internal/api/handlers_applications_test.go\ngit commit -m \"feat: add application management and release deletion HTTP handlers\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-9-register-routes","title":"Task 9: Register Routes","text":"<p>Files: - Modify: <code>internal/api/routes.go:31-103</code></p> <p>Step 1: Add application management routes</p> <p>In the <code>SetupRoutes</code> function in <code>internal/api/routes.go</code>, add the application management endpoints. Add them inside the <code>if config.Security.EnableAuth</code> block, following the existing pattern of creating subrouters with middleware:</p> <p>Inside the <code>if config.Security.EnableAuth</code> block, after the existing <code>writeAPI</code> routes:</p> <pre><code>// Application management endpoints (read permission)\nappReadAPI := api.PathPrefix(\"/applications\").Subrouter()\nappReadAPI.Use(authMiddleware(config.Security))\nappReadAPI.Use(RequirePermission(PermissionRead))\nappReadAPI.HandleFunc(\"\", handlers.ListApplications).Methods(\"GET\")\nappReadAPI.HandleFunc(\"/{app_id}\", handlers.GetApplication).Methods(\"GET\")\n\n// Application management endpoints (write permission)\nappWriteAPI := api.PathPrefix(\"/applications\").Subrouter()\nappWriteAPI.Use(authMiddleware(config.Security))\nappWriteAPI.Use(RequirePermission(PermissionWrite))\nappWriteAPI.HandleFunc(\"\", handlers.CreateApplication).Methods(\"POST\")\n\n// Application management endpoints (admin permission)\nappAdminAPI := api.PathPrefix(\"/applications\").Subrouter()\nappAdminAPI.Use(authMiddleware(config.Security))\nappAdminAPI.Use(RequirePermission(PermissionAdmin))\nappAdminAPI.HandleFunc(\"/{app_id}\", handlers.UpdateApplication).Methods(\"PUT\")\nappAdminAPI.HandleFunc(\"/{app_id}\", handlers.DeleteApplication).Methods(\"DELETE\")\n\n// Release deletion (admin permission)\nadminAPI := api.PathPrefix(\"\").Subrouter()\nadminAPI.Use(authMiddleware(config.Security))\nadminAPI.Use(RequirePermission(PermissionAdmin))\nadminAPI.HandleFunc(\"/updates/{app_id}/releases/{version}/{platform}/{arch}\", handlers.DeleteRelease).Methods(\"DELETE\")\n</code></pre> <p>In the <code>else</code> block (auth disabled), add unprotected equivalents:</p> <pre><code>api.HandleFunc(\"/applications\", handlers.ListApplications).Methods(\"GET\")\napi.HandleFunc(\"/applications/{app_id}\", handlers.GetApplication).Methods(\"GET\")\napi.HandleFunc(\"/applications\", handlers.CreateApplication).Methods(\"POST\")\napi.HandleFunc(\"/applications/{app_id}\", handlers.UpdateApplication).Methods(\"PUT\")\napi.HandleFunc(\"/applications/{app_id}\", handlers.DeleteApplication).Methods(\"DELETE\")\napi.HandleFunc(\"/updates/{app_id}/releases/{version}/{platform}/{arch}\", handlers.DeleteRelease).Methods(\"DELETE\")\n</code></pre> <p>Also add the new targets to the <code>.PHONY</code> declaration at the top of <code>routes.go</code> if applicable (note: this is Go, not Make, so just ensure correct imports).</p> <p>Step 2: Run all tests</p> <p>Run: <code>go test ./...</code> Expected: All tests pass.</p> <p>Step 3: Commit</p> <pre><code>git add internal/api/routes.go\ngit commit -m \"feat: register application management and release deletion routes\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-10-add-integration-tests","title":"Task 10: Add Integration Tests","text":"<p>Files: - Modify: <code>internal/integration/integration_test.go</code></p> <p>Step 1: Read the existing integration test file</p> <p>Read <code>internal/integration/integration_test.go</code> to understand the setup pattern (how the server is created, how requests are made, how auth headers are set).</p> <p>Step 2: Add application lifecycle integration test</p> <pre><code>func TestApplicationLifecycle(t *testing.T) {\n    // Use the existing test setup pattern from the file\n    // Create app -&gt; Get app -&gt; List apps -&gt; Update app -&gt; Delete app\n\n    // 1. Create application\n    // POST /api/v1/applications with write auth\n    // Assert 201\n\n    // 2. Get application\n    // GET /api/v1/applications/test-app with read auth\n    // Assert 200, verify fields\n\n    // 3. List applications\n    // GET /api/v1/applications with read auth\n    // Assert 200, verify test-app in list\n\n    // 4. Update application\n    // PUT /api/v1/applications/test-app with admin auth\n    // Assert 200\n\n    // 5. Delete application\n    // DELETE /api/v1/applications/test-app with admin auth\n    // Assert 204\n\n    // 6. Verify deleted\n    // GET /api/v1/applications/test-app with read auth\n    // Assert 404\n}\n</code></pre> <p>Step 3: Add referential integrity integration test</p> <pre><code>func TestDeleteApplicationWithReleases(t *testing.T) {\n    // 1. Create application\n    // 2. Register a release for it\n    // 3. Try to delete the application -&gt; expect 409\n    // 4. Delete the release\n    // 5. Delete the application -&gt; expect 204\n}\n</code></pre> <p>Step 4: Run integration tests</p> <p>Run: <code>go test ./internal/integration/ -v</code> Expected: All pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/integration/integration_test.go\ngit commit -m \"test: add application lifecycle and referential integrity integration tests\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-11-write-documentation","title":"Task 11: Write Documentation","text":"<p>Files: - Create: <code>docs/api.md</code> - Modify: <code>mkdocs.yml</code> - Modify: <code>docs/ARCHITECTURE.md</code></p> <p>Step 1: Create API documentation</p> <p>Create <code>docs/api.md</code> with: - Overview of all endpoints (existing update endpoints + new application management endpoints) - Authentication and permissions table - Request/response examples for each endpoint (use JSON code blocks) - Error codes and their meanings - Endpoint flow diagrams using mermaid</p> <p>Step 2: Update mkdocs nav</p> <p>Add <code>- API: api.md</code> to the nav in <code>mkdocs.yml</code>, after \"Use Cases\" and before \"Architecture\".</p> <p>Step 3: Update architecture docs</p> <p>Update the endpoint table in <code>docs/ARCHITECTURE.md</code> to include the new application management endpoints and delete release endpoint.</p> <p>Step 4: Verify docs build</p> <p>Run: <code>make docs-build</code> Expected: MkDocs builds successfully with the new page.</p> <p>Step 5: Commit</p> <pre><code>git add docs/api.md mkdocs.yml docs/ARCHITECTURE.md\ngit commit -m \"docs: add API reference and update architecture docs\"\n</code></pre>"},{"location":"plans/2026-02-15-application-management-api-implementation/#task-12-final-verification","title":"Task 12: Final Verification","text":"<p>Step 1: Run full test suite</p> <p>Run: <code>go test ./...</code> Expected: All tests pass.</p> <p>Step 2: Run vet</p> <p>Run: <code>go vet ./...</code> Expected: No issues.</p> <p>Step 3: Run fmt</p> <p>Run: <code>go fmt ./...</code> Expected: No formatting changes needed.</p> <p>Step 4: Verify build</p> <p>Run: <code>go build ./cmd/updater</code> Expected: Builds successfully.</p> <p>Step 5: Review all changes</p> <p>Run: <code>git diff main --stat</code> Verify all expected files are modified/created and nothing unexpected is included.</p> <p>Step 6: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: final adjustments from application management API review\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-design/","title":"Makefile Restructure Design","text":"<p>Date: 2026-02-15 Status: Approved</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#problem","title":"Problem","text":"<p>The Makefile is a single 163-line file that will continue growing as new target categories are added. This makes targets hard to find, the file hard to maintain, and help text must be kept in sync manually.</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#goals","title":"Goals","text":"<ol> <li>Improve readability by splitting targets into category-based files</li> <li>Transition all possible commands to run inside Docker containers for consistency and reduced local dependencies</li> <li>Auto-generate help output so it stays in sync as targets are added</li> </ol>"},{"location":"plans/2026-02-15-makefile-restructure-design/#design","title":"Design","text":""},{"location":"plans/2026-02-15-makefile-restructure-design/#file-structure","title":"File Structure","text":"<pre><code>Makefile              -- Shared variables, includes, help target (~30 lines)\nmake/\n  go.mk              -- Go development: build, test, fmt, vet, clean, tidy, check\n  docs.mk            -- Documentation: docs-serve, docs-build, docs-clean\n  docker.mk          -- Docker operations: docker-build, docker-scan, docker-run,\n                         docker-dev, docker-prod, docker-obs-up, docker-obs-down,\n                         docker-clean, docker-push\n  db.mk              -- Database: sqlc-generate, sqlc-vet\n</code></pre> <p>The root Makefile uses <code>include make/*.mk</code> to pull in all category files automatically. New categories are added by creating a new <code>.mk</code> file -- no changes to the root Makefile needed.</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#docker-first-targets","title":"Docker-first Targets","text":"<p>Default targets run inside Docker containers. Only Docker is required on the host -- no local Go, sqlc, or other tooling needed.</p> <p>Go targets run via a shared <code>GO_DOCKER</code> variable:</p> <pre><code>GO_IMAGE       := golang:1.25-alpine\nGO_MOD_CACHE   := updater-go-mod-cache\nGO_BUILD_CACHE := updater-go-build-cache\nGO_DOCKER      := docker run --rm \\\n    -v \"$(CURDIR):/app\" \\\n    -v \"$(GO_MOD_CACHE):/go/pkg/mod\" \\\n    -v \"$(GO_BUILD_CACHE):/root/.cache/go-build\" \\\n    -w /app \\\n    -e CGO_ENABLED=0 \\\n    --user \"$(shell id -u):$(shell id -g)\" \\\n    $(GO_IMAGE)\n</code></pre> <p>Target mapping:</p> Target Container Command <code>build</code> <code>$(GO_DOCKER) go build -o bin/updater ./cmd/updater</code> <code>test</code> <code>$(GO_DOCKER) go test ./...</code> <code>fmt</code> <code>$(GO_DOCKER) go fmt ./...</code> <code>vet</code> <code>$(GO_DOCKER) go vet ./...</code> <code>tidy</code> <code>$(GO_DOCKER) go mod tidy</code> <code>check</code> <code>fmt</code> + <code>vet</code> + <code>test</code> (all containerized) <code>clean</code> <code>rm -rf bin</code> (local, no container) <p>sqlc targets run via the official sqlc Docker image:</p> Target Container Command <code>sqlc-generate</code> <code>docker run --rm -v \"$(CURDIR):/src\" -w /src sqlc/sqlc:latest generate</code> <code>sqlc-vet</code> <code>docker run --rm -v \"$(CURDIR):/src\" -w /src sqlc/sqlc:latest vet</code> <p>Docs targets already use Docker (squidfunk/mkdocs-material). No change needed.</p> <p>Docker ops targets inherently use Docker. No change needed.</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#volume-caching","title":"Volume Caching","text":"<p>Two named Docker volumes persist caches between runs:</p> <ul> <li><code>updater-go-mod-cache</code> -- Go module downloads (<code>/go/pkg/mod</code>)</li> <li><code>updater-go-build-cache</code> -- Go build cache (<code>/root/.cache/go-build</code>)</li> </ul> <p>This ensures repeated runs of <code>make test</code> or <code>make build</code> are fast after the first invocation.</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#auto-documenting-help","title":"Auto-documenting Help","text":"<p>Each target is annotated with <code>## Description</code> on the target line. Category headers use <code>##@</code> comments. The help target parses all included files:</p> <pre><code>.DEFAULT_GOAL := help\n\nhelp: ## Show this help\n    @grep -h '##' $(MAKEFILE_LIST) | grep -v grep | awk -F ':.*##' '{printf \"  %-18s %s\\n\", $$1, $$2}'\n</code></pre> <p>Example output:</p> <pre><code>Go Development:\n  build              Build the application to bin/updater\n  test               Run tests\n  fmt                Format code\n  vet                Vet code for issues\n  clean              Clean build artifacts\n  tidy               Tidy dependencies\n  check              Run format, vet, and test\n\nDocumentation:\n  docs-serve         Start MkDocs development server\n  docs-build         Build documentation site\n  docs-clean         Clean documentation build artifacts\n\nDocker Operations:\n  docker-build       Build secure Docker image\n  docker-scan        Scan Docker image for vulnerabilities\n  docker-run         Run container with security defaults\n  docker-dev         Start development environment\n  docker-prod        Run with production configuration\n  docker-obs-up      Start observability stack\n  docker-obs-down    Stop observability stack\n  docker-clean       Clean Docker artifacts\n  docker-push        Build and push Docker image\n\nDatabase:\n  sqlc-generate      Generate Go code from SQL schemas\n  sqlc-vet           Validate SQL schemas and queries\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-design/#error-handling","title":"Error Handling","text":"<p>Docker guard at the top of the root Makefile:</p> <pre><code>DOCKER := $(shell command -v docker 2&gt;/dev/null)\nifndef DOCKER\n    $(error \"Docker is required but not found. Install Docker to use this Makefile.\")\nendif\n</code></pre> <p>File ownership: The <code>--user \"$(shell id -u):$(shell id -g)\"</code> flag ensures container-created files (e.g., <code>bin/updater</code>) match the host user, avoiding root-owned files on Linux.</p>"},{"location":"plans/2026-02-15-makefile-restructure-design/#verification","title":"Verification","text":"<p>Since this is a Makefile restructure (not Go code), verification is a manual checklist:</p> <ol> <li>Every target runs successfully</li> <li>Help output lists all targets with correct descriptions and groupings</li> <li>Second run of <code>make test</code> is faster than the first (cache hit)</li> <li>Clear error message when Docker is unavailable</li> <li><code>make clean</code> removes build artifacts</li> </ol>"},{"location":"plans/2026-02-15-makefile-restructure-design/#documentation","title":"Documentation","text":"<ul> <li>New page at <code>docs/makefile.md</code> covering the <code>make/</code> structure, Docker-first philosophy, how to add targets, prerequisites, and cache management</li> <li>Added to <code>mkdocs.yml</code> nav</li> <li>CLAUDE.md \"Development Commands\" section updated to reflect new structure</li> </ul>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/","title":"Makefile Restructure Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Split the monolithic Makefile into category-based files under <code>make/</code>, transition all targets to Docker-first execution, and add auto-documenting help.</p> <p>Architecture: A slim root Makefile defines shared Docker variables and includes all <code>make/*.mk</code> files via wildcard. Each <code>.mk</code> file owns its category's <code>.PHONY</code> declarations and targets. A <code>grep</code>/<code>awk</code>-based help target auto-discovers target descriptions from <code>## comment</code> annotations.</p> <p>Tech Stack: GNU Make, Docker (golang:1.25-alpine, sqlc/sqlc, squidfunk/mkdocs-material), POSIX shell</p>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-1-create-make-directory-and-root-makefile","title":"Task 1: Create <code>make/</code> Directory and Root Makefile","text":"<p>Files: - Create: <code>make/.gitkeep</code> (placeholder, removed after other files exist) - Modify: <code>Makefile</code> (complete rewrite)</p> <p>Step 1: Create the <code>make/</code> directory</p> <p>Run: <code>mkdir -p make</code></p> <p>Step 2: Rewrite the root Makefile</p> <p>Replace the entire contents of <code>Makefile</code> with:</p> <pre><code># Root Makefile - shared variables, includes, auto-documenting help\n#\n# All targets run inside Docker containers. Only Docker is required locally.\n# See make/*.mk for target definitions.\n\n# Guard: require Docker\nDOCKER := $(shell command -v docker 2&gt;/dev/null)\nifndef DOCKER\n    $(error Docker is required but not found. Install Docker to use this Makefile)\nendif\n\n# Shared variables\nAPP_NAME   := updater\nBIN_DIR    := bin\nGO_IMAGE   := golang:1.25-alpine\nGO_MOD_CACHE   := $(APP_NAME)-go-mod-cache\nGO_BUILD_CACHE := $(APP_NAME)-go-build-cache\nGO_DOCKER  := docker run --rm \\\n    -v \"$(CURDIR):/app\" \\\n    -v \"$(GO_MOD_CACHE):/go/pkg/mod\" \\\n    -v \"$(GO_BUILD_CACHE):/root/.cache/go-build\" \\\n    -w /app \\\n    -e CGO_ENABLED=0 \\\n    $(GO_IMAGE)\n\n# Include all category makefiles\ninclude make/*.mk\n\n# Default target\n.DEFAULT_GOAL := help\n\n.PHONY: help\nhelp: ## Show this help\n    @echo \"Usage: make &lt;target&gt;\"\n    @echo \"\"\n    @awk '/^##@/ {printf \"\\n\\033[1m%s\\033[0m\\n\", substr($$0, 5)}' $(MAKEFILE_LIST)\n    @awk '/^[a-zA-Z_-]+:.*##/ {printf \"  \\033[36m%-18s\\033[0m %s\\n\", $$1, substr($$0, index($$0, \"##\") + 3)}' $(MAKEFILE_LIST)\n</code></pre> <p>Step 3: Verify the Makefile parses without errors</p> <p>Run: <code>make --dry-run help</code> Expected: May warn about missing includes (no <code>.mk</code> files yet), but no syntax errors.</p> <p>Step 4: Commit</p> <pre><code>git add Makefile\ngit commit -m \"refactor: rewrite root Makefile as slim orchestrator with Docker variables\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-2-create-makegomk-with-docker-first-go-targets","title":"Task 2: Create <code>make/go.mk</code> with Docker-first Go Targets","text":"<p>Files: - Create: <code>make/go.mk</code></p> <p>Step 1: Create <code>make/go.mk</code></p> <pre><code>##@ Go Development\n\n.PHONY: build run test fmt vet clean tidy check\n\nbuild: ## Build the application to bin/updater\n    $(GO_DOCKER) go build -o $(BIN_DIR)/$(APP_NAME) ./cmd/$(APP_NAME)\n\nrun: ## Run the application\n    $(GO_DOCKER) go run ./cmd/$(APP_NAME)\n\ntest: ## Run tests\n    $(GO_DOCKER) go test ./...\n\nfmt: ## Format code\n    $(GO_DOCKER) go fmt ./...\n\nvet: ## Vet code for issues\n    $(GO_DOCKER) go vet ./...\n\nclean: ## Clean build artifacts\n    rm -rf $(BIN_DIR)\n\ntidy: ## Tidy dependencies\n    $(GO_DOCKER) go mod tidy\n\ncheck: fmt vet test ## Run format, vet, and test\n</code></pre> <p>Step 2: Verify targets are discovered</p> <p>Run: <code>make help</code> Expected: \"Go Development\" header with all targets listed.</p> <p>Step 3: Run a target to verify Docker execution</p> <p>Run: <code>make vet</code> Expected: Docker pulls <code>golang:1.25-alpine</code> (first time), runs <code>go vet ./...</code>, exits 0.</p> <p>Step 4: Commit</p> <pre><code>git add make/go.mk\ngit commit -m \"refactor: add Docker-first Go targets in make/go.mk\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-3-create-makedocsmk-with-documentation-targets","title":"Task 3: Create <code>make/docs.mk</code> with Documentation Targets","text":"<p>Files: - Create: <code>make/docs.mk</code></p> <p>Step 1: Create <code>make/docs.mk</code></p> <pre><code>##@ Documentation\n\n.PHONY: docs-serve docs-build docs-clean\n\ndocs-serve: ## Start MkDocs development server (http://localhost:8000)\n    @echo \"Starting MkDocs development server with Docker...\"\n    docker run --rm -it -p 8000:8000 -v \"$(CURDIR):/docs\" squidfunk/mkdocs-material:latest\n\ndocs-build: ## Build documentation site\n    @echo \"Building documentation site with Docker...\"\n    docker run --rm -v \"$(CURDIR):/docs\" squidfunk/mkdocs-material:latest build\n\ndocs-clean: ## Clean documentation build artifacts\n    @echo \"Cleaning documentation build artifacts...\"\n    rm -rf site\n</code></pre> <p>Step 2: Verify targets appear in help</p> <p>Run: <code>make help</code> Expected: \"Documentation\" header with three targets listed.</p> <p>Step 3: Commit</p> <pre><code>git add make/docs.mk\ngit commit -m \"refactor: move documentation targets to make/docs.mk\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-4-create-makedockermk-with-docker-operations-targets","title":"Task 4: Create <code>make/docker.mk</code> with Docker Operations Targets","text":"<p>Files: - Create: <code>make/docker.mk</code></p> <p>Step 1: Create <code>make/docker.mk</code></p> <pre><code>##@ Docker Operations\n\n.PHONY: docker-build docker-scan docker-run docker-dev docker-prod \\\n    docker-obs-up docker-obs-down docker-clean docker-push\n\ndocker-build: ## Build secure Docker image\n    @echo \"Building secure Docker image...\"\n    ./scripts/docker-build.sh\n\ndocker-scan: ## Scan Docker image for vulnerabilities\n    @echo \"Scanning Docker image for vulnerabilities...\"\n    ./scripts/docker-build.sh --scan\n\ndocker-run: ## Run container with security defaults\n    @echo \"Running Docker container with security defaults...\"\n    docker run --rm -p 8080:8080 \\\n        --read-only \\\n        --tmpfs /tmp:noexec,nosuid,size=10m \\\n        --cap-drop=ALL \\\n        --security-opt=no-new-privileges:true \\\n        -e UPDATER_CONFIG_SECTION=development \\\n        localhost/$(APP_NAME):latest\n\ndocker-dev: ## Start development environment with Docker Compose\n    @echo \"Starting development environment...\"\n    docker-compose up -d\n    @echo \"Service available at http://localhost:8080\"\n    @echo \"View logs: docker-compose logs -f\"\n    @echo \"Stop: docker-compose down\"\n\ndocker-prod: ## Run with production configuration (for testing)\n    @echo \"Running container with production configuration...\"\n    @echo \"Note: This is for testing production config locally\"\n    docker run -d --name $(APP_NAME)-prod-test -p 8080:8080 \\\n        --restart=unless-stopped \\\n        --read-only \\\n        --tmpfs /tmp:noexec,nosuid,nodev,size=5m \\\n        --tmpfs /app/data:noexec,nosuid,size=50m \\\n        --cap-drop=ALL \\\n        --security-opt=no-new-privileges:true \\\n        --memory=256m --cpus=\"1.0\" \\\n        -e UPDATER_CONFIG_SECTION=production \\\n        --env-file=.env.example \\\n        localhost/$(APP_NAME):latest\n    @echo \"Production test container started\"\n    @echo \"View logs: docker logs -f $(APP_NAME)-prod-test\"\n    @echo \"Stop: docker stop $(APP_NAME)-prod-test &amp;&amp; docker rm $(APP_NAME)-prod-test\"\n\ndocker-obs-up: ## Start observability stack\n    @echo \"Starting observability stack...\"\n    docker compose -f docker-compose.yml -f docker-compose.observability.yml up -d\n    @echo \"Services:\"\n    @echo \"  Updater:    http://localhost:8080\"\n    @echo \"  Metrics:    http://localhost:9090/metrics\"\n    @echo \"  Jaeger UI:  http://localhost:16686\"\n    @echo \"  Prometheus: http://localhost:9091\"\n    @echo \"  Grafana:    http://localhost:3000\"\n\ndocker-obs-down: ## Stop observability stack\n    docker compose -f docker-compose.yml -f docker-compose.observability.yml down\n\ndocker-clean: ## Clean Docker artifacts\n    @echo \"Cleaning Docker artifacts...\"\n    docker system prune -f\n    docker image prune -f\n\ndocker-push: ## Build and push Docker image to registry\n    @echo \"Building and pushing Docker image to registry...\"\n    ./scripts/docker-build.sh --push\n</code></pre> <p>Step 2: Verify targets appear in help</p> <p>Run: <code>make help</code> Expected: \"Docker Operations\" header with all nine targets listed.</p> <p>Step 3: Commit</p> <pre><code>git add make/docker.mk\ngit commit -m \"refactor: move Docker operations targets to make/docker.mk\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-5-create-makedbmk-with-docker-first-database-targets","title":"Task 5: Create <code>make/db.mk</code> with Docker-first Database Targets","text":"<p>Files: - Create: <code>make/db.mk</code></p> <p>Step 1: Create <code>make/db.mk</code></p> <pre><code>##@ Database\n\nSQLC_IMAGE := sqlc/sqlc:latest\n\n.PHONY: sqlc-generate sqlc-vet\n\nsqlc-generate: ## Generate Go code from SQL schemas\n    @echo \"Generating Go code from SQL schemas...\"\n    docker run --rm -v \"$(CURDIR):/src\" -w /src $(SQLC_IMAGE) generate\n\nsqlc-vet: ## Validate SQL schemas and queries\n    @echo \"Validating SQL schemas and queries...\"\n    docker run --rm -v \"$(CURDIR):/src\" -w /src $(SQLC_IMAGE) vet\n</code></pre> <p>Step 2: Verify targets appear in help</p> <p>Run: <code>make help</code> Expected: \"Database\" header with two targets listed.</p> <p>Step 3: Commit</p> <pre><code>git add make/db.mk\ngit commit -m \"refactor: move database targets to make/db.mk with Docker execution\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-6-full-verification","title":"Task 6: Full Verification","text":"<p>Step 1: Run <code>make help</code> and verify all targets are listed</p> <p>Run: <code>make help</code> Expected: All targets grouped under four category headers (Go Development, Documentation, Docker Operations, Database) plus help itself.</p> <p>Step 2: Run <code>make vet</code> to verify Docker-first Go targets work</p> <p>Run: <code>make vet</code> Expected: Runs <code>go vet ./...</code> inside Docker container, exits 0.</p> <p>Step 3: Run <code>make test</code> to verify test execution in Docker</p> <p>Run: <code>make test</code> Expected: Runs <code>go test ./...</code> inside Docker container, all tests pass.</p> <p>Step 4: Run <code>make test</code> a second time to verify caching</p> <p>Run: <code>make test</code> Expected: Noticeably faster than first run (module and build caches warm).</p> <p>Step 5: Run <code>make build</code> to verify binary output</p> <p>Run: <code>make build &amp;&amp; ls -la bin/updater</code> Expected: Binary exists at <code>bin/updater</code>.</p> <p>Step 6: Commit (if any fixes were needed)</p> <pre><code>git add -A\ngit commit -m \"fix: address issues found during Makefile verification\"\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-7-write-documentation","title":"Task 7: Write Documentation","text":"<p>Files: - Create: <code>docs/makefile.md</code> - Modify: <code>mkdocs.yml</code> (add nav entry) - Modify: <code>CLAUDE.md</code> (update Development Commands section and Project Structure)</p> <p>Step 1: Create <code>docs/makefile.md</code></p> <p><pre><code># Makefile\n\nThe project uses a split Makefile structure with Docker-first execution. Only Docker is required on the host -- no local Go, sqlc, or other tooling needed.\n\n## Structure\n</code></pre> Makefile              -- Shared variables, includes, auto-documenting help make/   go.mk              -- Go development (build, test, fmt, vet, clean, tidy, check)   docs.mk            -- Documentation (docs-serve, docs-build, docs-clean)   docker.mk          -- Docker operations (docker-build, docker-run, docker-dev, etc.)   db.mk              -- Database (sqlc-generate, sqlc-vet) <pre><code>The root `Makefile` includes all `make/*.mk` files automatically. To add a new category, create a new `.mk` file in `make/` -- no changes to the root Makefile needed.\n\n## Docker-first Execution\n\nAll Go and database targets run inside Docker containers:\n\n```mermaid\ngraph LR\n    A[make test] --&gt; B[docker run golang:1.25-alpine]\n    B --&gt; C[go test ./...]\n    A -- cached --&gt; D[(go-mod-cache)]\n    A -- cached --&gt; E[(go-build-cache)]\n</code></pre></p> Category Container Image Go development <code>golang:1.25-alpine</code> Documentation <code>squidfunk/mkdocs-material:latest</code> Database (sqlc) <code>sqlc/sqlc:latest</code> Docker operations Host Docker daemon"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker -- the only local requirement</li> <li>GNU Make -- included with most systems (on Windows, use Git for Windows which provides <code>make</code> and <code>sh</code>)</li> </ul>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#caching","title":"Caching","text":"<p>Two named Docker volumes persist caches between runs:</p> Volume Purpose <code>updater-go-mod-cache</code> Go module downloads <code>updater-go-build-cache</code> Go build cache <p>To clear caches (e.g., after a Go version bump):</p> <pre><code>docker volume rm updater-go-mod-cache updater-go-build-cache\n</code></pre>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#adding-a-new-target","title":"Adding a New Target","text":"<ol> <li>Open the appropriate <code>make/*.mk</code> file (or create a new one for a new category)</li> <li>Add a category header if creating a new file: <code>##@ Category Name</code></li> <li>Add the target with a <code>## Description</code> annotation:</li> </ol> <pre><code>new-target: ## Description of what this target does\n    command to run\n</code></pre> <ol> <li>The target automatically appears in <code>make help</code> output</li> </ol>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#available-targets","title":"Available Targets","text":"<p>Run <code>make help</code> to see all available targets with descriptions. <pre><code>**Step 2: Add nav entry to `mkdocs.yml`**\n\nAdd `- Makefile: makefile.md` after the Observability entry in the nav section of `mkdocs.yml`.\n\n**Step 3: Update CLAUDE.md**\n\nUpdate the \"Project Structure\" section to include `make/` directory. Update the \"Development Commands\" section to note Docker-first execution and the `make/` structure. Update the Gotchas section to note Docker is the only local requirement.\n\n**Step 4: Commit**\n\n```bash\ngit add docs/makefile.md mkdocs.yml CLAUDE.md\ngit commit -m \"docs: add Makefile documentation and update project references\"\n</code></pre></p>"},{"location":"plans/2026-02-15-makefile-restructure-implementation/#task-8-final-review","title":"Task 8: Final Review","text":"<p>Step 1: Run full check</p> <p>Run: <code>make check</code> Expected: <code>fmt</code>, <code>vet</code>, and <code>test</code> all pass inside Docker.</p> <p>Step 2: Verify help output is clean</p> <p>Run: <code>make help</code> Expected: All targets listed under correct category headers, no duplicates, no stray output.</p> <p>Step 3: Verify old Makefile has no leftover targets</p> <p>Run: <code>grep -c '^[a-z]' Makefile</code> Expected: Only <code>help</code> target defined in root Makefile (count = 1).</p> <p>Step 4: Verify docs build</p> <p>Run: <code>make docs-build</code> Expected: MkDocs builds successfully, including the new <code>makefile.md</code> page.</p> <p>Step 5: Final commit if any fixes needed</p> <pre><code>git add -A\ngit commit -m \"fix: final adjustments from Makefile restructure review\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-design/","title":"Rate Limiter Overhaul","text":"<p>Date: 2026-02-15 Status: Approved</p>"},{"location":"plans/2026-02-15-rate-limiter-design/#problem","title":"Problem","text":"<p>The current rate limiter in <code>internal/api/routes.go</code> has several production-readiness issues:</p> <ul> <li>Memory leak: The <code>map[string]time.Time</code> grows unbounded. No cleanup of stale entries.</li> <li>Incorrect algorithm: Stores only the last request timestamp per IP. This enforces a minimum inter-request interval, not a rate limit. A client sending 1 request per second would be allowed at 60 rpm, but 2 rapid requests followed by 58 seconds of silence would be rejected on the second request despite being well under the limit.</li> <li>Ignored config: <code>BurstSize</code> and <code>RequestsPerHour</code> fields in <code>RateLimitConfig</code> are loaded and validated but never used.</li> <li>No response headers: Clients have no way to know their rate limit status or when to retry.</li> <li>No auth-aware tiers: All clients share the same limit regardless of authentication status.</li> <li>Tightly coupled: The implementation is an inline closure in <code>routes.go</code>, making it difficult to test or replace.</li> </ul>"},{"location":"plans/2026-02-15-rate-limiter-design/#design","title":"Design","text":""},{"location":"plans/2026-02-15-rate-limiter-design/#package-structure","title":"Package Structure","text":"<pre><code>internal/ratelimit/\n  limiter.go          - Limiter interface and Info type\n  memory.go           - MemoryLimiter backed by golang.org/x/time/rate\n  memory_test.go      - Unit tests for MemoryLimiter\n  middleware.go        - HTTP middleware using the Limiter interface\n  middleware_test.go   - Middleware tests\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-design/#interface","title":"Interface","text":"<pre><code>// Limiter defines the rate limiting contract. Implementations must be\n// safe for concurrent use.\ntype Limiter interface {\n    // Allow checks whether a request identified by key should be allowed.\n    // Returns whether the request is allowed and rate information for\n    // response headers.\n    Allow(key string) (allowed bool, info Info)\n\n    // Close stops background goroutines and releases resources.\n    Close()\n}\n\n// Info contains rate limit state for populating response headers.\ntype Info struct {\n    Limit      int           // Maximum requests per window\n    Remaining  int           // Approximate tokens remaining\n    ResetAt    time.Time     // When the bucket will be full again\n    RetryAfter time.Duration // How long to wait (meaningful only when denied)\n}\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-design/#keying-strategy","title":"Keying Strategy","text":"<p>The middleware determines the rate limit key based on authentication context:</p> <ul> <li>Anonymous requests: keyed by client IP address (from <code>X-Forwarded-For</code>, <code>X-Real-IP</code>, or <code>RemoteAddr</code>)</li> <li>Authenticated requests: keyed by <code>auth:&lt;key-name&gt;</code> where <code>&lt;key-name&gt;</code> is the API key's configured name</li> </ul> <p>This separation ensures that authenticated clients get their own bucket at the higher tier rate, independent of anonymous traffic from the same IP.</p>"},{"location":"plans/2026-02-15-rate-limiter-design/#algorithm-token-bucket-via-golangorgxtimerate","title":"Algorithm: Token Bucket via <code>golang.org/x/time/rate</code>","text":"<p>Each client key gets a <code>rate.Limiter</code> configured with:</p> <ul> <li>Rate: <code>rate.Every(time.Minute / requestsPerMinute)</code> -- one token added per interval</li> <li>Burst: <code>burstSize</code> -- maximum tokens the bucket can hold</li> </ul> <p>The <code>MemoryLimiter</code> stores these in a <code>sync.Mutex</code>-guarded map. A background goroutine runs every <code>CleanupInterval</code> to evict entries that have not been accessed within 2x the cleanup interval.</p> <pre><code>graph TD\n    A[HTTP Request] --&gt; B{Authenticated?}\n    B --&gt;|Yes| C[\"Key: auth:&lt;name&gt;&lt;br/&gt;Rate: authenticated tier\"]\n    B --&gt;|No| D[\"Key: client IP&lt;br/&gt;Rate: default tier\"]\n    C --&gt; E[Lookup or create rate.Limiter]\n    D --&gt; E\n    E --&gt; F{Tokens available?}\n    F --&gt;|Yes| G[Allow request&lt;br/&gt;Set X-RateLimit-* headers]\n    F --&gt;|No| H[Return 429&lt;br/&gt;Set Retry-After header]</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-design/#two-tier-configuration","title":"Two-Tier Configuration","text":"<pre><code>type RateLimitConfig struct {\n    Enabled                        bool          `yaml:\"enabled\"`\n    RequestsPerMinute              int           `yaml:\"requests_per_minute\"`\n    BurstSize                      int           `yaml:\"burst_size\"`\n    AuthenticatedRequestsPerMinute int           `yaml:\"authenticated_requests_per_minute\"`\n    AuthenticatedBurstSize         int           `yaml:\"authenticated_burst_size\"`\n    CleanupInterval                time.Duration `yaml:\"cleanup_interval\"`\n}\n</code></pre> <p>Changes from the current config:</p> Field Before After <code>RequestsPerMinute</code> 60 (partially used) 60 (fully enforced) <code>BurstSize</code> 10 (ignored) 10 (enforced) <code>RequestsPerHour</code> 1000 (ignored) Removed <code>AuthenticatedRequestsPerMinute</code> N/A 120 (new) <code>AuthenticatedBurstSize</code> N/A 20 (new) <code>CleanupInterval</code> 5m (ignored) 5m (enforced) <p>Default authenticated values are 2x the anonymous values. If set to 0, they default to 2x the anonymous values.</p>"},{"location":"plans/2026-02-15-rate-limiter-design/#response-headers","title":"Response Headers","text":"<p>Every response includes rate limit headers:</p> Header Description Example <code>X-RateLimit-Limit</code> Requests per minute for this client <code>60</code> <code>X-RateLimit-Remaining</code> Approximate tokens remaining <code>42</code> <code>X-RateLimit-Reset</code> Unix timestamp when bucket is full <code>1739664000</code> <p>On 429 responses, an additional header is included:</p> Header Description Example <code>Retry-After</code> Seconds until a token is available <code>3</code>"},{"location":"plans/2026-02-15-rate-limiter-design/#integration","title":"Integration","text":"<ol> <li>Remove the inline <code>rateLimitMiddleware</code> from <code>internal/api/routes.go</code></li> <li>Create <code>MemoryLimiter</code> in <code>cmd/updater/updater.go</code> during server startup</li> <li>Pass <code>ratelimit.Middleware(limiter)</code> as a <code>RouteOption</code> to <code>SetupRoutes</code></li> <li>Defer <code>limiter.Close()</code> in <code>main()</code> to stop the cleanup goroutine on shutdown</li> <li>The middleware reads the <code>\"api_key\"</code> context value (set by <code>authMiddleware</code>) to determine which tier applies</li> </ol>"},{"location":"plans/2026-02-15-rate-limiter-design/#middleware-order","title":"Middleware Order","text":"<p>The rate limiter middleware runs before authentication so that anonymous abuse is caught early. For authenticated requests that pass the rate check, the auth middleware runs next and sets the context value. On subsequent requests from the same authenticated client, the rate limiter middleware sees the auth context and applies the authenticated tier.</p> <p>Correction: Since the rate limiter needs to know whether the request is authenticated to pick the right tier, it must run after auth middleware. The middleware order is:</p> <ol> <li>CORS</li> <li>Logging</li> <li>Recovery</li> <li>Auth (optional, sets context)</li> <li>Rate limiting (reads auth context, applies correct tier)</li> </ol> <p>This matches the existing middleware order in <code>routes.go</code> where rate limiting already runs after CORS, logging, and recovery. The auth middleware for protected endpoints runs on subrouters, so the rate limiter on the main router will see unauthenticated requests. For the two-tier approach, the middleware will attempt to read auth context if present (via <code>OptionalAuth</code> or subrouter auth) and fall back to the anonymous tier.</p>"},{"location":"plans/2026-02-15-rate-limiter-design/#dependencies","title":"Dependencies","text":"<ul> <li><code>golang.org/x/time/rate</code> (new dependency)</li> </ul>"},{"location":"plans/2026-02-15-rate-limiter-design/#files-modified","title":"Files Modified","text":"File Change <code>internal/ratelimit/limiter.go</code> New: interface and types <code>internal/ratelimit/memory.go</code> New: MemoryLimiter implementation <code>internal/ratelimit/memory_test.go</code> New: unit tests <code>internal/ratelimit/middleware.go</code> New: HTTP middleware <code>internal/ratelimit/middleware_test.go</code> New: middleware tests <code>internal/models/config.go</code> Modified: update RateLimitConfig, defaults, validation <code>internal/models/config_test.go</code> Modified: update config tests <code>internal/api/routes.go</code> Modified: remove inline rateLimitMiddleware, add RouteOption <code>internal/api/routes_test.go</code> Modified: update route tests if affected <code>cmd/updater/updater.go</code> Modified: create limiter, pass to SetupRoutes, defer Close <code>go.mod</code> / <code>go.sum</code> Modified: add golang.org/x/time dependency <code>docs/rate-limiting.md</code> New: documentation page <code>mkdocs.yml</code> Modified: add rate limiting to nav"},{"location":"plans/2026-02-15-rate-limiter-implementation/","title":"Rate Limiter Overhaul Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the broken in-memory rate limiter with a proper token-bucket implementation backed by <code>golang.org/x/time/rate</code>, with two-tier auth-aware limits, response headers, and stale entry cleanup.</p> <p>Architecture: New <code>internal/ratelimit/</code> package with a <code>Limiter</code> interface and <code>MemoryLimiter</code> implementation. The middleware moves from an inline closure in <code>routes.go</code> to this package. The limiter is created in <code>main()</code> and injected via <code>RouteOption</code>.</p> <p>Tech Stack: <code>golang.org/x/time/rate</code>, <code>gorilla/mux</code>, <code>net/http</code>, <code>sync</code></p> <p>Design doc: <code>docs/plans/2026-02-15-rate-limiter-design.md</code></p>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-1-add-golangorgxtime-dependency","title":"Task 1: Add <code>golang.org/x/time</code> dependency","text":"<p>Files: - Modify: <code>go.mod</code></p> <p>Step 1: Add the dependency</p> <p>Run: <code>go get golang.org/x/time/rate</code></p> <p>Step 2: Verify it was added</p> <p>Run: <code>go mod tidy</code> Expected: <code>golang.org/x/time</code> appears in <code>go.mod</code> require block</p> <p>Step 3: Commit</p> <pre><code>git add go.mod go.sum\ngit commit -m \"chore: add golang.org/x/time dependency for rate limiting\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-2-update-ratelimitconfig-model","title":"Task 2: Update RateLimitConfig model","text":"<p>Files: - Modify: <code>internal/models/config.go:103-109</code> (RateLimitConfig struct) - Modify: <code>internal/models/config.go:211-217</code> (NewDefaultConfig rate limit section) - Modify: <code>internal/models/config.go:350-361</code> (SecurityConfig.Validate rate limit validation)</p> <p>Step 1: Write the failing test</p> <p>Update <code>internal/models/config_test.go</code>. Find the <code>TestNewDefaultConfig</code> function and update the rate limit assertions. Find <code>TestRateLimitConfig_Structure</code> and update it. Add a test for the new authenticated fields.</p> <p>In <code>TestNewDefaultConfig</code> (around line 39-42), the assertions currently check <code>RequestsPerHour</code>. Replace them:</p> <pre><code>// Test security defaults\nassert.Empty(t, config.Security.APIKeys)\nassert.True(t, config.Security.RateLimit.Enabled)\nassert.Equal(t, 60, config.Security.RateLimit.RequestsPerMinute)\nassert.Equal(t, 10, config.Security.RateLimit.BurstSize)\nassert.Equal(t, 120, config.Security.RateLimit.AuthenticatedRequestsPerMinute)\nassert.Equal(t, 20, config.Security.RateLimit.AuthenticatedBurstSize)\nassert.Equal(t, 5*time.Minute, config.Security.RateLimit.CleanupInterval)\nassert.False(t, config.Security.EnableAuth)\n</code></pre> <p>In <code>TestRateLimitConfig_Structure</code> (around line 897-911), update to remove <code>RequestsPerHour</code> and add authenticated fields:</p> <pre><code>func TestRateLimitConfig_Structure(t *testing.T) {\n    rateLimitConfig := RateLimitConfig{\n        Enabled:                        true,\n        RequestsPerMinute:              120,\n        BurstSize:                      20,\n        AuthenticatedRequestsPerMinute: 240,\n        AuthenticatedBurstSize:         40,\n        CleanupInterval:                10 * time.Minute,\n    }\n\n    assert.True(t, rateLimitConfig.Enabled)\n    assert.Equal(t, 120, rateLimitConfig.RequestsPerMinute)\n    assert.Equal(t, 20, rateLimitConfig.BurstSize)\n    assert.Equal(t, 240, rateLimitConfig.AuthenticatedRequestsPerMinute)\n    assert.Equal(t, 40, rateLimitConfig.AuthenticatedBurstSize)\n    assert.Equal(t, 10*time.Minute, rateLimitConfig.CleanupInterval)\n}\n</code></pre> <p>In <code>TestSecurityConfig_Validate</code> (the table-driven test around line 355), update the \"valid config with rate limiting\" test case to remove <code>RequestsPerHour</code> and remove the \"negative requests per hour\" test case. Add test cases for negative authenticated values:</p> <pre><code>{\n    name: \"valid config with rate limiting\",\n    config: SecurityConfig{\n        RateLimit: RateLimitConfig{\n            Enabled:                        true,\n            RequestsPerMinute:              60,\n            BurstSize:                      10,\n            AuthenticatedRequestsPerMinute: 120,\n            AuthenticatedBurstSize:         20,\n        },\n    },\n    expectError: false,\n},\n</code></pre> <p>Remove the <code>\"negative requests per hour\"</code> test case entirely (around line 393-403).</p> <p>Add new test cases:</p> <pre><code>{\n    name: \"negative authenticated requests per minute\",\n    config: SecurityConfig{\n        RateLimit: RateLimitConfig{\n            Enabled:                        true,\n            AuthenticatedRequestsPerMinute: -1,\n        },\n    },\n    expectError: true,\n    errorMsg:    \"authenticated requests per minute cannot be negative\",\n},\n{\n    name: \"negative authenticated burst size\",\n    config: SecurityConfig{\n        RateLimit: RateLimitConfig{\n            Enabled:                true,\n            AuthenticatedBurstSize: -1,\n        },\n    },\n    expectError: true,\n    errorMsg:    \"authenticated burst size cannot be negative\",\n},\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>go test ./internal/models/ -run \"TestNewDefaultConfig|TestRateLimitConfig_Structure|TestSecurityConfig_Validate\" -v</code> Expected: FAIL -- <code>RequestsPerHour</code> field no longer exists, <code>AuthenticatedRequestsPerMinute</code> does not exist yet</p> <p>Step 3: Update RateLimitConfig struct</p> <p>In <code>internal/models/config.go</code>, replace the <code>RateLimitConfig</code> struct (lines 103-109):</p> <pre><code>type RateLimitConfig struct {\n    Enabled                        bool          `yaml:\"enabled\" json:\"enabled\"`\n    RequestsPerMinute              int           `yaml:\"requests_per_minute\" json:\"requests_per_minute\"`\n    BurstSize                      int           `yaml:\"burst_size\" json:\"burst_size\"`\n    AuthenticatedRequestsPerMinute int           `yaml:\"authenticated_requests_per_minute\" json:\"authenticated_requests_per_minute\"`\n    AuthenticatedBurstSize         int           `yaml:\"authenticated_burst_size\" json:\"authenticated_burst_size\"`\n    CleanupInterval                time.Duration `yaml:\"cleanup_interval\" json:\"cleanup_interval\"`\n}\n</code></pre> <p>Step 4: Update NewDefaultConfig</p> <p>In <code>internal/models/config.go</code>, update the <code>RateLimit</code> section in <code>NewDefaultConfig</code> (around line 211):</p> <pre><code>RateLimit: RateLimitConfig{\n    Enabled:                        true,\n    RequestsPerMinute:              60,\n    BurstSize:                      10,\n    AuthenticatedRequestsPerMinute: 120,\n    AuthenticatedBurstSize:         20,\n    CleanupInterval:                5 * time.Minute,\n},\n</code></pre> <p>Step 5: Update SecurityConfig.Validate</p> <p>In <code>internal/models/config.go</code>, replace the rate limit validation in <code>Validate()</code> (around lines 351-361):</p> <pre><code>func (sec *SecurityConfig) Validate() error {\n    if sec.RateLimit.Enabled {\n        if sec.RateLimit.RequestsPerMinute &lt; 0 {\n            return errors.New(\"requests per minute cannot be negative\")\n        }\n        if sec.RateLimit.BurstSize &lt; 0 {\n            return errors.New(\"burst size cannot be negative\")\n        }\n        if sec.RateLimit.AuthenticatedRequestsPerMinute &lt; 0 {\n            return errors.New(\"authenticated requests per minute cannot be negative\")\n        }\n        if sec.RateLimit.AuthenticatedBurstSize &lt; 0 {\n            return errors.New(\"authenticated burst size cannot be negative\")\n        }\n    }\n\n    for _, apiKey := range sec.APIKeys {\n        if apiKey.Key == \"\" {\n            return errors.New(\"API key cannot be empty\")\n        }\n        if apiKey.Name == \"\" {\n            return errors.New(\"API key name cannot be empty\")\n        }\n    }\n\n    return nil\n}\n</code></pre> <p>Step 6: Fix compilation errors in other test files</p> <p>Several test files reference <code>RequestsPerHour</code>. These need updating:</p> <ul> <li><code>internal/config/config_test.go:48</code> -- remove the <code>requests_per_hour: 1000</code> line from the YAML test fixture, and remove the assertion at line 112 (<code>assert.Equal(t, 1000, config.Security.RateLimit.RequestsPerHour)</code>). Update the default config assertion at line 178 similarly.</li> <li><code>internal/integration/integration_test.go:591</code> -- remove the <code>requests_per_hour: 2000</code> line from the YAML fixture, and remove the assertion at line 626.</li> <li><code>internal/models/config_test.go</code> -- the \"valid config with rate limiting\" test case at line 358: remove the <code>RequestsPerHour</code> field.</li> </ul> <p>Step 7: Run tests to verify they pass</p> <p>Run: <code>go test ./internal/models/ ./internal/config/ -v</code> Expected: PASS</p> <p>Step 8: Commit</p> <pre><code>git add internal/models/config.go internal/models/config_test.go internal/config/config_test.go internal/integration/integration_test.go\ngit commit -m \"refactor: update RateLimitConfig with two-tier auth-aware fields\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-3-create-limiter-interface-and-info-type","title":"Task 3: Create Limiter interface and Info type","text":"<p>Files: - Create: <code>internal/ratelimit/limiter.go</code></p> <p>Step 1: Create the file</p> <pre><code>// Package ratelimit provides rate limiting for HTTP requests using the token\n// bucket algorithm. It supports two-tier rate limits (anonymous vs authenticated)\n// and includes HTTP middleware that sets standard rate limit response headers.\npackage ratelimit\n\nimport \"time\"\n\n// Limiter defines the rate limiting contract. Implementations must be safe for\n// concurrent use.\ntype Limiter interface {\n    // Allow checks whether a request identified by key should be allowed.\n    // Returns whether the request is allowed and rate information for\n    // populating response headers.\n    Allow(key string) (allowed bool, info Info)\n\n    // Close stops background goroutines and releases resources.\n    Close()\n}\n\n// Info contains rate limit state for populating response headers.\ntype Info struct {\n    Limit      int           // Maximum requests per window\n    Remaining  int           // Approximate tokens remaining\n    ResetAt    time.Time     // When the bucket will be full again\n    RetryAfter time.Duration // How long to wait (meaningful only when denied)\n}\n</code></pre> <p>Step 2: Verify it compiles</p> <p>Run: <code>go build ./internal/ratelimit/</code> Expected: success (no output)</p> <p>Step 3: Commit</p> <pre><code>git add internal/ratelimit/limiter.go\ngit commit -m \"feat: add Limiter interface and Info type for rate limiting\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-4-implement-memorylimiter","title":"Task 4: Implement MemoryLimiter","text":"<p>Files: - Create: <code>internal/ratelimit/memory.go</code> - Create: <code>internal/ratelimit/memory_test.go</code></p> <p>Step 1: Write the failing tests</p> <p>Create <code>internal/ratelimit/memory_test.go</code>:</p> <pre><code>package ratelimit\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"testing\"\n    \"time\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewMemoryLimiter(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 5*time.Minute)\n    defer limiter.Close()\n\n    assert.NotNil(t, limiter)\n}\n\nfunc TestMemoryLimiter_Allow_UnderLimit(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 5*time.Minute)\n    defer limiter.Close()\n\n    allowed, info := limiter.Allow(\"192.168.1.1\")\n    assert.True(t, allowed)\n    assert.Equal(t, 60, info.Limit)\n    assert.True(t, info.Remaining &gt;= 0)\n    assert.False(t, info.ResetAt.IsZero())\n}\n\nfunc TestMemoryLimiter_Allow_ExceedsBurst(t *testing.T) {\n    // Burst of 3, rate of 60/min -- 4th rapid request should be denied\n    limiter := NewMemoryLimiter(60, 3, 5*time.Minute)\n    defer limiter.Close()\n\n    key := \"192.168.1.1\"\n\n    for i := 0; i &lt; 3; i++ {\n        allowed, _ := limiter.Allow(key)\n        assert.True(t, allowed, \"request %d should be allowed\", i+1)\n    }\n\n    allowed, info := limiter.Allow(key)\n    assert.False(t, allowed)\n    assert.True(t, info.RetryAfter &gt; 0)\n}\n\nfunc TestMemoryLimiter_Allow_DifferentKeys(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 2, 5*time.Minute)\n    defer limiter.Close()\n\n    // Exhaust key1's burst\n    for i := 0; i &lt; 2; i++ {\n        limiter.Allow(\"key1\")\n    }\n    allowed1, _ := limiter.Allow(\"key1\")\n    assert.False(t, allowed1, \"key1 should be denied\")\n\n    // key2 should still be allowed\n    allowed2, _ := limiter.Allow(\"key2\")\n    assert.True(t, allowed2, \"key2 should be allowed\")\n}\n\nfunc TestMemoryLimiter_Allow_InfoHeaders(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 5, 5*time.Minute)\n    defer limiter.Close()\n\n    _, info := limiter.Allow(\"test-key\")\n    assert.Equal(t, 60, info.Limit)\n    assert.True(t, info.Remaining &gt;= 0 &amp;&amp; info.Remaining &lt;= 5)\n    assert.False(t, info.ResetAt.IsZero())\n}\n\nfunc TestMemoryLimiter_ConcurrentAccess(t *testing.T) {\n    limiter := NewMemoryLimiter(1000, 100, 5*time.Minute)\n    defer limiter.Close()\n\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 50; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            key := fmt.Sprintf(\"client-%d\", id%5)\n            for j := 0; j &lt; 20; j++ {\n                limiter.Allow(key)\n            }\n        }(i)\n    }\n    wg.Wait()\n    // No panics or data races -- run with -race flag\n}\n\nfunc TestMemoryLimiter_Close(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 100*time.Millisecond)\n    limiter.Close()\n    // Should not panic on double close or use after close\n    limiter.Close()\n}\n\nfunc TestMemoryLimiter_Cleanup(t *testing.T) {\n    // Use very short cleanup interval for testing\n    limiter := NewMemoryLimiter(60, 10, 50*time.Millisecond)\n    defer limiter.Close()\n\n    limiter.Allow(\"ephemeral-key\")\n\n    // Verify the key exists\n    limiter.mu.Lock()\n    _, exists := limiter.entries[\"ephemeral-key\"]\n    limiter.mu.Unlock()\n    require.True(t, exists, \"key should exist before cleanup\")\n\n    // Wait for cleanup to run (2x cleanup interval for the staleness check)\n    time.Sleep(200 * time.Millisecond)\n\n    limiter.mu.Lock()\n    _, exists = limiter.entries[\"ephemeral-key\"]\n    limiter.mu.Unlock()\n    assert.False(t, exists, \"key should be cleaned up after inactivity\")\n}\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>go test ./internal/ratelimit/ -v</code> Expected: FAIL -- <code>NewMemoryLimiter</code> not defined</p> <p>Step 3: Implement MemoryLimiter</p> <p>Create <code>internal/ratelimit/memory.go</code>:</p> <pre><code>package ratelimit\n\nimport (\n    \"math\"\n    \"sync\"\n    \"time\"\n\n    \"golang.org/x/time/rate\"\n)\n\n// entry holds a rate limiter and its last access time for cleanup.\ntype entry struct {\n    limiter  *rate.Limiter\n    lastSeen time.Time\n}\n\n// MemoryLimiter is an in-memory rate limiter backed by golang.org/x/time/rate.\n// Each unique key gets its own token bucket. A background goroutine periodically\n// evicts stale entries that have not been accessed within 2x the cleanup interval.\ntype MemoryLimiter struct {\n    rate            rate.Limit\n    burst           int\n    limit           int // requests per minute, for Info.Limit\n    cleanupInterval time.Duration\n\n    mu      sync.Mutex\n    entries map[string]*entry\n    done    chan struct{}\n    closed  bool\n}\n\n// NewMemoryLimiter creates a rate limiter with the given requests-per-minute rate,\n// burst size, and cleanup interval. It starts a background goroutine for eviction.\nfunc NewMemoryLimiter(requestsPerMinute int, burst int, cleanupInterval time.Duration) *MemoryLimiter {\n    m := &amp;MemoryLimiter{\n        rate:            rate.Every(time.Minute / time.Duration(requestsPerMinute)),\n        burst:           burst,\n        limit:           requestsPerMinute,\n        cleanupInterval: cleanupInterval,\n        entries:         make(map[string]*entry),\n        done:            make(chan struct{}),\n    }\n    go m.cleanup()\n    return m\n}\n\n// Allow checks whether a request from the given key should be allowed.\nfunc (m *MemoryLimiter) Allow(key string) (bool, Info) {\n    m.mu.Lock()\n    e, exists := m.entries[key]\n    if !exists {\n        e = &amp;entry{\n            limiter: rate.NewLimiter(m.rate, m.burst),\n        }\n        m.entries[key] = e\n    }\n    e.lastSeen = time.Now()\n    m.mu.Unlock()\n\n    allowed := e.limiter.Allow()\n\n    now := time.Now()\n    tokens := e.limiter.TokensAt(now)\n    remaining := int(math.Max(0, math.Floor(tokens)))\n\n    // Calculate reset time: how long until the bucket is full again\n    tokensNeeded := float64(m.burst) - tokens\n    var resetAt time.Time\n    if tokensNeeded &gt; 0 {\n        resetDuration := time.Duration(tokensNeeded / float64(m.rate) * float64(time.Second))\n        resetAt = now.Add(resetDuration)\n    } else {\n        resetAt = now\n    }\n\n    info := Info{\n        Limit:     m.limit,\n        Remaining: remaining,\n        ResetAt:   resetAt,\n    }\n\n    if !allowed {\n        // Calculate retry-after: time until the next token is available\n        reservation := e.limiter.Reserve()\n        delay := reservation.Delay()\n        reservation.Cancel()\n        info.RetryAfter = delay\n    }\n\n    return allowed, info\n}\n\n// Close stops the background cleanup goroutine.\nfunc (m *MemoryLimiter) Close() {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    if !m.closed {\n        m.closed = true\n        close(m.done)\n    }\n}\n\n// cleanup periodically evicts entries that have not been accessed within\n// 2x the cleanup interval.\nfunc (m *MemoryLimiter) cleanup() {\n    ticker := time.NewTicker(m.cleanupInterval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case &lt;-m.done:\n            return\n        case &lt;-ticker.C:\n            m.evictStale()\n        }\n    }\n}\n\n// evictStale removes entries older than 2x the cleanup interval.\nfunc (m *MemoryLimiter) evictStale() {\n    cutoff := time.Now().Add(-2 * m.cleanupInterval)\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    for key, e := range m.entries {\n        if e.lastSeen.Before(cutoff) {\n            delete(m.entries, key)\n        }\n    }\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>go test ./internal/ratelimit/ -v -race</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add internal/ratelimit/memory.go internal/ratelimit/memory_test.go\ngit commit -m \"feat: implement MemoryLimiter with token bucket and cleanup\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-5-create-rate-limit-middleware","title":"Task 5: Create rate limit middleware","text":"<p>Files: - Create: <code>internal/ratelimit/middleware.go</code> - Create: <code>internal/ratelimit/middleware_test.go</code></p> <p>Step 1: Write the failing tests</p> <p>Create <code>internal/ratelimit/middleware_test.go</code>:</p> <pre><code>package ratelimit\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"strconv\"\n    \"testing\"\n    \"time\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n\n    \"updater/internal/models\"\n)\n\nfunc okHandler(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc TestMiddleware_AllowedRequest(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 5*time.Minute)\n    defer limiter.Close()\n\n    handler := Middleware(limiter, limiter)(http.HandlerFunc(okHandler))\n\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"192.168.1.1:12345\"\n    rr := httptest.NewRecorder()\n\n    handler.ServeHTTP(rr, req)\n\n    assert.Equal(t, http.StatusOK, rr.Code)\n    assert.NotEmpty(t, rr.Header().Get(\"X-RateLimit-Limit\"))\n    assert.NotEmpty(t, rr.Header().Get(\"X-RateLimit-Remaining\"))\n    assert.NotEmpty(t, rr.Header().Get(\"X-RateLimit-Reset\"))\n}\n\nfunc TestMiddleware_DeniedRequest(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 2, 5*time.Minute)\n    defer limiter.Close()\n\n    handler := Middleware(limiter, limiter)(http.HandlerFunc(okHandler))\n\n    for i := 0; i &lt; 2; i++ {\n        req := httptest.NewRequest(\"GET\", \"/test\", nil)\n        req.RemoteAddr = \"192.168.1.1:12345\"\n        rr := httptest.NewRecorder()\n        handler.ServeHTTP(rr, req)\n        assert.Equal(t, http.StatusOK, rr.Code)\n    }\n\n    // Third request should be denied\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"192.168.1.1:12345\"\n    rr := httptest.NewRecorder()\n    handler.ServeHTTP(rr, req)\n\n    assert.Equal(t, http.StatusTooManyRequests, rr.Code)\n    assert.NotEmpty(t, rr.Header().Get(\"Retry-After\"))\n    assert.NotEmpty(t, rr.Header().Get(\"X-RateLimit-Limit\"))\n\n    // Verify JSON error body\n    var errResp map[string]interface{}\n    err := json.NewDecoder(rr.Body).Decode(&amp;errResp)\n    require.NoError(t, err)\n    assert.Equal(t, \"Rate limit exceeded\", errResp[\"error\"])\n}\n\nfunc TestMiddleware_AuthenticatedRequest(t *testing.T) {\n    anonLimiter := NewMemoryLimiter(60, 2, 5*time.Minute)\n    defer anonLimiter.Close()\n    authLimiter := NewMemoryLimiter(120, 5, 5*time.Minute)\n    defer authLimiter.Close()\n\n    handler := Middleware(anonLimiter, authLimiter)(http.HandlerFunc(okHandler))\n\n    apiKey := &amp;models.APIKey{\n        Key:         \"test-key\",\n        Name:        \"Test Key\",\n        Permissions: []string{\"read\"},\n        Enabled:     true,\n    }\n\n    // Anonymous requests exhaust burst of 2\n    for i := 0; i &lt; 2; i++ {\n        req := httptest.NewRequest(\"GET\", \"/test\", nil)\n        req.RemoteAddr = \"192.168.1.1:12345\"\n        rr := httptest.NewRecorder()\n        handler.ServeHTTP(rr, req)\n        assert.Equal(t, http.StatusOK, rr.Code)\n    }\n\n    // Anonymous is now denied\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"192.168.1.1:12345\"\n    rr := httptest.NewRecorder()\n    handler.ServeHTTP(rr, req)\n    assert.Equal(t, http.StatusTooManyRequests, rr.Code)\n\n    // Authenticated request from same IP should still be allowed (different key)\n    req = httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"192.168.1.1:12345\"\n    ctx := context.WithValue(req.Context(), \"api_key\", apiKey)\n    req = req.WithContext(ctx)\n    rr = httptest.NewRecorder()\n    handler.ServeHTTP(rr, req)\n    assert.Equal(t, http.StatusOK, rr.Code)\n\n    // Verify authenticated limit header is 120\n    limit, err := strconv.Atoi(rr.Header().Get(\"X-RateLimit-Limit\"))\n    require.NoError(t, err)\n    assert.Equal(t, 120, limit)\n}\n\nfunc TestMiddleware_XForwardedFor(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 5*time.Minute)\n    defer limiter.Close()\n\n    handler := Middleware(limiter, limiter)(http.HandlerFunc(okHandler))\n\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"10.0.0.1:12345\"\n    req.Header.Set(\"X-Forwarded-For\", \"203.0.113.50, 70.41.3.18\")\n    rr := httptest.NewRecorder()\n\n    handler.ServeHTTP(rr, req)\n    assert.Equal(t, http.StatusOK, rr.Code)\n}\n\nfunc TestMiddleware_XRealIP(t *testing.T) {\n    limiter := NewMemoryLimiter(60, 10, 5*time.Minute)\n    defer limiter.Close()\n\n    handler := Middleware(limiter, limiter)(http.HandlerFunc(okHandler))\n\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    req.RemoteAddr = \"10.0.0.1:12345\"\n    req.Header.Set(\"X-Real-IP\", \"203.0.113.50\")\n    rr := httptest.NewRecorder()\n\n    handler.ServeHTTP(rr, req)\n    assert.Equal(t, http.StatusOK, rr.Code)\n}\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>go test ./internal/ratelimit/ -run \"TestMiddleware\" -v</code> Expected: FAIL -- <code>Middleware</code> not defined</p> <p>Step 3: Implement the middleware</p> <p>Create <code>internal/ratelimit/middleware.go</code>:</p> <pre><code>package ratelimit\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log/slog\"\n    \"net/http\"\n    \"strings\"\n\n    \"updater/internal/models\"\n)\n\n// Middleware returns HTTP middleware that enforces rate limits. It takes two\n// limiters: one for anonymous requests (keyed by IP) and one for authenticated\n// requests (keyed by API key name). The middleware reads the \"api_key\" context\n// value set by the auth middleware to determine which limiter to use.\nfunc Middleware(anonymous Limiter, authenticated Limiter) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            key, limiter := resolveKeyAndLimiter(r, anonymous, authenticated)\n\n            allowed, info := limiter.Allow(key)\n\n            // Always set rate limit headers\n            w.Header().Set(\"X-RateLimit-Limit\", fmt.Sprintf(\"%d\", info.Limit))\n            w.Header().Set(\"X-RateLimit-Remaining\", fmt.Sprintf(\"%d\", info.Remaining))\n            w.Header().Set(\"X-RateLimit-Reset\", fmt.Sprintf(\"%d\", info.ResetAt.Unix()))\n\n            if !allowed {\n                retryAfterSecs := int(info.RetryAfter.Seconds()) + 1\n                w.Header().Set(\"Retry-After\", fmt.Sprintf(\"%d\", retryAfterSecs))\n                w.Header().Set(\"Content-Type\", \"application/json\")\n                w.WriteHeader(http.StatusTooManyRequests)\n\n                errorResp := models.NewErrorResponse(\"Rate limit exceeded\", \"RATE_LIMIT_EXCEEDED\")\n                json.NewEncoder(w).Encode(errorResp)\n\n                slog.Warn(\"Rate limit exceeded\",\n                    \"key\", key,\n                    \"limit\", info.Limit,\n                    \"retry_after\", retryAfterSecs,\n                )\n                return\n            }\n\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n\n// resolveKeyAndLimiter determines the rate limit key and which limiter to use\n// based on the request's authentication context.\nfunc resolveKeyAndLimiter(r *http.Request, anonymous Limiter, authenticated Limiter) (string, Limiter) {\n    if apiKey, ok := r.Context().Value(\"api_key\").(*models.APIKey); ok &amp;&amp; apiKey != nil {\n        return \"auth:\" + apiKey.Name, authenticated\n    }\n    return getClientIP(r), anonymous\n}\n\n// getClientIP extracts the client IP from the request, checking proxy headers.\nfunc getClientIP(r *http.Request) string {\n    if xff := r.Header.Get(\"X-Forwarded-For\"); xff != \"\" {\n        ips := strings.Split(xff, \",\")\n        if len(ips) &gt; 0 {\n            return strings.TrimSpace(ips[0])\n        }\n    }\n\n    if xri := r.Header.Get(\"X-Real-IP\"); xri != \"\" {\n        return xri\n    }\n\n    return r.RemoteAddr\n}\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>go test ./internal/ratelimit/ -v -race</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add internal/ratelimit/middleware.go internal/ratelimit/middleware_test.go\ngit commit -m \"feat: add rate limit HTTP middleware with auth-aware two-tier support\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-6-integrate-into-routes-and-main","title":"Task 6: Integrate into routes and main","text":"<p>Files: - Modify: <code>internal/api/routes.go:240-270</code> (remove rateLimitMiddleware, add WithRateLimiter RouteOption) - Modify: <code>cmd/updater/updater.go:84-89</code> (create limiter, pass as RouteOption)</p> <p>Step 1: Add WithRateLimiter RouteOption to routes.go</p> <p>Add a new <code>RouteOption</code> constructor and remove the inline <code>rateLimitMiddleware</code>. In <code>internal/api/routes.go</code>:</p> <p>Remove the entire <code>rateLimitMiddleware</code> function (lines 241-270).</p> <p>Remove the rate limit application block in <code>SetupRoutes</code> (lines 74-77): <pre><code>// Remove this block:\nif config.Security.RateLimit.Enabled {\n    router.Use(rateLimitMiddleware(config.Security.RateLimit))\n}\n</code></pre></p> <p>Add a new <code>RouteOption</code> after the existing <code>WithOTelMiddleware</code>:</p> <pre><code>// WithRateLimiter adds rate limiting middleware to the router.\nfunc WithRateLimiter(middleware func(http.Handler) http.Handler) RouteOption {\n    return func(r *mux.Router) {\n        r.Use(middleware)\n    }\n}\n</code></pre> <p>Also remove the now-unused imports: <code>\"sync\"</code> and <code>\"time\"</code> (only if they are no longer used elsewhere in routes.go).</p> <p>Step 2: Update cmd/updater/updater.go</p> <p>Add <code>\"updater/internal/ratelimit\"</code> to the imports.</p> <p>After the handlers are created and before <code>SetupRoutes</code> is called (around line 84-89), add:</p> <pre><code>// Initialize rate limiter if enabled\nif cfg.Security.RateLimit.Enabled {\n    rlCfg := cfg.Security.RateLimit\n\n    // Default authenticated values to 2x anonymous if not set\n    authRPM := rlCfg.AuthenticatedRequestsPerMinute\n    if authRPM == 0 {\n        authRPM = rlCfg.RequestsPerMinute * 2\n    }\n    authBurst := rlCfg.AuthenticatedBurstSize\n    if authBurst == 0 {\n        authBurst = rlCfg.BurstSize * 2\n    }\n\n    anonLimiter := ratelimit.NewMemoryLimiter(rlCfg.RequestsPerMinute, rlCfg.BurstSize, rlCfg.CleanupInterval)\n    authLimiter := ratelimit.NewMemoryLimiter(authRPM, authBurst, rlCfg.CleanupInterval)\n    defer anonLimiter.Close()\n    defer authLimiter.Close()\n\n    routeOpts = append(routeOpts, api.WithRateLimiter(ratelimit.Middleware(anonLimiter, authLimiter)))\n}\n</code></pre> <p>Step 3: Run all tests</p> <p>Run: <code>go test ./... -race</code> Expected: PASS (the existing <code>TestRateLimiting</code> in <code>security_test.go</code> will need updating -- see next step)</p> <p>Step 4: Update existing rate limit test in security_test.go</p> <p>The <code>TestRateLimiting</code> test in <code>internal/api/security_test.go</code> (around line 690) tests the old inline middleware. Since rate limiting is no longer applied by <code>SetupRoutes</code> directly (it is now a <code>RouteOption</code>), this test needs to be updated.</p> <p>Update it to use the new <code>WithRateLimiter</code> option:</p> <pre><code>func TestRateLimiting(t *testing.T) {\n    config := &amp;models.Config{\n        Security: models.SecurityConfig{\n            EnableAuth: false,\n            RateLimit: models.RateLimitConfig{\n                Enabled:           true,\n                RequestsPerMinute: 5,\n                BurstSize:         5,\n                CleanupInterval:   5 * time.Minute,\n            },\n        },\n    }\n\n    updateService := setupTestUpdateService()\n    handlers := NewHandlers(updateService)\n\n    limiter := ratelimit.NewMemoryLimiter(\n        config.Security.RateLimit.RequestsPerMinute,\n        config.Security.RateLimit.BurstSize,\n        config.Security.RateLimit.CleanupInterval,\n    )\n    defer limiter.Close()\n\n    router := SetupRoutes(handlers, config,\n        WithRateLimiter(ratelimit.Middleware(limiter, limiter)),\n    )\n\n    clientIP := \"192.168.1.100\"\n\n    var rateLimitHit bool\n    for i := 0; i &lt; 10; i++ {\n        req := httptest.NewRequest(\"GET\", \"/api/v1/updates/test/check\", nil)\n        req.RemoteAddr = clientIP + \":12345\"\n        rr := httptest.NewRecorder()\n        router.ServeHTTP(rr, req)\n\n        if rr.Code == http.StatusTooManyRequests {\n            rateLimitHit = true\n            break\n        }\n    }\n\n    assert.True(t, rateLimitHit, \"Rate limiting should trigger after exceeding limit\")\n}\n</code></pre> <p>Add <code>\"updater/internal/ratelimit\"</code> and <code>\"time\"</code> to the imports of <code>security_test.go</code>.</p> <p>Step 5: Run all tests</p> <p>Run: <code>go test ./... -race</code> Expected: PASS</p> <p>Step 6: Commit</p> <pre><code>git add internal/api/routes.go internal/api/security_test.go cmd/updater/updater.go\ngit commit -m \"feat: integrate rate limiter into route setup and server startup\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-7-write-documentation","title":"Task 7: Write documentation","text":"<p>Files: - Create: <code>docs/rate-limiting.md</code> - Modify: <code>mkdocs.yml</code> (add to nav)</p> <p>Step 1: Create the documentation page</p> <p>Create <code>docs/rate-limiting.md</code> covering: - Overview of the token bucket algorithm - Configuration reference (all <code>RateLimitConfig</code> fields) - Two-tier rate limits (anonymous vs authenticated) - Response headers reference - Example config YAML - Mermaid diagram showing the request flow (reuse from design doc)</p> <p>Step 2: Add to mkdocs.yml nav</p> <p>Add <code>- Rate Limiting: rate-limiting.md</code> after the Security section in the nav.</p> <p>Step 3: Commit</p> <pre><code>git add docs/rate-limiting.md mkdocs.yml\ngit commit -m \"docs: add rate limiting documentation page\"\n</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-8-final-verification","title":"Task 8: Final verification","text":"<p>Step 1: Run full test suite</p> <p>Run: <code>go test ./... -race -count=1</code> Expected: All tests PASS</p> <p>Step 2: Build the binary</p> <p>Run: <code>make build</code> Expected: <code>bin/updater</code> built successfully</p> <p>Step 3: Run linting and formatting</p> <p>Run: <code>make check</code> Expected: PASS (fmt + vet + test all succeed)</p> <p>Step 4: Verify no compilation warnings</p> <p>Run: <code>go vet ./...</code> Expected: No output (clean)</p>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#task-dependency-graph","title":"Task Dependency Graph","text":"<pre><code>graph TD\n    T1[Task 1: Add dependency] --&gt; T4[Task 4: MemoryLimiter]\n    T2[Task 2: Update config] --&gt; T6[Task 6: Integration]\n    T3[Task 3: Limiter interface] --&gt; T4\n    T4 --&gt; T5[Task 5: Middleware]\n    T5 --&gt; T6\n    T6 --&gt; T7[Task 7: Documentation]\n    T6 --&gt; T8[Task 8: Final verification]\n    T7 --&gt; T8</code></pre>"},{"location":"plans/2026-02-15-rate-limiter-implementation/#summary-of-all-files","title":"Summary of All Files","text":"File Action Task <code>go.mod</code>, <code>go.sum</code> Modify 1 <code>internal/models/config.go</code> Modify 2 <code>internal/models/config_test.go</code> Modify 2 <code>internal/config/config_test.go</code> Modify 2 <code>internal/integration/integration_test.go</code> Modify 2 <code>internal/ratelimit/limiter.go</code> Create 3 <code>internal/ratelimit/memory.go</code> Create 4 <code>internal/ratelimit/memory_test.go</code> Create 4 <code>internal/ratelimit/middleware.go</code> Create 5 <code>internal/ratelimit/middleware_test.go</code> Create 5 <code>internal/api/routes.go</code> Modify 6 <code>internal/api/security_test.go</code> Modify 6 <code>cmd/updater/updater.go</code> Modify 6 <code>docs/rate-limiting.md</code> Create 7 <code>mkdocs.yml</code> Modify 7"},{"location":"plans/2026-02-16-admin-frontend/","title":"Admin Frontend Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a server-rendered HTMX + Go templates admin UI at <code>/admin</code>, embedded in the binary, covering API key login, application CRUD, release management, and a health dashboard.</p> <p>Architecture: Templates live in <code>internal/api/admin/templates/</code> and are embedded via <code>go:embed</code>. A new <code>adminSessionMiddleware</code> validates an HttpOnly session cookie set at login \u2014 skipping auth only for <code>/admin/login</code> and <code>/admin/logout</code>. Admin handlers call <code>update.ServiceInterface</code> and <code>storage.Storage</code> directly; no HTTP round-trips. Standard HTML forms handle creates/edits (Post-Redirect-Get); HTMX handles deletes inline (row removal without page reload). Full-page navigations receive full HTML; HTMX delete requests receive a 200 OK with empty body.</p> <p>Tech Stack: Go <code>html/template</code> (stdlib), <code>go:embed</code> (stdlib), HTMX 2.x (unpkg CDN), Tailwind CSS 3.x Play CDN, gorilla/mux subrouter.</p>"},{"location":"plans/2026-02-16-admin-frontend/#file-map","title":"File Map","text":"<pre><code>internal/api/\n  admin/\n    templates/\n      layout.html                     # \"head\" and \"nav\" named templates\n      login.html                      # defines \"login\" named template\n      health.html                     # defines \"health\" named template\n      applications.html               # defines \"applications\" named template\n      application.html                # defines \"application\" named template\n      partials/\n        flash.html                    # defines \"flash\" named template\n        app-row.html                  # defines \"app-row\" named template\n        release-row.html              # defines \"release-row\" named template\n  handlers_admin.go                   # go:embed + render helper + all admin handlers\n  handlers_admin_test.go              # handler tests\n  middleware_admin.go                 # adminSessionMiddleware + isValidAdminKey\n  middleware_admin_test.go            # middleware tests\n  routes.go                           # modified: add admin subrouter\n  handlers.go                         # modified: add adminTmpl + securityConfig fields\ndocs/\n  admin-ui.md                         # new documentation page\nmkdocs.yml                            # modified: add admin-ui.md to nav\ncmd/updater/updater.go                # modified: parse templates + pass options\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-1-extend-the-handlers-struct","title":"Task 1: Extend the Handlers struct","text":"<p>Files: - Modify: <code>internal/api/handlers.go</code></p> <p>The <code>Handlers</code> struct needs to carry the parsed admin templates and the security config so admin handlers can validate sessions.</p> <p>Step 1: Write failing tests</p> <p>Add to <code>internal/api/handlers_test.go</code>:</p> <pre><code>func TestNewHandlers_WithAdminTemplates(t *testing.T) {\n    tmpl := template.Must(template.New(\"test\").Parse(`{{define \"test\"}}ok{{end}}`))\n    h := NewHandlers(&amp;MockUpdateService{}, WithAdminTemplates(tmpl))\n    assert.NotNil(t, h.adminTmpl)\n}\n\nfunc TestNewHandlers_WithSecurityConfig(t *testing.T) {\n    cfg := models.SecurityConfig{EnableAuth: true}\n    h := NewHandlers(&amp;MockUpdateService{}, WithSecurityConfig(cfg))\n    assert.True(t, h.securityConfig.EnableAuth)\n}\n</code></pre> <p>Add <code>\"html/template\"</code> to the imports in that file.</p> <p>Step 2: Run tests to verify they fail</p> <pre><code>make test 2&gt;&amp;1 | grep -A3 \"FAIL\\|undefined\"\n</code></pre> <p>Expected: compile error \u2014 <code>WithAdminTemplates</code>, <code>WithSecurityConfig</code>, <code>adminTmpl</code>, <code>securityConfig</code> undefined.</p> <p>Step 3: Implement</p> <p>In <code>internal/api/handlers.go</code>, add to the <code>Handlers</code> struct and add two options:</p> <pre><code>import \"html/template\"\n\ntype Handlers struct {\n    updateService  update.ServiceInterface\n    storage        storage.Storage\n    adminTmpl      *template.Template    // new\n    securityConfig models.SecurityConfig  // new\n}\n\n// WithAdminTemplates sets the parsed admin template set.\nfunc WithAdminTemplates(tmpl *template.Template) HandlersOption {\n    return func(h *Handlers) { h.adminTmpl = tmpl }\n}\n\n// WithSecurityConfig stores the security config for admin session validation.\nfunc WithSecurityConfig(cfg models.SecurityConfig) HandlersOption {\n    return func(h *Handlers) { h.securityConfig = cfg }\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers.go internal/api/handlers_test.go\ngit commit -m \"feat(admin): add adminTmpl and securityConfig fields to Handlers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-2-admin-session-middleware","title":"Task 2: Admin session middleware","text":"<p>Files: - Create: <code>internal/api/middleware_admin.go</code> - Create: <code>internal/api/middleware_admin_test.go</code></p> <p>Step 1: Write failing tests</p> <p>Create <code>internal/api/middleware_admin_test.go</code>:</p> <pre><code>package api\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n    \"updater/internal/models\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc okHandler(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }\n\nvar adminKey = models.APIKey{\n    Key:         \"secret\",\n    Name:        \"test\",\n    Permissions: []string{\"admin\"},\n    Enabled:     true,\n}\n\nvar cfgWithKey = models.SecurityConfig{APIKeys: []models.APIKey{adminKey}}\nvar cfgNoKeys  = models.SecurityConfig{}\n\nfunc makeAdminReq(path, cookieVal string) *http.Request {\n    req := httptest.NewRequest(http.MethodGet, path, nil)\n    if cookieVal != \"\" {\n        req.AddCookie(&amp;http.Cookie{Name: \"admin_session\", Value: cookieVal})\n    }\n    return req\n}\n\nfunc TestAdminMiddleware_NoCookie_Redirects(t *testing.T) {\n    mw := adminSessionMiddleware(cfgWithKey)\n    rec := httptest.NewRecorder()\n    mw(http.HandlerFunc(okHandler)).ServeHTTP(rec, makeAdminReq(\"/admin/applications\", \"\"))\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    assert.Equal(t, \"/admin/login\", rec.Header().Get(\"Location\"))\n}\n\nfunc TestAdminMiddleware_InvalidKey_Redirects(t *testing.T) {\n    mw := adminSessionMiddleware(cfgWithKey)\n    rec := httptest.NewRecorder()\n    mw(http.HandlerFunc(okHandler)).ServeHTTP(rec, makeAdminReq(\"/admin/applications\", \"wrong\"))\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n}\n\nfunc TestAdminMiddleware_ValidKey_Passes(t *testing.T) {\n    mw := adminSessionMiddleware(cfgWithKey)\n    rec := httptest.NewRecorder()\n    mw(http.HandlerFunc(okHandler)).ServeHTTP(rec, makeAdminReq(\"/admin/applications\", \"secret\"))\n    assert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestAdminMiddleware_SkipsLogin(t *testing.T) {\n    mw := adminSessionMiddleware(cfgWithKey)\n    rec := httptest.NewRecorder()\n    mw(http.HandlerFunc(okHandler)).ServeHTTP(rec, makeAdminReq(\"/admin/login\", \"\"))\n    assert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestAdminMiddleware_SkipsLogout(t *testing.T) {\n    mw := adminSessionMiddleware(cfgWithKey)\n    rec := httptest.NewRecorder()\n    mw(http.HandlerFunc(okHandler)).ServeHTTP(rec, makeAdminReq(\"/admin/logout\", \"\"))\n    assert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestIsValidAdminKey_NoKeysConfigured_AcceptsAny(t *testing.T) {\n    assert.True(t, isValidAdminKey(\"anything\", cfgNoKeys))\n}\n\nfunc TestIsValidAdminKey_EmptyKeyNoKeys_Rejects(t *testing.T) {\n    assert.False(t, isValidAdminKey(\"\", cfgNoKeys))\n}\n\nfunc TestIsValidAdminKey_ValidAdminKey(t *testing.T) {\n    assert.True(t, isValidAdminKey(\"secret\", cfgWithKey))\n}\n\nfunc TestIsValidAdminKey_NonAdminKey_Rejects(t *testing.T) {\n    readOnlyCfg := models.SecurityConfig{APIKeys: []models.APIKey{\n        {Key: \"readkey\", Name: \"r\", Permissions: []string{\"read\"}, Enabled: true},\n    }}\n    assert.False(t, isValidAdminKey(\"readkey\", readOnlyCfg))\n}\n\nfunc TestIsValidAdminKey_DisabledKey_Rejects(t *testing.T) {\n    disabledCfg := models.SecurityConfig{APIKeys: []models.APIKey{\n        {Key: \"secret\", Name: \"d\", Permissions: []string{\"admin\"}, Enabled: false},\n    }}\n    assert.False(t, isValidAdminKey(\"secret\", disabledCfg))\n}\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"FAIL|undefined\"\n</code></pre> <p>Expected: compile error \u2014 <code>adminSessionMiddleware</code>, <code>isValidAdminKey</code> undefined.</p> <p>Step 3: Implement</p> <p>Create <code>internal/api/middleware_admin.go</code>:</p> <pre><code>package api\n\nimport (\n    \"net/http\"\n    \"strings\"\n    \"updater/internal/models\"\n\n    \"github.com/gorilla/mux\"\n)\n\n// adminSessionMiddleware validates the HttpOnly admin_session cookie.\n// Requests to /admin/login and /admin/logout are always passed through.\nfunc adminSessionMiddleware(cfg models.SecurityConfig) mux.MiddlewareFunc {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            // Login and logout pages are exempt.\n            if strings.HasSuffix(r.URL.Path, \"/login\") || strings.HasSuffix(r.URL.Path, \"/logout\") {\n                next.ServeHTTP(w, r)\n                return\n            }\n\n            cookie, err := r.Cookie(\"admin_session\")\n            if err != nil || !isValidAdminKey(cookie.Value, cfg) {\n                // Clear any stale cookie.\n                http.SetCookie(w, &amp;http.Cookie{\n                    Name:   \"admin_session\",\n                    Value:  \"\",\n                    Path:   \"/admin\",\n                    MaxAge: -1,\n                })\n                http.Redirect(w, r, \"/admin/login\", http.StatusSeeOther)\n                return\n            }\n\n            next.ServeHTTP(w, r)\n        })\n    }\n}\n\n// isValidAdminKey returns true when key is authorised to access the admin UI.\n// If no API keys are configured the service is in dev mode and any non-empty\n// string is accepted.\nfunc isValidAdminKey(key string, cfg models.SecurityConfig) bool {\n    if key == \"\" {\n        return false\n    }\n    if len(cfg.APIKeys) == 0 {\n        return true // dev mode\n    }\n    for _, ak := range cfg.APIKeys {\n        if ak.Key != key || !ak.Enabled {\n            continue\n        }\n        for _, p := range ak.Permissions {\n            if p == \"admin\" || p == \"*\" {\n                return true\n            }\n        }\n    }\n    return false\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/middleware_admin.go internal/api/middleware_admin_test.go\ngit commit -m \"feat(admin): add adminSessionMiddleware and isValidAdminKey\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-3-template-files","title":"Task 3: Template files","text":"<p>Files: - Create: <code>internal/api/admin/templates/layout.html</code> - Create: <code>internal/api/admin/templates/login.html</code> - Create: <code>internal/api/admin/templates/health.html</code> - Create: <code>internal/api/admin/templates/applications.html</code> - Create: <code>internal/api/admin/templates/application.html</code> - Create: <code>internal/api/admin/templates/partials/flash.html</code> - Create: <code>internal/api/admin/templates/partials/app-row.html</code> - Create: <code>internal/api/admin/templates/partials/release-row.html</code></p> <p>No tests for templates directly; they are covered via handler tests in Task 5+.</p> <p>Step 1: Create <code>layout.html</code> \u2014 shared head and nav fragments used by every page template.</p> <pre><code>{{define \"head\"}}\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;script src=\"https://unpkg.com/htmx.org@2/dist/htmx.min.js\" defer&gt;&lt;/script&gt;\n&lt;script src=\"https://cdn.tailwindcss.com\"&gt;&lt;/script&gt;\n{{end}}\n\n{{define \"nav\"}}\n&lt;nav class=\"bg-gray-900 text-white px-6 py-3 flex items-center gap-6\"&gt;\n  &lt;span class=\"font-bold text-lg\"&gt;Updater Admin&lt;/span&gt;\n  &lt;a href=\"/admin/applications\" class=\"hover:underline\"&gt;Applications&lt;/a&gt;\n  &lt;a href=\"/admin/health\" class=\"hover:underline\"&gt;Health&lt;/a&gt;\n  &lt;a href=\"/api/v1/docs\" target=\"_blank\" class=\"hover:underline\"&gt;API Docs&lt;/a&gt;\n  &lt;form method=\"POST\" action=\"/admin/logout\" class=\"ml-auto\"&gt;\n    &lt;button type=\"submit\" class=\"text-sm hover:underline\"&gt;Log out&lt;/button&gt;\n  &lt;/form&gt;\n&lt;/nav&gt;\n{{end}}\n</code></pre> <p>Step 2: Create <code>login.html</code></p> <pre><code>{{define \"login\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;Login - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-100 flex items-center justify-center min-h-screen\"&gt;\n  &lt;div class=\"bg-white p-8 rounded shadow w-96\"&gt;\n    &lt;h1 class=\"text-2xl font-bold mb-6\"&gt;Admin Login&lt;/h1&gt;\n    {{if .Error}}\n    &lt;p class=\"text-red-600 mb-4\"&gt;{{.Error}}&lt;/p&gt;\n    {{end}}\n    &lt;form method=\"POST\" action=\"/admin/login\"&gt;\n      &lt;label class=\"block mb-2 font-medium\"&gt;API Key&lt;/label&gt;\n      &lt;input type=\"password\" name=\"api_key\"\n             class=\"w-full border rounded px-3 py-2 mb-4 focus:outline-none focus:ring\"\n             placeholder=\"Enter your admin API key\" autofocus&gt;\n      &lt;button type=\"submit\"\n              class=\"w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700\"&gt;\n        Sign in\n      &lt;/button&gt;\n    &lt;/form&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre> <p>Step 3: Create <code>health.html</code></p> <pre><code>{{define \"health\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;Health - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-4xl mx-auto p-6\"&gt;\n  &lt;h1 class=\"text-2xl font-bold mb-6\"&gt;Service Health&lt;/h1&gt;\n  &lt;div class=\"bg-white rounded shadow p-6 mb-4\"&gt;\n    &lt;p class=\"text-lg\"&gt;Status:\n      &lt;span class=\"font-bold {{if eq .Health.Status \"healthy\"}}text-green-600{{else}}text-red-600{{end}}\"&gt;\n        {{.Health.Status}}\n      &lt;/span&gt;\n    &lt;/p&gt;\n    &lt;p class=\"text-gray-500 text-sm mt-1\"&gt;{{.Health.Timestamp}}&lt;/p&gt;\n    {{if .Health.Version}}&lt;p class=\"mt-2\"&gt;Version: {{.Health.Version}}&lt;/p&gt;{{end}}\n    {{if .Health.Uptime}}&lt;p&gt;Uptime: {{.Health.Uptime}}&lt;/p&gt;{{end}}\n  &lt;/div&gt;\n  {{if .Health.Components}}\n  &lt;h2 class=\"text-xl font-semibold mb-3\"&gt;Components&lt;/h2&gt;\n  &lt;div class=\"space-y-2\"&gt;\n    {{range $name, $comp := .Health.Components}}\n    &lt;div class=\"bg-white rounded shadow p-4 flex justify-between items-center\"&gt;\n      &lt;span class=\"font-medium\"&gt;{{$name}}&lt;/span&gt;\n      &lt;span class=\"{{if eq $comp.Status \"healthy\"}}text-green-600{{else}}text-red-600{{end}}\"&gt;\n        {{$comp.Status}}{{if $comp.Message}} \u2014 {{$comp.Message}}{{end}}\n      &lt;/span&gt;\n    &lt;/div&gt;\n    {{end}}\n  &lt;/div&gt;\n  {{end}}\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre> <p>Step 4: Create <code>applications.html</code></p> <pre><code>{{define \"applications\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;Applications - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-6xl mx-auto p-6\"&gt;\n  &lt;div class=\"flex items-center justify-between mb-6\"&gt;\n    &lt;h1 class=\"text-2xl font-bold\"&gt;Applications&lt;/h1&gt;\n    &lt;a href=\"/admin/applications/new\"\n       class=\"bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700\"&gt;\n      New Application\n    &lt;/a&gt;\n  &lt;/div&gt;\n\n  {{if .Flash}}{{template \"flash\" .Flash}}{{end}}\n\n  &lt;div class=\"bg-white rounded shadow overflow-hidden\"&gt;\n    &lt;table class=\"w-full text-sm\"&gt;\n      &lt;thead class=\"bg-gray-100 text-left\"&gt;\n        &lt;tr&gt;\n          &lt;th class=\"px-4 py-3\"&gt;ID&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Name&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Platforms&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Updated&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;/thead&gt;\n      &lt;tbody id=\"app-list\" class=\"divide-y\"&gt;\n        {{range .Applications.Applications}}\n          {{template \"app-row\" .}}\n        {{else}}\n        &lt;tr&gt;&lt;td colspan=\"5\" class=\"px-4 py-6 text-center text-gray-400\"&gt;No applications yet.&lt;/td&gt;&lt;/tr&gt;\n        {{end}}\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n\n  {{if .Applications.HasMore}}\n  &lt;p class=\"mt-4 text-gray-500 text-sm\"&gt;\n    Showing {{.Applications.PageSize}} of {{.Applications.TotalCount}} applications.\n  &lt;/p&gt;\n  {{end}}\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n{{define \"new-application-form\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;New Application - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-2xl mx-auto p-6\"&gt;\n  &lt;h1 class=\"text-2xl font-bold mb-6\"&gt;New Application&lt;/h1&gt;\n  {{if .Error}}&lt;p class=\"text-red-600 mb-4\"&gt;{{.Error}}&lt;/p&gt;{{end}}\n  &lt;form method=\"POST\" action=\"/admin/applications\" class=\"bg-white rounded shadow p-6 space-y-4\"&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;ID &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;input type=\"text\" name=\"id\" value=\"{{.Form.ID}}\"\n             class=\"w-full border rounded px-3 py-2\" placeholder=\"my-app\" required&gt;\n      &lt;p class=\"text-gray-400 text-xs mt-1\"&gt;Alphanumeric, hyphens, underscores. Max 100 chars.&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Name &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;input type=\"text\" name=\"name\" value=\"{{.Form.Name}}\"\n             class=\"w-full border rounded px-3 py-2\" required&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Description&lt;/label&gt;\n      &lt;input type=\"text\" name=\"description\" value=\"{{.Form.Description}}\"\n             class=\"w-full border rounded px-3 py-2\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Platforms &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;div class=\"flex gap-4 flex-wrap\"&gt;\n        {{range $p := .Platforms}}\n        &lt;label class=\"flex items-center gap-1\"&gt;\n          &lt;input type=\"checkbox\" name=\"platforms\" value=\"{{$p}}\"&gt; {{$p}}\n        &lt;/label&gt;\n        {{end}}\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"flex gap-3\"&gt;\n      &lt;button type=\"submit\" class=\"bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700\"&gt;\n        Create\n      &lt;/button&gt;\n      &lt;a href=\"/admin/applications\" class=\"px-6 py-2 border rounded hover:bg-gray-50\"&gt;Cancel&lt;/a&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre> <p>Step 5: Create <code>application.html</code></p> <pre><code>{{define \"application\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;{{.Application.Name}} - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-6xl mx-auto p-6\"&gt;\n  &lt;div class=\"flex items-center justify-between mb-4\"&gt;\n    &lt;div&gt;\n      &lt;a href=\"/admin/applications\" class=\"text-blue-600 hover:underline text-sm\"&gt;\u2190 Applications&lt;/a&gt;\n      &lt;h1 class=\"text-2xl font-bold mt-1\"&gt;{{.Application.Name}}&lt;/h1&gt;\n      &lt;p class=\"text-gray-500 text-sm\"&gt;{{.Application.ID}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=\"flex gap-2\"&gt;\n      &lt;a href=\"/admin/applications/{{.Application.ID}}/edit\"\n         class=\"border px-4 py-2 rounded hover:bg-gray-50\"&gt;Edit&lt;/a&gt;\n      &lt;button\n        hx-delete=\"/admin/applications/{{.Application.ID}}\"\n        hx-confirm=\"Delete {{.Application.Name}}? All releases must be removed first.\"\n        hx-target=\"body\"\n        hx-push-url=\"/admin/applications\"\n        class=\"bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700\"&gt;\n        Delete\n      &lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n\n  {{if .Flash}}{{template \"flash\" .Flash}}{{end}}\n\n  {{if .Application.Description}}\n  &lt;p class=\"text-gray-600 mb-6\"&gt;{{.Application.Description}}&lt;/p&gt;\n  {{end}}\n\n  &lt;!-- Stats --&gt;\n  {{if .Application.Stats}}\n  &lt;div class=\"grid grid-cols-3 gap-4 mb-6\"&gt;\n    &lt;div class=\"bg-white rounded shadow p-4\"&gt;\n      &lt;p class=\"text-gray-500 text-sm\"&gt;Total Releases&lt;/p&gt;\n      &lt;p class=\"text-2xl font-bold\"&gt;{{.Application.Stats.TotalReleases}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=\"bg-white rounded shadow p-4\"&gt;\n      &lt;p class=\"text-gray-500 text-sm\"&gt;Latest Version&lt;/p&gt;\n      &lt;p class=\"text-2xl font-bold\"&gt;{{.Application.Stats.LatestVersion}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=\"bg-white rounded shadow p-4\"&gt;\n      &lt;p class=\"text-gray-500 text-sm\"&gt;Platforms&lt;/p&gt;\n      &lt;p class=\"text-2xl font-bold\"&gt;{{.Application.Stats.PlatformCount}}&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  {{end}}\n\n  &lt;!-- Releases --&gt;\n  &lt;div class=\"flex items-center justify-between mb-3\"&gt;\n    &lt;h2 class=\"text-xl font-semibold\"&gt;Releases&lt;/h2&gt;\n    &lt;a href=\"/admin/applications/{{.Application.ID}}/releases/new\"\n       class=\"bg-green-600 text-white px-4 py-2 rounded text-sm hover:bg-green-700\"&gt;\n      Register Release\n    &lt;/a&gt;\n  &lt;/div&gt;\n\n  &lt;div class=\"bg-white rounded shadow overflow-hidden\"&gt;\n    &lt;table class=\"w-full text-sm\"&gt;\n      &lt;thead class=\"bg-gray-100 text-left\"&gt;\n        &lt;tr&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Version&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Platform&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Arch&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Required&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;Released&lt;/th&gt;\n          &lt;th class=\"px-4 py-3\"&gt;&lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;/thead&gt;\n      &lt;tbody id=\"release-list\" class=\"divide-y\"&gt;\n        {{range .Releases.Releases}}\n          {{template \"release-row\" .}}\n        {{else}}\n        &lt;tr&gt;&lt;td colspan=\"6\" class=\"px-4 py-6 text-center text-gray-400\"&gt;No releases yet.&lt;/td&gt;&lt;/tr&gt;\n        {{end}}\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n{{define \"edit-application-form\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;Edit {{.Application.Name}} - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-2xl mx-auto p-6\"&gt;\n  &lt;a href=\"/admin/applications/{{.Application.ID}}\" class=\"text-blue-600 hover:underline text-sm\"&gt;\n    \u2190 {{.Application.Name}}\n  &lt;/a&gt;\n  &lt;h1 class=\"text-2xl font-bold mt-2 mb-6\"&gt;Edit Application&lt;/h1&gt;\n  {{if .Error}}&lt;p class=\"text-red-600 mb-4\"&gt;{{.Error}}&lt;/p&gt;{{end}}\n  &lt;form method=\"POST\" action=\"/admin/applications/{{.Application.ID}}/edit\"\n        class=\"bg-white rounded shadow p-6 space-y-4\"&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Name &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;input type=\"text\" name=\"name\" value=\"{{.Application.Name}}\"\n             class=\"w-full border rounded px-3 py-2\" required&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Description&lt;/label&gt;\n      &lt;input type=\"text\" name=\"description\" value=\"{{.Application.Description}}\"\n             class=\"w-full border rounded px-3 py-2\"&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Platforms &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;div class=\"flex gap-4 flex-wrap\"&gt;\n        {{range $p := .Platforms}}\n        &lt;label class=\"flex items-center gap-1\"&gt;\n          &lt;input type=\"checkbox\" name=\"platforms\" value=\"{{$p}}\"\n                 {{if hasPlatform $.Application.Platforms $p}}checked{{end}}&gt; {{$p}}\n        &lt;/label&gt;\n        {{end}}\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=\"flex gap-3\"&gt;\n      &lt;button type=\"submit\" class=\"bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700\"&gt;\n        Save\n      &lt;/button&gt;\n      &lt;a href=\"/admin/applications/{{.Application.ID}}\"\n         class=\"px-6 py-2 border rounded hover:bg-gray-50\"&gt;Cancel&lt;/a&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n\n{{define \"new-release-form\"}}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;&lt;title&gt;New Release - Updater Admin&lt;/title&gt;{{template \"head\" .}}&lt;/head&gt;\n&lt;body class=\"bg-gray-50\"&gt;\n{{template \"nav\" .}}\n&lt;main class=\"max-w-2xl mx-auto p-6\"&gt;\n  &lt;a href=\"/admin/applications/{{.AppID}}\" class=\"text-blue-600 hover:underline text-sm\"&gt;\n    \u2190 Back to application\n  &lt;/a&gt;\n  &lt;h1 class=\"text-2xl font-bold mt-2 mb-6\"&gt;Register Release for {{.AppID}}&lt;/h1&gt;\n  {{if .Error}}&lt;p class=\"text-red-600 mb-4\"&gt;{{.Error}}&lt;/p&gt;{{end}}\n  &lt;form method=\"POST\" action=\"/admin/applications/{{.AppID}}/releases\"\n        class=\"bg-white rounded shadow p-6 space-y-4\"&gt;\n    &lt;div class=\"grid grid-cols-2 gap-4\"&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;Version &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n        &lt;input type=\"text\" name=\"version\" class=\"w-full border rounded px-3 py-2\"\n               placeholder=\"1.0.0\" required&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;Platform &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n        &lt;select name=\"platform\" class=\"w-full border rounded px-3 py-2\" required&gt;\n          &lt;option value=\"\"&gt;Select\u2026&lt;/option&gt;\n          {{range .Platforms}}&lt;option&gt;{{.}}&lt;/option&gt;{{end}}\n        &lt;/select&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;Architecture &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n        &lt;select name=\"architecture\" class=\"w-full border rounded px-3 py-2\" required&gt;\n          &lt;option value=\"\"&gt;Select\u2026&lt;/option&gt;\n          {{range .Architectures}}&lt;option&gt;{{.}}&lt;/option&gt;{{end}}\n        &lt;/select&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;File Size (bytes)&lt;/label&gt;\n        &lt;input type=\"number\" name=\"file_size\" class=\"w-full border rounded px-3 py-2\" min=\"0\"&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Download URL &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n      &lt;input type=\"url\" name=\"download_url\" class=\"w-full border rounded px-3 py-2\" required&gt;\n    &lt;/div&gt;\n    &lt;div class=\"grid grid-cols-2 gap-4\"&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;Checksum &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n        &lt;input type=\"text\" name=\"checksum\" class=\"w-full border rounded px-3 py-2\" required&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label class=\"block font-medium mb-1\"&gt;Checksum Type &lt;span class=\"text-red-500\"&gt;*&lt;/span&gt;&lt;/label&gt;\n        &lt;select name=\"checksum_type\" class=\"w-full border rounded px-3 py-2\" required&gt;\n          &lt;option&gt;sha256&lt;/option&gt;&lt;option&gt;sha1&lt;/option&gt;&lt;option&gt;md5&lt;/option&gt;\n        &lt;/select&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Release Notes&lt;/label&gt;\n      &lt;textarea name=\"release_notes\" rows=\"3\" class=\"w-full border rounded px-3 py-2\"&gt;&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;label class=\"block font-medium mb-1\"&gt;Minimum Version&lt;/label&gt;\n      &lt;input type=\"text\" name=\"minimum_version\" class=\"w-full border rounded px-3 py-2\"\n             placeholder=\"1.0.0\"&gt;\n    &lt;/div&gt;\n    &lt;label class=\"flex items-center gap-2\"&gt;\n      &lt;input type=\"checkbox\" name=\"required\"&gt; Mark as required update\n    &lt;/label&gt;\n    &lt;div class=\"flex gap-3\"&gt;\n      &lt;button type=\"submit\" class=\"bg-green-600 text-white px-6 py-2 rounded hover:bg-green-700\"&gt;\n        Register\n      &lt;/button&gt;\n      &lt;a href=\"/admin/applications/{{.AppID}}\"\n         class=\"px-6 py-2 border rounded hover:bg-gray-50\"&gt;Cancel&lt;/a&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n{{end}}\n</code></pre> <p>Step 6: Create <code>partials/flash.html</code></p> <pre><code>{{define \"flash\"}}\n&lt;div class=\"rounded px-4 py-3 mb-4\n  {{if eq .Type \"success\"}}bg-green-100 text-green-800 border border-green-300\n  {{else}}bg-red-100 text-red-800 border border-red-300{{end}}\"&gt;\n  {{.Message}}\n&lt;/div&gt;\n{{end}}\n</code></pre> <p>Step 7: Create <code>partials/app-row.html</code></p> <pre><code>{{define \"app-row\"}}\n&lt;tr id=\"app-{{.ID}}\" class=\"hover:bg-gray-50\"&gt;\n  &lt;td class=\"px-4 py-3 font-mono text-sm\"&gt;{{.ID}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3\"&gt;\n    &lt;a href=\"/admin/applications/{{.ID}}\" class=\"text-blue-600 hover:underline\"&gt;{{.Name}}&lt;/a&gt;\n  &lt;/td&gt;\n  &lt;td class=\"px-4 py-3 text-gray-500\"&gt;{{range .Platforms}}{{.}} {{end}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3 text-gray-500 text-sm\"&gt;{{.UpdatedAt}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3 text-right\"&gt;\n    &lt;button\n      hx-delete=\"/admin/applications/{{.ID}}\"\n      hx-confirm=\"Delete {{.Name}}? All releases must be removed first.\"\n      hx-target=\"closest tr\"\n      hx-swap=\"delete\"\n      class=\"text-red-600 hover:underline text-sm\"&gt;\n      Delete\n    &lt;/button&gt;\n  &lt;/td&gt;\n&lt;/tr&gt;\n{{end}}\n</code></pre> <p>Step 8: Create <code>partials/release-row.html</code></p> <pre><code>{{define \"release-row\"}}\n&lt;tr id=\"rel-{{.ID}}\" class=\"hover:bg-gray-50\"&gt;\n  &lt;td class=\"px-4 py-3 font-mono\"&gt;{{.Version}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3\"&gt;{{.Platform}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3\"&gt;{{.Architecture}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3\"&gt;{{if .Required}}&lt;span class=\"text-red-600 font-medium\"&gt;Yes&lt;/span&gt;{{else}}No{{end}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3 text-gray-500 text-sm\"&gt;{{.ReleaseDate}}&lt;/td&gt;\n  &lt;td class=\"px-4 py-3 text-right\"&gt;\n    &lt;button\n      hx-delete=\"/admin/applications/{{.ApplicationID}}/releases/{{.Version}}/{{.Platform}}/{{.Architecture}}\"\n      hx-confirm=\"Delete release {{.Version}} ({{.Platform}}/{{.Architecture}})?\"\n      hx-target=\"closest tr\"\n      hx-swap=\"delete\"\n      class=\"text-red-600 hover:underline text-sm\"&gt;\n      Delete\n    &lt;/button&gt;\n  &lt;/td&gt;\n&lt;/tr&gt;\n{{end}}\n</code></pre> <p>Step 9: Commit</p> <pre><code>git add internal/api/admin/\ngit commit -m \"feat(admin): add HTMX + Tailwind template files\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-4-admin-handlers-embed-data-types-render-helper","title":"Task 4: Admin handlers \u2014 embed, data types, render helper","text":"<p>Files: - Create: <code>internal/api/handlers_admin.go</code></p> <p>Step 1: Write a failing test that verifies templates parse without error</p> <p>Create <code>internal/api/handlers_admin_test.go</code>:</p> <pre><code>package api\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestAdminTemplates_ParseWithoutError(t *testing.T) {\n    tmpl, err := parseAdminTemplates()\n    require.NoError(t, err)\n    require.NotNil(t, tmpl)\n\n    expected := []string{\n        \"login\", \"health\", \"applications\", \"new-application-form\",\n        \"application\", \"edit-application-form\", \"new-release-form\",\n        \"flash\", \"app-row\", \"release-row\",\n    }\n    for _, name := range expected {\n        require.NotNil(t, tmpl.Lookup(name), \"template %q not found\", name)\n    }\n}\n</code></pre> <p>Step 2: Run test to verify it fails</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"FAIL|undefined|parseAdminTemplates\"\n</code></pre> <p>Expected: compile error \u2014 <code>parseAdminTemplates</code> undefined.</p> <p>Step 3: Create <code>handlers_admin.go</code> with embed + data structs + render helper</p> <pre><code>package api\n\nimport (\n    \"embed\"\n    \"html/template\"\n    \"log/slog\"\n    \"net/http\"\n    \"strings\"\n    \"updater/internal/models\"\n)\n\n//go:embed admin/templates\nvar adminTemplateFS embed.FS\n\n// parseAdminTemplates parses all admin templates from the embedded FS.\nfunc parseAdminTemplates() (*template.Template, error) {\n    return template.New(\"\").Funcs(template.FuncMap{\n        \"hasPlatform\": func(platforms []string, p string) bool {\n            for _, pl := range platforms {\n                if pl == p { return true }\n            }\n            return false\n        },\n    }).ParseFS(adminTemplateFS,\n        \"admin/templates/*.html\",\n        \"admin/templates/partials/*.html\",\n    )\n}\n\n// adminBaseData is embedded in every page data struct.\ntype adminBaseData struct {\n    Flash *adminFlashData\n}\n\ntype adminFlashData struct {\n    Type    string // \"success\" or \"error\"\n    Message string\n}\n\ntype adminLoginData struct {\n    Error string\n}\n\ntype adminApplicationsData struct {\n    adminBaseData\n    Applications *models.ListApplicationsResponse\n    Platforms    []string\n}\n\ntype adminNewAppData struct {\n    adminBaseData\n    Error     string\n    Form      models.CreateApplicationRequest\n    Platforms []string\n}\n\ntype adminApplicationData struct {\n    adminBaseData\n    Application *models.ApplicationInfoResponse\n    Releases    *models.ListReleasesResponse\n    Platforms   []string\n    Error       string\n}\n\ntype adminEditAppData struct {\n    adminBaseData\n    Application *models.ApplicationInfoResponse\n    Platforms   []string\n    Error       string\n}\n\ntype adminReleaseFormData struct {\n    adminBaseData\n    AppID         string\n    Platforms     []string\n    Architectures []string\n    Error         string\n}\n\ntype adminHealthData struct {\n    adminBaseData\n    Health *models.HealthCheckResponse\n}\n\nvar allPlatforms     = []string{\"windows\", \"linux\", \"darwin\", \"android\", \"ios\"}\nvar allArchitectures = []string{\"amd64\", \"arm64\", \"386\", \"arm\"}\n\n// renderAdmin renders a named template, writing 500 on error.\nfunc (h *Handlers) renderAdmin(w http.ResponseWriter, name string, data any) {\n    w.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n    if err := h.adminTmpl.ExecuteTemplate(w, name, data); err != nil {\n        slog.Error(\"admin template error\", \"template\", name, \"error\", err)\n        http.Error(w, \"internal server error\", http.StatusInternalServerError)\n    }\n}\n\n// flashFromQuery reads a ?flash=&lt;msg&gt;&amp;flash_type=&lt;type&gt; query pair into adminFlashData.\nfunc flashFromQuery(r *http.Request) *adminFlashData {\n    msg := r.URL.Query().Get(\"flash\")\n    if msg == \"\" {\n        return nil\n    }\n    ft := r.URL.Query().Get(\"flash_type\")\n    if ft == \"\" {\n        ft = \"success\"\n    }\n    return &amp;adminFlashData{Type: ft, Message: msg}\n}\n\n// addFlash appends flash query params to a redirect URL.\nfunc addFlash(base, msg, flashType string) string {\n    sep := \"?\"\n    if strings.Contains(base, \"?\") {\n        sep = \"&amp;\"\n    }\n    return base + sep + \"flash=\" + msg + \"&amp;flash_type=\" + flashType\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): embed templates, define data types and render helper\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-5-login-and-logout-handlers","title":"Task 5: Login and logout handlers","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write failing tests</p> <p>Add to <code>handlers_admin_test.go</code>:</p> <pre><code>import (\n    \"html/template\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"net/url\"\n    \"strings\"\n    \"testing\"\n    \"updater/internal/models\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc newAdminHandlers(t *testing.T) *Handlers {\n    t.Helper()\n    tmpl, err := parseAdminTemplates()\n    require.NoError(t, err)\n    cfg := models.SecurityConfig{\n        APIKeys: []models.APIKey{\n            {Key: \"admin-key\", Name: \"test\", Permissions: []string{\"admin\"}, Enabled: true},\n        },\n    }\n    return NewHandlers(&amp;MockUpdateService{},\n        WithAdminTemplates(tmpl),\n        WithSecurityConfig(cfg),\n    )\n}\n\nfunc TestAdminLogin_GET_ShowsForm(t *testing.T) {\n    h := newAdminHandlers(t)\n    rec := httptest.NewRecorder()\n    req := httptest.NewRequest(http.MethodGet, \"/admin/login\", nil)\n    h.AdminLogin(rec, req)\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Header().Get(\"Content-Type\"), \"text/html\")\n    assert.Contains(t, rec.Body.String(), \"Admin Login\")\n}\n\nfunc TestAdminLogin_POST_ValidKey_Redirects(t *testing.T) {\n    h := newAdminHandlers(t)\n    form := url.Values{\"api_key\": {\"admin-key\"}}\n    req := httptest.NewRequest(http.MethodPost, \"/admin/login\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := httptest.NewRecorder()\n    h.AdminLogin(rec, req)\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    assert.Equal(t, \"/admin/applications\", rec.Header().Get(\"Location\"))\n    // Cookie must be set\n    cookies := rec.Result().Cookies()\n    var found bool\n    for _, c := range cookies {\n        if c.Name == \"admin_session\" {\n            assert.Equal(t, \"admin-key\", c.Value)\n            assert.True(t, c.HttpOnly)\n            found = true\n        }\n    }\n    assert.True(t, found, \"admin_session cookie not set\")\n}\n\nfunc TestAdminLogin_POST_InvalidKey_ShowsError(t *testing.T) {\n    h := newAdminHandlers(t)\n    form := url.Values{\"api_key\": {\"wrong\"}}\n    req := httptest.NewRequest(http.MethodPost, \"/admin/login\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := httptest.NewRecorder()\n    h.AdminLogin(rec, req)\n    assert.Equal(t, http.StatusUnauthorized, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"Invalid\")\n}\n\nfunc TestAdminLogout_ClearsCookieAndRedirects(t *testing.T) {\n    h := newAdminHandlers(t)\n    req := httptest.NewRequest(http.MethodPost, \"/admin/logout\", nil)\n    req.AddCookie(&amp;http.Cookie{Name: \"admin_session\", Value: \"admin-key\"})\n    rec := httptest.NewRecorder()\n    h.AdminLogout(rec, req)\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    assert.Equal(t, \"/admin/login\", rec.Header().Get(\"Location\"))\n    for _, c := range rec.Result().Cookies() {\n        if c.Name == \"admin_session\" {\n            assert.Equal(t, -1, c.MaxAge)\n        }\n    }\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"FAIL|undefined\"\n</code></pre> <p>Expected: compile error \u2014 <code>AdminLogin</code>, <code>AdminLogout</code> undefined.</p> <p>Step 3: Implement handlers</p> <p>Add to <code>handlers_admin.go</code>:</p> <pre><code>// AdminLogin handles GET (show form) and POST (submit key) for /admin/login.\nfunc (h *Handlers) AdminLogin(w http.ResponseWriter, r *http.Request) {\n    if r.Method == http.MethodGet {\n        h.renderAdmin(w, \"login\", adminLoginData{})\n        return\n    }\n\n    // POST \u2014 validate submitted key.\n    if err := r.ParseForm(); err != nil {\n        h.renderAdmin(w, \"login\", adminLoginData{Error: \"Invalid form submission\"})\n        return\n    }\n    key := r.FormValue(\"api_key\")\n    if !isValidAdminKey(key, h.securityConfig) {\n        w.WriteHeader(http.StatusUnauthorized)\n        h.renderAdmin(w, \"login\", adminLoginData{Error: \"Invalid API key or insufficient permissions\"})\n        return\n    }\n\n    http.SetCookie(w, &amp;http.Cookie{\n        Name:     \"admin_session\",\n        Value:    key,\n        Path:     \"/admin\",\n        HttpOnly: true,\n        SameSite: http.SameSiteStrictMode,\n    })\n    http.Redirect(w, r, \"/admin/applications\", http.StatusSeeOther)\n}\n\n// AdminLogout clears the session cookie and redirects to login.\nfunc (h *Handlers) AdminLogout(w http.ResponseWriter, r *http.Request) {\n    http.SetCookie(w, &amp;http.Cookie{\n        Name:   \"admin_session\",\n        Value:  \"\",\n        Path:   \"/admin\",\n        MaxAge: -1,\n    })\n    http.Redirect(w, r, \"/admin/login\", http.StatusSeeOther)\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): implement login and logout handlers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-6-health-handler","title":"Task 6: Health handler","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write failing test</p> <p>Add to <code>handlers_admin_test.go</code>:</p> <pre><code>func TestAdminHealth_ReturnsPage(t *testing.T) {\n    h := newAdminHandlers(t)\n    req := httptest.NewRequest(http.MethodGet, \"/admin/health\", nil)\n    rec := httptest.NewRecorder()\n    h.AdminHealth(rec, req)\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"Service Health\")\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep \"AdminHealth\"\n</code></pre> <p>Step 3: Implement</p> <p>Add to <code>handlers_admin.go</code>:</p> <pre><code>// AdminHealth renders the health dashboard.\nfunc (h *Handlers) AdminHealth(w http.ResponseWriter, r *http.Request) {\n    // Re-use the existing HealthCheck logic by calling storage.Ping directly.\n    resp := models.NewHealthCheckResponse(models.StatusHealthy)\n    resp.Version = \"1.0.0\"\n\n    storageStatus := models.StatusHealthy\n    storageMsg := \"Storage is operational\"\n    if h.storage != nil {\n        if err := h.storage.Ping(r.Context()); err != nil {\n            storageStatus = models.StatusUnhealthy\n            storageMsg = err.Error()\n            resp.Status = models.StatusDegraded\n        }\n    }\n    resp.AddComponent(\"storage\", storageStatus, storageMsg)\n    resp.AddComponent(\"api\", models.StatusHealthy, \"API is operational\")\n\n    h.renderAdmin(w, \"health\", adminHealthData{Health: resp})\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): implement health dashboard handler\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-7-applications-list-and-create-handlers","title":"Task 7: Applications list and create handlers","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write failing tests</p> <p>Add to <code>handlers_admin_test.go</code>. The <code>MockUpdateService</code> from <code>handlers_test.go</code> is already in scope since tests are in the same package.</p> <pre><code>func TestAdminListApplications_RendersPage(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"ListApplications\", mock.Anything, 50, 0).Return(&amp;models.ListApplicationsResponse{\n        Applications: []models.ApplicationSummary{},\n        TotalCount: 0,\n    }, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    req := httptest.NewRequest(http.MethodGet, \"/admin/applications\", nil)\n    rec := httptest.NewRecorder()\n    h.AdminListApplications(rec, req)\n\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"Applications\")\n    svc.AssertExpectations(t)\n}\n\nfunc TestAdminNewApplicationForm_RendersForm(t *testing.T) {\n    h := newAdminHandlers(t)\n    req := httptest.NewRequest(http.MethodGet, \"/admin/applications/new\", nil)\n    rec := httptest.NewRecorder()\n    h.AdminNewApplicationForm(rec, req)\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"New Application\")\n}\n\nfunc TestAdminCreateApplication_ValidInput_Redirects(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"CreateApplication\", mock.Anything, mock.AnythingOfType(\"*models.CreateApplicationRequest\")).\n        Return(&amp;models.CreateApplicationResponse{ID: \"my-app\", Message: \"created\"}, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    form := url.Values{\n        \"id\": {\"my-app\"}, \"name\": {\"My App\"}, \"platforms\": {\"windows\", \"linux\"},\n    }\n    req := httptest.NewRequest(http.MethodPost, \"/admin/applications\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := httptest.NewRecorder()\n    h.AdminCreateApplication(rec, req)\n\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    assert.Contains(t, rec.Header().Get(\"Location\"), \"/admin/applications/my-app\")\n    svc.AssertExpectations(t)\n}\n\nfunc TestAdminCreateApplication_EmptyID_ShowsError(t *testing.T) {\n    h := newAdminHandlers(t)\n    form := url.Values{\"id\": {\"\"}, \"name\": {\"App\"}, \"platforms\": {\"windows\"}}\n    req := httptest.NewRequest(http.MethodPost, \"/admin/applications\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := httptest.NewRecorder()\n    h.AdminCreateApplication(rec, req)\n    assert.Equal(t, http.StatusUnprocessableEntity, rec.Code)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep \"FAIL\\|undefined\"\n</code></pre> <p>Step 3: Implement</p> <p>Add to <code>handlers_admin.go</code>:</p> <pre><code>// AdminListApplications renders the applications list page.\nfunc (h *Handlers) AdminListApplications(w http.ResponseWriter, r *http.Request) {\n    resp, err := h.updateService.ListApplications(r.Context(), 50, 0)\n    if err != nil {\n        h.renderAdmin(w, \"applications\", adminApplicationsData{\n            adminBaseData: adminBaseData{Flash: &amp;adminFlashData{Type: \"error\", Message: err.Error()}},\n            Platforms:     allPlatforms,\n        })\n        return\n    }\n    h.renderAdmin(w, \"applications\", adminApplicationsData{\n        adminBaseData: adminBaseData{Flash: flashFromQuery(r)},\n        Applications:  resp,\n        Platforms:     allPlatforms,\n    })\n}\n\n// AdminNewApplicationForm renders the create-application form.\nfunc (h *Handlers) AdminNewApplicationForm(w http.ResponseWriter, r *http.Request) {\n    h.renderAdmin(w, \"new-application-form\", adminNewAppData{Platforms: allPlatforms})\n}\n\n// AdminCreateApplication processes the create-application form.\nfunc (h *Handlers) AdminCreateApplication(w http.ResponseWriter, r *http.Request) {\n    if err := r.ParseForm(); err != nil {\n        w.WriteHeader(http.StatusBadRequest)\n        h.renderAdmin(w, \"new-application-form\", adminNewAppData{Error: \"Invalid form\", Platforms: allPlatforms})\n        return\n    }\n\n    id := strings.TrimSpace(r.FormValue(\"id\"))\n    name := strings.TrimSpace(r.FormValue(\"name\"))\n    if id == \"\" || name == \"\" {\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"new-application-form\", adminNewAppData{\n            Error:     \"ID and Name are required\",\n            Form:      models.CreateApplicationRequest{ID: id, Name: name},\n            Platforms: allPlatforms,\n        })\n        return\n    }\n\n    platforms := r.Form[\"platforms\"]\n    if len(platforms) == 0 {\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"new-application-form\", adminNewAppData{\n            Error:     \"At least one platform is required\",\n            Form:      models.CreateApplicationRequest{ID: id, Name: name},\n            Platforms: allPlatforms,\n        })\n        return\n    }\n\n    req := &amp;models.CreateApplicationRequest{\n        ID:          id,\n        Name:        name,\n        Description: r.FormValue(\"description\"),\n        Platforms:   platforms,\n    }\n    resp, err := h.updateService.CreateApplication(r.Context(), req)\n    if err != nil {\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"new-application-form\", adminNewAppData{\n            Error: err.Error(), Form: *req, Platforms: allPlatforms,\n        })\n        return\n    }\n\n    http.Redirect(w, r, addFlash(\"/admin/applications/\"+resp.ID, \"Application created\", \"success\"),\n        http.StatusSeeOther)\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): implement applications list and create handlers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-8-application-detail-edit-and-delete-handlers","title":"Task 8: Application detail, edit, and delete handlers","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write failing tests</p> <p>Add to <code>handlers_admin_test.go</code>. Note: these handlers use <code>mux.Vars</code>, so they need the gorilla router.</p> <pre><code>func serveWithVars(h http.HandlerFunc, vars map[string]string, req *http.Request) *httptest.ResponseRecorder {\n    rec := httptest.NewRecorder()\n    // Inject mux vars manually for unit tests.\n    req = mux.SetURLVars(req, vars)\n    h(rec, req)\n    return rec\n}\n\nfunc TestAdminGetApplication_RendersPage(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"GetApplication\", mock.Anything, \"my-app\").Return(&amp;models.ApplicationInfoResponse{\n        ID: \"my-app\", Name: \"My App\", Platforms: []string{\"windows\"},\n    }, nil)\n    svc.On(\"ListReleases\", mock.Anything, mock.AnythingOfType(\"*models.ListReleasesRequest\")).\n        Return(&amp;models.ListReleasesResponse{}, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    req := httptest.NewRequest(http.MethodGet, \"/admin/applications/my-app\", nil)\n    rec := serveWithVars(h.AdminGetApplication, map[string]string{\"app_id\": \"my-app\"}, req)\n\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"My App\")\n    svc.AssertExpectations(t)\n}\n\nfunc TestAdminDeleteApplication_Success_ReturnsOK(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"DeleteApplication\", mock.Anything, \"my-app\").Return(nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    req := httptest.NewRequest(http.MethodDelete, \"/admin/applications/my-app\", nil)\n    rec := serveWithVars(h.AdminDeleteApplication, map[string]string{\"app_id\": \"my-app\"}, req)\n\n    assert.Equal(t, http.StatusOK, rec.Code)\n    svc.AssertExpectations(t)\n}\n\nfunc TestAdminUpdateApplication_ValidForm_Redirects(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"UpdateApplication\", mock.Anything, \"my-app\",\n        mock.AnythingOfType(\"*models.UpdateApplicationRequest\")).\n        Return(&amp;models.UpdateApplicationResponse{ID: \"my-app\", Message: \"updated\"}, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    form := url.Values{\"name\": {\"New Name\"}, \"platforms\": {\"windows\"}}\n    req := httptest.NewRequest(http.MethodPost, \"/admin/applications/my-app/edit\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := serveWithVars(h.AdminUpdateApplication, map[string]string{\"app_id\": \"my-app\"}, req)\n\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    svc.AssertExpectations(t)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep \"FAIL\\|undefined\"\n</code></pre> <p>Step 3: Implement</p> <p>Add to <code>handlers_admin.go</code>:</p> <pre><code>import \"github.com/gorilla/mux\"\n\n// AdminGetApplication renders the application detail page with its releases.\nfunc (h *Handlers) AdminGetApplication(w http.ResponseWriter, r *http.Request) {\n    appID := mux.Vars(r)[\"app_id\"]\n    app, err := h.updateService.GetApplication(r.Context(), appID)\n    if err != nil {\n        http.Error(w, \"Application not found\", http.StatusNotFound)\n        return\n    }\n    releases, err := h.updateService.ListReleases(r.Context(), &amp;models.ListReleasesRequest{\n        ApplicationID: appID, Limit: 100,\n    })\n    if err != nil {\n        releases = &amp;models.ListReleasesResponse{}\n    }\n    h.renderAdmin(w, \"application\", adminApplicationData{\n        adminBaseData: adminBaseData{Flash: flashFromQuery(r)},\n        Application:   app,\n        Releases:      releases,\n        Platforms:     allPlatforms,\n    })\n}\n\n// AdminEditApplicationForm renders the edit form pre-filled with current values.\nfunc (h *Handlers) AdminEditApplicationForm(w http.ResponseWriter, r *http.Request) {\n    appID := mux.Vars(r)[\"app_id\"]\n    app, err := h.updateService.GetApplication(r.Context(), appID)\n    if err != nil {\n        http.Error(w, \"Application not found\", http.StatusNotFound)\n        return\n    }\n    h.renderAdmin(w, \"edit-application-form\", adminEditAppData{\n        Application: app, Platforms: allPlatforms,\n    })\n}\n\n// AdminUpdateApplication processes the edit form (POST /admin/applications/{id}/edit).\nfunc (h *Handlers) AdminUpdateApplication(w http.ResponseWriter, r *http.Request) {\n    appID := mux.Vars(r)[\"app_id\"]\n    if err := r.ParseForm(); err != nil {\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n    name := strings.TrimSpace(r.FormValue(\"name\"))\n    platforms := r.Form[\"platforms\"]\n    if name == \"\" || len(platforms) == 0 {\n        app, _ := h.updateService.GetApplication(r.Context(), appID)\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"edit-application-form\", adminEditAppData{\n            Application: app, Platforms: allPlatforms,\n            Error: \"Name and at least one platform are required\",\n        })\n        return\n    }\n    req := &amp;models.UpdateApplicationRequest{\n        Name:        name,\n        Description: r.FormValue(\"description\"),\n        Platforms:   platforms,\n    }\n    if _, err := h.updateService.UpdateApplication(r.Context(), appID, req); err != nil {\n        app, _ := h.updateService.GetApplication(r.Context(), appID)\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"edit-application-form\", adminEditAppData{\n            Application: app, Platforms: allPlatforms, Error: err.Error(),\n        })\n        return\n    }\n    http.Redirect(w, r, addFlash(\"/admin/applications/\"+appID, \"Application updated\", \"success\"),\n        http.StatusSeeOther)\n}\n\n// AdminDeleteApplication deletes the application and returns 200 OK (HTMX removes the row).\nfunc (h *Handlers) AdminDeleteApplication(w http.ResponseWriter, r *http.Request) {\n    appID := mux.Vars(r)[\"app_id\"]\n    if err := h.updateService.DeleteApplication(r.Context(), appID); err != nil {\n        http.Error(w, err.Error(), http.StatusConflict)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): implement application detail, edit, and delete handlers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-9-release-management-handlers","title":"Task 9: Release management handlers","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write failing tests</p> <p>Add to <code>handlers_admin_test.go</code>:</p> <pre><code>func TestAdminNewReleaseForm_RendersForm(t *testing.T) {\n    h := newAdminHandlers(t)\n    req := httptest.NewRequest(http.MethodGet, \"/admin/applications/my-app/releases/new\", nil)\n    rec := serveWithVars(h.AdminNewReleaseForm, map[string]string{\"app_id\": \"my-app\"}, req)\n    assert.Equal(t, http.StatusOK, rec.Code)\n    assert.Contains(t, rec.Body.String(), \"Register Release\")\n    assert.Contains(t, rec.Body.String(), \"my-app\")\n}\n\nfunc TestAdminCreateRelease_ValidInput_Redirects(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"RegisterRelease\", mock.Anything, mock.AnythingOfType(\"*models.RegisterReleaseRequest\")).\n        Return(&amp;models.RegisterReleaseResponse{ID: \"rel-1\", Message: \"created\"}, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    form := url.Values{\n        \"version\": {\"1.0.0\"}, \"platform\": {\"windows\"}, \"architecture\": {\"amd64\"},\n        \"download_url\": {\"https://example.com/app.exe\"},\n        \"checksum\": {\"abc\"}, \"checksum_type\": {\"sha256\"},\n    }\n    req := httptest.NewRequest(http.MethodPost, \"/admin/applications/my-app/releases\",\n        strings.NewReader(form.Encode()))\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    rec := serveWithVars(h.AdminCreateRelease, map[string]string{\"app_id\": \"my-app\"}, req)\n\n    assert.Equal(t, http.StatusSeeOther, rec.Code)\n    assert.Contains(t, rec.Header().Get(\"Location\"), \"/admin/applications/my-app\")\n    svc.AssertExpectations(t)\n}\n\nfunc TestAdminDeleteRelease_Success_ReturnsOK(t *testing.T) {\n    svc := &amp;MockUpdateService{}\n    svc.On(\"DeleteRelease\", mock.Anything, \"my-app\", \"1.0.0\", \"windows\", \"amd64\").\n        Return(&amp;models.DeleteReleaseResponse{ID: \"rel-1\", Message: \"deleted\"}, nil)\n\n    tmpl, _ := parseAdminTemplates()\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n\n    req := httptest.NewRequest(http.MethodDelete,\n        \"/admin/applications/my-app/releases/1.0.0/windows/amd64\", nil)\n    vars := map[string]string{\n        \"app_id\": \"my-app\", \"version\": \"1.0.0\", \"platform\": \"windows\", \"arch\": \"amd64\",\n    }\n    rec := serveWithVars(h.AdminDeleteRelease, vars, req)\n    assert.Equal(t, http.StatusOK, rec.Code)\n    svc.AssertExpectations(t)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep \"FAIL\\|undefined\"\n</code></pre> <p>Step 3: Implement</p> <p>Add to <code>handlers_admin.go</code>:</p> <pre><code>// AdminNewReleaseForm renders the release registration form.\nfunc (h *Handlers) AdminNewReleaseForm(w http.ResponseWriter, r *http.Request) {\n    h.renderAdmin(w, \"new-release-form\", adminReleaseFormData{\n        AppID: mux.Vars(r)[\"app_id\"], Platforms: allPlatforms, Architectures: allArchitectures,\n    })\n}\n\n// AdminCreateRelease processes the release registration form.\nfunc (h *Handlers) AdminCreateRelease(w http.ResponseWriter, r *http.Request) {\n    appID := mux.Vars(r)[\"app_id\"]\n    if err := r.ParseForm(); err != nil {\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n    req := &amp;models.RegisterReleaseRequest{\n        ApplicationID: appID,\n        Version:       strings.TrimSpace(r.FormValue(\"version\")),\n        Platform:      r.FormValue(\"platform\"),\n        Architecture:  r.FormValue(\"architecture\"),\n        DownloadURL:   strings.TrimSpace(r.FormValue(\"download_url\")),\n        Checksum:      strings.TrimSpace(r.FormValue(\"checksum\")),\n        ChecksumType:  r.FormValue(\"checksum_type\"),\n        ReleaseNotes:  r.FormValue(\"release_notes\"),\n        MinimumVersion: r.FormValue(\"minimum_version\"),\n        Required:      r.FormValue(\"required\") == \"on\",\n    }\n    if req.Version == \"\" || req.Platform == \"\" || req.Architecture == \"\" ||\n        req.DownloadURL == \"\" || req.Checksum == \"\" {\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"new-release-form\", adminReleaseFormData{\n            AppID: appID, Platforms: allPlatforms, Architectures: allArchitectures,\n            Error: \"Version, Platform, Architecture, Download URL, and Checksum are required\",\n        })\n        return\n    }\n    if _, err := h.updateService.RegisterRelease(r.Context(), req); err != nil {\n        w.WriteHeader(http.StatusUnprocessableEntity)\n        h.renderAdmin(w, \"new-release-form\", adminReleaseFormData{\n            AppID: appID, Platforms: allPlatforms, Architectures: allArchitectures,\n            Error: err.Error(),\n        })\n        return\n    }\n    http.Redirect(w, r, addFlash(\"/admin/applications/\"+appID, \"Release registered\", \"success\"),\n        http.StatusSeeOther)\n}\n\n// AdminDeleteRelease deletes a release and returns 200 OK (HTMX removes the row).\nfunc (h *Handlers) AdminDeleteRelease(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    if _, err := h.updateService.DeleteRelease(r.Context(),\n        vars[\"app_id\"], vars[\"version\"], vars[\"platform\"], vars[\"arch\"]); err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): implement release management handlers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-10-register-admin-routes","title":"Task 10: Register admin routes","text":"<p>Files: - Modify: <code>internal/api/routes.go</code></p> <p>Step 1: Write failing route test</p> <p>Add to <code>handlers_admin_test.go</code>:</p> <pre><code>func TestAdminRoutes_LoginPublic(t *testing.T) {\n    tmpl, _ := parseAdminTemplates()\n    svc := &amp;MockUpdateService{}\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n    router := SetupRoutes(h, &amp;models.Config{})\n    server := httptest.NewServer(router)\n    defer server.Close()\n\n    resp, err := http.Get(server.URL + \"/admin/login\")\n    require.NoError(t, err)\n    resp.Body.Close()\n    assert.Equal(t, http.StatusOK, resp.StatusCode)\n}\n\nfunc TestAdminRoutes_ProtectedRedirectsWithoutCookie(t *testing.T) {\n    tmpl, _ := parseAdminTemplates()\n    svc := &amp;MockUpdateService{}\n    h := NewHandlers(svc, WithAdminTemplates(tmpl), WithSecurityConfig(models.SecurityConfig{}))\n    router := SetupRoutes(h, &amp;models.Config{})\n    server := httptest.NewServer(router)\n    defer server.Close()\n\n    client := &amp;http.Client{CheckRedirect: func(req *http.Request, via []*http.Request) error {\n        return http.ErrUseLastResponse\n    }}\n    resp, err := client.Get(server.URL + \"/admin/applications\")\n    require.NoError(t, err)\n    resp.Body.Close()\n    // In dev mode (no API keys), any non-empty cookie passes; no cookie \u2192 redirect.\n    assert.Equal(t, http.StatusSeeOther, resp.StatusCode)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test 2&gt;&amp;1 | grep \"FAIL\\|undefined\\|no route\"\n</code></pre> <p>Step 3: Add admin routes to <code>routes.go</code></p> <p>Add this block before the auth <code>if/else</code> block (after the health routes):</p> <pre><code>// Admin UI \u2014 single subrouter; middleware skips /login and /logout internally.\nadminRouter := router.PathPrefix(\"/admin\").Subrouter()\nadminRouter.Use(adminSessionMiddleware(config.Security))\nadminRouter.HandleFunc(\"/login\", handlers.AdminLogin).Methods(\"GET\", \"POST\")\nadminRouter.HandleFunc(\"/logout\", handlers.AdminLogout).Methods(\"POST\")\nadminRouter.HandleFunc(\"\", func(w http.ResponseWriter, r *http.Request) {\n    http.Redirect(w, r, \"/admin/applications\", http.StatusSeeOther)\n}).Methods(\"GET\")\nadminRouter.HandleFunc(\"/health\", handlers.AdminHealth).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications\", handlers.AdminListApplications).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications/new\", handlers.AdminNewApplicationForm).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications\", handlers.AdminCreateApplication).Methods(\"POST\")\nadminRouter.HandleFunc(\"/applications/{app_id}\", handlers.AdminGetApplication).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications/{app_id}/edit\", handlers.AdminEditApplicationForm).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications/{app_id}/edit\", handlers.AdminUpdateApplication).Methods(\"POST\")\nadminRouter.HandleFunc(\"/applications/{app_id}\", handlers.AdminDeleteApplication).Methods(\"DELETE\")\nadminRouter.HandleFunc(\"/applications/{app_id}/releases/new\", handlers.AdminNewReleaseForm).Methods(\"GET\")\nadminRouter.HandleFunc(\"/applications/{app_id}/releases\", handlers.AdminCreateRelease).Methods(\"POST\")\nadminRouter.HandleFunc(\"/applications/{app_id}/releases/{version}/{platform}/{arch}\",\n    handlers.AdminDeleteRelease).Methods(\"DELETE\")\n</code></pre> <p>Note: the edit form uses POST instead of PUT because standard HTML forms only support GET/POST. HTMX delete uses the DELETE method via XHR.</p> <p>Step 4: Run all tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/routes.go internal/api/handlers_admin_test.go\ngit commit -m \"feat(admin): register admin routes with session middleware\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-11-wire-up-in-main-and-update-updateapplicationrequest","title":"Task 11: Wire up in main and update UpdateApplicationRequest","text":"<p>Files: - Modify: <code>cmd/updater/updater.go</code></p> <p>Step 1: Parse templates and pass options</p> <p>In <code>updater.go</code>, after the <code>observability.Setup</code> call, add:</p> <pre><code>// Parse admin UI templates from embedded FS.\nadminTmpl, err := api.ParseAdminTemplates()\nif err != nil {\n    slog.Error(\"Failed to parse admin templates\", \"error\", err)\n    os.Exit(1)\n}\n</code></pre> <p>Change <code>parseAdminTemplates</code> to be exported (<code>ParseAdminTemplates</code>) in <code>handlers_admin.go</code>.</p> <p>Update the <code>handlers</code> line:</p> <pre><code>handlers := api.NewHandlers(updateService,\n    api.WithStorage(activeStorage),\n    api.WithAdminTemplates(adminTmpl),\n    api.WithSecurityConfig(cfg.Security),\n)\n</code></pre> <p>Step 2: Build to verify no compile errors</p> <pre><code>make build 2&gt;&amp;1\n</code></pre> <p>Expected: clean build.</p> <p>Step 3: Run all tests</p> <pre><code>make test 2&gt;&amp;1 | grep -E \"ok|FAIL\"\n</code></pre> <p>Expected: all pass.</p> <p>Step 4: Commit</p> <pre><code>git add cmd/updater/updater.go internal/api/handlers_admin.go\ngit commit -m \"feat(admin): wire admin templates and security config into main\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#task-12-documentation","title":"Task 12: Documentation","text":"<p>Files: - Create: <code>docs/admin-ui.md</code> - Modify: <code>mkdocs.yml</code></p> <p>Step 1: Create <code>docs/admin-ui.md</code></p> <pre><code># Admin UI\n\nThe updater service ships with a browser-based admin interface at `/admin`. It is\nserver-rendered using Go's `html/template` package with HTMX for inline delete\nactions, styled with Tailwind CSS (Play CDN). No JavaScript build step is required.\n\n## Access\n\nNavigate to `http://localhost:8080/admin` in a browser. You will be redirected to\nthe login page.\n\n## Authentication\n\nEnter an API key configured with `admin` permission in your server configuration.\nIn development mode (no API keys configured) any non-empty string is accepted.\n\nThe key is stored in an HttpOnly, SameSite=Strict session cookie scoped to `/admin`.\nIt is never visible to JavaScript.\n\n## Pages\n\n| Path | Description |\n|------|-------------|\n| `/admin/login` | Login form |\n| `/admin/applications` | Application list with inline delete |\n| `/admin/applications/new` | Create application form |\n| `/admin/applications/{id}` | Application detail + release list |\n| `/admin/applications/{id}/edit` | Edit application form |\n| `/admin/applications/{id}/releases/new` | Register a release |\n| `/admin/health` | Service health dashboard |\n\n## Architecture\n\n```mermaid\nflowchart LR\n    B[Browser] --&gt;|GET /admin/*| R[Router\\ngorilla/mux]\n    R --&gt;|cookie check| M[adminSessionMiddleware]\n    M --&gt;|valid| H[Admin Handlers]\n    H --&gt;|direct call| S[ServiceInterface]\n    S --&gt; DB[(Storage)]\n    H --&gt;|html/template| T[Embedded Templates\\ngo:embed]\n    T --&gt; B\n</code></pre> <p>Templates are embedded via <code>go:embed</code> at compile time. HTMX is loaded from the unpkg CDN; an internet connection is required for the interactive delete behaviour. Core page navigation works without JavaScript. <pre><code>**Step 2: Add to `mkdocs.yml` nav**\n\nFind the `nav:` section and add under API:\n\n```yaml\n  - API:\n    - Reference: api.md\n    - OpenAPI Spec: openapi.md\n    - Admin UI: admin-ui.md\n</code></pre></p> <p>Step 3: Commit</p> <pre><code>git add docs/admin-ui.md mkdocs.yml\ngit commit -m \"docs: add admin UI documentation page\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-frontend/#testing-the-complete-feature","title":"Testing the Complete Feature","text":"<p>After all tasks are done:</p> <p>1. Build and start:</p> <pre><code>make docker-obs-up\n</code></pre> <p>2. Open the admin UI:</p> <pre><code>http://localhost:8080/admin\n</code></pre> <p>Login with key <code>dev-admin-key-12345678901234567890</code> (from <code>docker-compose.yml</code> env).</p> <p>3. Verify:</p> <ul> <li>[ ] Login redirects to Applications page</li> <li>[ ] Applications page lists apps (empty initially)</li> <li>[ ] New Application form creates an app and redirects back with flash message</li> <li>[ ] Application detail shows stats and empty releases table</li> <li>[ ] Register Release form creates a release and shows it in the table</li> <li>[ ] Delete release button removes the row without page reload</li> <li>[ ] Health page shows storage and API status</li> <li>[ ] Logout clears cookie and returns to login</li> <li>[ ] Accessing <code>/admin/applications</code> without cookie redirects to login</li> </ul> <p>4. Run full test suite:</p> <pre><code>make test\n</code></pre> <p>Expected: all green.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/","title":"Admin Key Management \u2014 Design","text":"<p>Date: 2026-02-16 Status: Approved Roadmap item: 1.1 Admin REST API</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#overview","title":"Overview","text":"<p>Replace config-file-based API key management with a storage-backed system exposing CRUD endpoints under <code>/api/v1/admin/keys</code>. A single bootstrap key may be provided in config; it is seeded into storage on first startup and thereafter behaves like any other key.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#goals","title":"Goals","text":"<ul> <li>API keys are manageable at runtime with no service restart.</li> <li>Raw key values are never stored; a SHA-256 hash is stored instead.</li> <li>The bootstrap key in config is the only key that ever comes from config; all others are created via the API.</li> <li>Key changes take effect immediately.</li> </ul>"},{"location":"plans/2026-02-16-admin-key-management-design/#non-goals","title":"Non-Goals","text":"<ul> <li>Multi-tenant key scoping (deferred to Phase 2).</li> <li>Key expiry or rotation policies.</li> <li>Separate keystore backend (keys use whichever storage backend is active).</li> </ul>"},{"location":"plans/2026-02-16-admin-key-management-design/#model","title":"Model","text":"<p>A new <code>APIKey</code> model replaces the current <code>APIKey</code> struct in <code>models/config.go</code>.</p> <pre><code>type APIKey struct {\n    ID          string    // UUID v4\n    Name        string    // Human-readable label\n    KeyHash     string    // SHA-256 hex of the raw key (never returned in responses)\n    Prefix      string    // First 8 characters of the raw key (display only)\n    Permissions []string  // Subset of: read, write, admin\n    Enabled     bool\n    CreatedAt   time.Time\n    UpdatedAt   time.Time\n}\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#key-format","title":"Key Format","text":"<p>Raw keys follow the format <code>upd_&lt;32 URL-safe base64 chars&gt;</code>, providing 192 bits of entropy. The <code>upd_</code> prefix makes keys identifiable by secret scanning tools (gitleaks is already configured in CI).</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#hashing","title":"Hashing","text":"<p>SHA-256 of the raw key is stored as a lowercase hex string. The raw key is generated in memory, returned once in the creation response, and never persisted. On authentication, the presented Bearer token is hashed and matched against <code>key_hash</code> in storage.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#config-changes","title":"Config Changes","text":"<p><code>SecurityConfig</code> is simplified: the <code>APIKeys []APIKey</code> slice is removed and replaced with a single <code>BootstrapKey string</code> field.</p> <pre><code>security:\n  enable_auth: true\n  bootstrap_key: \"upd_...\"  # optional; seeded into storage on first startup\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#storage-layer","title":"Storage Layer","text":"<p>Five new methods are added to the <code>Storage</code> interface:</p> <pre><code>CreateAPIKey(ctx context.Context, key *models.APIKey) error\nGetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error)\nListAPIKeys(ctx context.Context) ([]*models.APIKey, error)\nUpdateAPIKey(ctx context.Context, key *models.APIKey) error\nDeleteAPIKey(ctx context.Context, id string) error\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#backend-implementations","title":"Backend Implementations","text":"Backend Storage mechanism Memory In-memory map keyed by ID; secondary map keyed by <code>KeyHash</code> for O(1) auth lookups JSON New top-level <code>\"api_keys\"</code> array in <code>releases.json</code> SQLite New <code>api_keys</code> table; sqlc queries in <code>internal/storage/sqlc/sqlite/</code> PostgreSQL New <code>api_keys</code> table; sqlc queries in <code>internal/storage/sqlc/postgres/</code> <p><code>GetAPIKeyByHash</code> is the hot path (every authenticated request). SQL backends index <code>key_hash</code>; the memory backend uses a secondary map.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#bootstrap-seeding","title":"Bootstrap Seeding","text":"<p>Executed once in <code>cmd/updater/main.go</code> after the storage provider is initialised:</p> <pre><code>if config.Security.BootstrapKey == \"\" \u2192 skip\nhash = SHA-256(config.Security.BootstrapKey)\nif storage.GetAPIKeyByHash(ctx, hash) found \u2192 skip (idempotent)\nstorage.CreateAPIKey(ctx, &amp;APIKey{\n    Name:        \"bootstrap\",\n    KeyHash:     hash,\n    Prefix:      key[:8],\n    Permissions: [\"admin\"],\n    Enabled:     true,\n})\n</code></pre> <p>After seeding, the bootstrap key is a normal key in storage. It can be renamed, disabled, or deleted through the API.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#auth-middleware","title":"Auth Middleware","text":"<p>The existing loop over <code>config.Security.APIKeys</code> in <code>authMiddleware</code> is replaced with:</p> <ol> <li>Extract the Bearer token from the <code>Authorization</code> header.</li> <li>Compute SHA-256.</li> <li>Call <code>storage.GetAPIKeyByHash(ctx, hash)</code>.</li> <li>If not found or <code>Enabled == false</code>, return 401.</li> <li>Store the resolved <code>*models.APIKey</code> in the request context.</li> </ol> <p>Config no longer participates in runtime authentication after startup.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#rest-endpoints","title":"REST Endpoints","text":"<p>All four endpoints require <code>admin</code> permission.</p> Method Path Description <code>GET</code> <code>/api/v1/admin/keys</code> List all keys (metadata only; no hash, no raw key) <code>POST</code> <code>/api/v1/admin/keys</code> Create a key; raw key returned once in response <code>PATCH</code> <code>/api/v1/admin/keys/{id}</code> Update name, permissions, or enabled state <code>DELETE</code> <code>/api/v1/admin/keys/{id}</code> Revoke a key"},{"location":"plans/2026-02-16-admin-key-management-design/#request-response-shapes","title":"Request / Response Shapes","text":"<p>POST <code>/api/v1/admin/keys</code> request:</p> <pre><code>{\n  \"name\": \"CI Publisher\",\n  \"permissions\": [\"write\"]\n}\n</code></pre> <p>Response (201):</p> <pre><code>{\n  \"id\": \"uuid\",\n  \"name\": \"CI Publisher\",\n  \"key\": \"upd_aB3xZ9qR...\",\n  \"prefix\": \"upd_aB3x\",\n  \"permissions\": [\"write\"],\n  \"enabled\": true,\n  \"created_at\": \"2026-02-16T00:00:00Z\"\n}\n</code></pre> <p>GET <code>/api/v1/admin/keys</code> response (200):</p> <pre><code>[\n  {\n    \"id\": \"uuid\",\n    \"name\": \"CI Publisher\",\n    \"prefix\": \"upd_aB3x\",\n    \"permissions\": [\"write\"],\n    \"enabled\": true,\n    \"created_at\": \"2026-02-16T00:00:00Z\",\n    \"updated_at\": \"2026-02-16T00:00:00Z\"\n  }\n]\n</code></pre> <p>PATCH <code>/api/v1/admin/keys/{id}</code> request (all fields optional):</p> <pre><code>{\n  \"name\": \"CI Publisher v2\",\n  \"permissions\": [\"write\"],\n  \"enabled\": false\n}\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#audit-logging","title":"Audit Logging","text":"<p>Every mutation (create, update, delete) emits a structured log event:</p> <pre><code>slog.Info(\"api key mutated\",\n    \"event\", \"security_audit\",\n    \"action\", \"create|update|delete\",\n    \"key_id\", id,\n    \"key_name\", name,\n    \"actor_key_id\", actorID,\n)\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#admin-ui","title":"Admin UI","text":"<p>A new \"API Keys\" section is added to the admin web UI:</p> Route Description <code>GET /admin/keys</code> Key list: name, prefix, permissions, enabled, created date <code>GET /admin/keys/new</code> Create key form <code>POST /admin/keys</code> Process creation; display raw key once with copy button and \"will not be shown again\" warning <code>DELETE /admin/keys/{id}</code> Revoke (HTMX inline, no page reload) <code>POST /admin/keys/{id}/toggle</code> Enable/disable toggle (HTMX inline) <p>No separate edit page; name and permissions are updated via inline forms calling the PATCH endpoint.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#openapi-spec","title":"OpenAPI Spec","text":"<p><code>internal/api/openapi/openapi.yaml</code> is updated to document all four endpoints with full request/response schemas and security requirements.</p>"},{"location":"plans/2026-02-16-admin-key-management-design/#data-flow","title":"Data Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant AuthMiddleware\n    participant Storage\n\n    Client-&gt;&gt;AuthMiddleware: GET /api/v1/... Bearer upd_abc...\n    AuthMiddleware-&gt;&gt;AuthMiddleware: SHA-256(token)\n    AuthMiddleware-&gt;&gt;Storage: GetAPIKeyByHash(hash)\n    Storage--&gt;&gt;AuthMiddleware: APIKey{Enabled: true, Permissions: [...]}\n    AuthMiddleware-&gt;&gt;Client: proceed (key in context)</code></pre> <pre><code>sequenceDiagram\n    participant AdminClient\n    participant KeyHandler\n    participant Storage\n\n    AdminClient-&gt;&gt;KeyHandler: POST /api/v1/admin/keys {name, permissions}\n    KeyHandler-&gt;&gt;KeyHandler: generate raw key\n    KeyHandler-&gt;&gt;KeyHandler: SHA-256(raw key)\n    KeyHandler-&gt;&gt;Storage: CreateAPIKey(hash, prefix, ...)\n    Storage--&gt;&gt;KeyHandler: ok\n    KeyHandler--&gt;&gt;AdminClient: 201 {id, key (raw), prefix, ...}\n    note over KeyHandler,AdminClient: raw key not stored; returned once only</code></pre>"},{"location":"plans/2026-02-16-admin-key-management-design/#testing","title":"Testing","text":"<ul> <li>Unit tests for the SHA-256 hashing helper</li> <li>Unit tests for each storage backend's key CRUD methods</li> <li>Table-driven handler tests for all four endpoints (auth, permission checks, response shapes)</li> <li>Integration test: create key via POST, authenticate with it, revoke it, confirm 401</li> <li>Bootstrap seeding test: seed once, restart (call seed again), confirm no duplicate</li> </ul>"},{"location":"plans/2026-02-16-admin-key-management/","title":"Admin Key Management Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace config-file API key management with storage-backed CRUD endpoints at <code>/api/v1/admin/keys</code>, seeding a single bootstrap key from config on first startup.</p> <p>Architecture: New <code>models.APIKey</code> model stores a SHA-256 hash of the raw key; five new <code>Storage</code> interface methods fan out to all four backends; auth middleware switches from iterating config memory to querying storage by hash; four new REST endpoints plus admin UI pages complete the surface.</p> <p>Tech Stack: Go 1.25, <code>crypto/sha256</code>, <code>encoding/hex</code>, <code>github.com/google/uuid</code>, <code>crypto/rand</code>, <code>encoding/base64</code>; all existing storage backends; gorilla/mux; HTMX admin templates.</p> <p>Design doc: <code>docs/plans/2026-02-16-admin-key-management-design.md</code></p>"},{"location":"plans/2026-02-16-admin-key-management/#task-1-new-apikey-model-and-key-helpers","title":"Task 1: New <code>APIKey</code> model and key helpers","text":"<p>Files: - Create: <code>internal/models/api_key.go</code> - Modify: <code>internal/models/config.go</code> - Create: <code>internal/models/api_key_test.go</code></p> <p>Context: The current <code>APIKey</code> struct in <code>config.go</code> stores the raw key value. We are replacing it with a model that stores a SHA-256 hash and a display prefix. The raw key is generated by a helper and returned to the caller only once.</p> <p>Step 1: Write the failing test</p> <pre><code>// internal/models/api_key_test.go\npackage models_test\n\nimport (\n    \"strings\"\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestGenerateAPIKey(t *testing.T) {\n    key, err := models.GenerateAPIKey()\n    require.NoError(t, err)\n    assert.True(t, strings.HasPrefix(key, \"upd_\"), \"key must start with upd_\")\n    assert.Len(t, key, 48, \"upd_ (4) + 44 base64url chars = 48\")\n}\n\nfunc TestHashAPIKey(t *testing.T) {\n    hash1 := models.HashAPIKey(\"upd_abc123\")\n    hash2 := models.HashAPIKey(\"upd_abc123\")\n    hash3 := models.HashAPIKey(\"upd_different\")\n    assert.Equal(t, hash1, hash2, \"same input must produce same hash\")\n    assert.NotEqual(t, hash1, hash3, \"different inputs must produce different hashes\")\n    assert.Len(t, hash1, 64, \"SHA-256 hex is 64 characters\")\n}\n\nfunc TestAPIKeyHasPermission(t *testing.T) {\n    tests := []struct {\n        name        string\n        permissions []string\n        check       string\n        want        bool\n    }{\n        {\"admin grants all\", []string{\"admin\"}, \"read\", true},\n        {\"admin grants write\", []string{\"admin\"}, \"write\", true},\n        {\"write grants read\", []string{\"write\"}, \"read\", true},\n        {\"write denied admin\", []string{\"write\"}, \"admin\", false},\n        {\"read only\", []string{\"read\"}, \"read\", true},\n        {\"read denied write\", []string{\"read\"}, \"write\", false},\n        {\"wildcard grants all\", []string{\"*\"}, \"admin\", true},\n        {\"disabled key denied\", []string{\"admin\"}, \"read\", false}, // Enabled: false tested separately\n    }\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            key := &amp;models.APIKey{Permissions: tt.permissions, Enabled: true}\n            if tt.name == \"disabled key denied\" {\n                key.Enabled = false\n            }\n            assert.Equal(t, tt.want, key.HasPermission(tt.check))\n        })\n    }\n}\n</code></pre> <p>Step 2: Run test to verify it fails</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 <code>models.GenerateAPIKey</code>, <code>models.HashAPIKey</code>, new <code>models.APIKey</code> not defined.</p> <p>Step 3: Create <code>internal/models/api_key.go</code></p> <pre><code>package models\n\nimport (\n    \"crypto/rand\"\n    \"crypto/sha256\"\n    \"encoding/base64\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"time\"\n\n    \"github.com/google/uuid\"\n)\n\n// APIKey represents a stored API key. The raw key value is never persisted;\n// only its SHA-256 hex hash and an 8-character display prefix are stored.\ntype APIKey struct {\n    ID          string    `json:\"id\"`\n    Name        string    `json:\"name\"`\n    KeyHash     string    `json:\"key_hash\"`\n    Prefix      string    `json:\"prefix\"`\n    Permissions []string  `json:\"permissions\"`\n    Enabled     bool      `json:\"enabled\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n    UpdatedAt   time.Time `json:\"updated_at\"`\n}\n\n// NewAPIKey creates a new APIKey from a raw key string.\n// The raw key is not stored; call GenerateAPIKey to produce one.\nfunc NewAPIKey(id, name, rawKey string, permissions []string) *APIKey {\n    now := time.Now().UTC()\n    prefix := rawKey\n    if len(prefix) &gt; 8 {\n        prefix = prefix[:8]\n    }\n    return &amp;APIKey{\n        ID:          id,\n        Name:        name,\n        KeyHash:     HashAPIKey(rawKey),\n        Prefix:      prefix,\n        Permissions: permissions,\n        Enabled:     true,\n        CreatedAt:   now,\n        UpdatedAt:   now,\n    }\n}\n\n// GenerateAPIKey produces a new random API key in the format upd_&lt;32 url-safe base64 chars&gt;.\n// The caller is responsible for hashing before storage.\nfunc GenerateAPIKey() (string, error) {\n    b := make([]byte, 33) // 33 bytes \u2192 44 base64url chars\n    if _, err := rand.Read(b); err != nil {\n        return \"\", fmt.Errorf(\"generate api key: %w\", err)\n    }\n    return \"upd_\" + base64.RawURLEncoding.EncodeToString(b), nil\n}\n\n// HashAPIKey computes the SHA-256 hex digest of a raw API key.\nfunc HashAPIKey(rawKey string) string {\n    sum := sha256.Sum256([]byte(rawKey))\n    return hex.EncodeToString(sum[:])\n}\n\n// NewKeyID generates a new UUID v4 for use as an APIKey ID.\nfunc NewKeyID() string {\n    return uuid.New().String()\n}\n\n// HasPermission returns true when the key is enabled and possesses the required permission.\n// The admin permission and the wildcard \"*\" grant all access; write implies read.\nfunc (ak *APIKey) HasPermission(required string) bool {\n    if !ak.Enabled {\n        return false\n    }\n    for _, p := range ak.Permissions {\n        switch p {\n        case \"*\", \"admin\":\n            return true\n        case \"write\":\n            if required == \"read\" || required == \"write\" {\n                return true\n            }\n        case required:\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <p>Step 4: Update <code>internal/models/config.go</code></p> <p>Replace the <code>SecurityConfig</code> struct and the old <code>APIKey</code> struct + <code>HasPermission</code> method. The <code>APIKey</code> struct is now in <code>api_key.go</code>; <code>SecurityConfig</code> gains <code>BootstrapKey</code> and loses <code>APIKeys []APIKey</code>.</p> <p>Find and replace in <code>config.go</code>:</p> <pre><code>// OLD (lines 88-101)\ntype SecurityConfig struct {\n    APIKeys        []APIKey        `yaml:\"api_keys\" json:\"api_keys\"`\n    RateLimit      RateLimitConfig `yaml:\"rate_limit\" json:\"rate_limit\"`\n    JWTSecret      string          `yaml:\"jwt_secret\" json:\"jwt_secret\"`\n    EnableAuth     bool            `yaml:\"enable_auth\" json:\"enable_auth\"`\n    TrustedProxies []string        `yaml:\"trusted_proxies\" json:\"trusted_proxies\"`\n}\n\ntype APIKey struct {\n    Key         string   `yaml:\"key\" json:\"key\"`\n    Name        string   `yaml:\"name\" json:\"name\"`\n    Permissions []string `yaml:\"permissions\" json:\"permissions\"`\n    Enabled     bool     `yaml:\"enabled\" json:\"enabled\"`\n}\n</code></pre> <pre><code>// NEW\ntype SecurityConfig struct {\n    BootstrapKey   string          `yaml:\"bootstrap_key\" json:\"bootstrap_key\"`\n    RateLimit      RateLimitConfig `yaml:\"rate_limit\" json:\"rate_limit\"`\n    JWTSecret      string          `yaml:\"jwt_secret\" json:\"jwt_secret\"`\n    EnableAuth     bool            `yaml:\"enable_auth\" json:\"enable_auth\"`\n    TrustedProxies []string        `yaml:\"trusted_proxies\" json:\"trusted_proxies\"`\n}\n</code></pre> <p>Also remove the old <code>HasPermission</code> method at the bottom of <code>config.go</code> (lines 494-504), since it now lives in <code>api_key.go</code>.</p> <p>Also update <code>NewDefaultConfig</code> \u2014 remove <code>APIKeys: []APIKey{}</code> from the Security section.</p> <p>Also update <code>SecurityConfig.Validate()</code> \u2014 remove the loop that validates <code>sec.APIKeys</code>.</p> <p>Step 5: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS. (There may be compile errors in other packages that reference the old <code>APIKey.Key</code> field \u2014 those are fixed in later tasks.)</p> <p>Step 6: Commit</p> <pre><code>git add internal/models/api_key.go internal/models/api_key_test.go internal/models/config.go\ngit commit -m \"feat(models): add APIKey model with SHA-256 hashing helpers\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-2-extend-the-storage-interface","title":"Task 2: Extend the Storage interface","text":"<p>Files: - Modify: <code>internal/storage/interface.go</code></p> <p>Context: Five new methods must be added to the <code>Storage</code> interface. All four backends (memory, JSON, SQLite, PostgreSQL) and the <code>InstrumentedStorage</code> wrapper in <code>observability</code> must implement them. Add the interface methods first so the compiler guides the remaining work.</p> <p>Step 1: Add methods to <code>internal/storage/interface.go</code></p> <p>Append to the <code>Storage</code> interface (after the <code>Ping</code> and <code>Close</code> methods):</p> <pre><code>// CreateAPIKey stores a new API key.\nCreateAPIKey(ctx context.Context, key *models.APIKey) error\n\n// GetAPIKeyByHash retrieves an API key by its SHA-256 hash.\n// Returns storage.ErrNotFound if no matching enabled key exists.\nGetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error)\n\n// ListAPIKeys returns all API keys (both enabled and disabled).\nListAPIKeys(ctx context.Context) ([]*models.APIKey, error)\n\n// UpdateAPIKey replaces the mutable fields of an existing API key.\nUpdateAPIKey(ctx context.Context, key *models.APIKey) error\n\n// DeleteAPIKey permanently removes an API key by ID.\nDeleteAPIKey(ctx context.Context, id string) error\n</code></pre> <p>Step 2: Run build to see what needs implementing</p> <pre><code>make build\n</code></pre> <p>Expected: compile errors listing every type that is missing the new methods.</p> <p>Step 3: Commit</p> <pre><code>git add internal/storage/interface.go\ngit commit -m \"feat(storage): extend Storage interface with APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-3-memory-storage-apikey-methods","title":"Task 3: Memory storage \u2014 APIKey methods","text":"<p>Files: - Modify: <code>internal/storage/memory.go</code> - Modify: <code>internal/storage/memory_test.go</code></p> <p>Context: <code>MemoryStorage</code> uses <code>sync.RWMutex</code> plus maps for fast access. Add a primary map keyed by ID and a secondary map keyed by hash for O(1) auth lookups.</p> <p>Step 1: Write the failing tests</p> <p>Add to <code>internal/storage/memory_test.go</code>:</p> <pre><code>func TestMemoryStorage_APIKeyCRUD(t *testing.T) {\n    s, _ := NewMemoryStorage(Config{})\n    ctx := context.Background()\n\n    raw, _ := models.GenerateAPIKey()\n    key := models.NewAPIKey(models.NewKeyID(), \"test\", raw, []string{\"read\"})\n\n    // Create\n    require.NoError(t, s.CreateAPIKey(ctx, key))\n\n    // GetByHash\n    got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)\n    require.NoError(t, err)\n    assert.Equal(t, key.ID, got.ID)\n\n    // List\n    list, err := s.ListAPIKeys(ctx)\n    require.NoError(t, err)\n    assert.Len(t, list, 1)\n\n    // Update\n    key.Name = \"updated\"\n    require.NoError(t, s.UpdateAPIKey(ctx, key))\n    got, _ = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Equal(t, \"updated\", got.Name)\n\n    // Delete\n    require.NoError(t, s.DeleteAPIKey(ctx, key.ID))\n    _, err = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Error(t, err)\n}\n\nfunc TestMemoryStorage_GetAPIKeyByHash_NotFound(t *testing.T) {\n    s, _ := NewMemoryStorage(Config{})\n    _, err := s.GetAPIKeyByHash(context.Background(), \"nonexistent\")\n    assert.ErrorIs(t, err, ErrNotFound)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 methods not found.</p> <p>Step 3: Add fields and implement methods in <code>internal/storage/memory.go</code></p> <p>Add to <code>MemoryStorage</code> struct: <pre><code>apiKeys     map[string]*models.APIKey // keyed by ID\napiKeyHashes map[string]string         // hash \u2192 ID\n</code></pre></p> <p>Update <code>NewMemoryStorage</code> to initialise both maps.</p> <p>Then add the five methods following the same pattern as <code>SaveApplication</code> (copy-on-return, mutex lock):</p> <pre><code>func (m *MemoryStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    c := *key\n    m.apiKeys[key.ID] = &amp;c\n    m.apiKeyHashes[key.KeyHash] = key.ID\n    return nil\n}\n\nfunc (m *MemoryStorage) GetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    id, ok := m.apiKeyHashes[hash]\n    if !ok {\n        return nil, ErrNotFound\n    }\n    k := *m.apiKeys[id]\n    return &amp;k, nil\n}\n\nfunc (m *MemoryStorage) ListAPIKeys(ctx context.Context) ([]*models.APIKey, error) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    out := make([]*models.APIKey, 0, len(m.apiKeys))\n    for _, k := range m.apiKeys {\n        c := *k\n        out = append(out, &amp;c)\n    }\n    return out, nil\n}\n\nfunc (m *MemoryStorage) UpdateAPIKey(ctx context.Context, key *models.APIKey) error {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    existing, ok := m.apiKeys[key.ID]\n    if !ok {\n        return ErrNotFound\n    }\n    // Update hash index if hash changed (shouldn't happen, but be safe)\n    if existing.KeyHash != key.KeyHash {\n        delete(m.apiKeyHashes, existing.KeyHash)\n        m.apiKeyHashes[key.KeyHash] = key.ID\n    }\n    c := *key\n    m.apiKeys[key.ID] = &amp;c\n    return nil\n}\n\nfunc (m *MemoryStorage) DeleteAPIKey(ctx context.Context, id string) error {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    k, ok := m.apiKeys[id]\n    if !ok {\n        return ErrNotFound\n    }\n    delete(m.apiKeyHashes, k.KeyHash)\n    delete(m.apiKeys, id)\n    return nil\n}\n</code></pre> <p>Check <code>internal/storage/errors.go</code> for the existing <code>ErrNotFound</code> sentinel \u2014 use it here.</p> <p>Step 4: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS for <code>TestMemoryStorage_APIKeyCRUD</code> and <code>TestMemoryStorage_GetAPIKeyByHash_NotFound</code>.</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/memory.go internal/storage/memory_test.go\ngit commit -m \"feat(storage/memory): implement APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-4-json-storage-apikey-methods","title":"Task 4: JSON storage \u2014 APIKey methods","text":"<p>Files: - Modify: <code>internal/storage/json.go</code> - Modify: <code>internal/storage/json_test.go</code></p> <p>Context: <code>JSONStorage</code> uses a <code>JSONData</code> struct that is serialised to disk. Add an <code>APIKeys</code> field to <code>JSONData</code> so keys persist. Follow the existing <code>save</code>/<code>load</code> pattern.</p> <p>Step 1: Write failing tests</p> <p>Add to <code>internal/storage/json_test.go</code>:</p> <pre><code>func TestJSONStorage_APIKeyCRUD(t *testing.T) {\n    dir := t.TempDir()\n    s, err := NewJSONStorage(Config{Path: filepath.Join(dir, \"data.json\")})\n    require.NoError(t, err)\n    ctx := context.Background()\n\n    raw, _ := models.GenerateAPIKey()\n    key := models.NewAPIKey(models.NewKeyID(), \"ci\", raw, []string{\"write\"})\n\n    require.NoError(t, s.CreateAPIKey(ctx, key))\n\n    got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)\n    require.NoError(t, err)\n    assert.Equal(t, \"ci\", got.Name)\n\n    keys, err := s.ListAPIKeys(ctx)\n    require.NoError(t, err)\n    assert.Len(t, keys, 1)\n\n    key.Name = \"ci-updated\"\n    require.NoError(t, s.UpdateAPIKey(ctx, key))\n\n    require.NoError(t, s.DeleteAPIKey(ctx, key.ID))\n    _, err = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Error(t, err)\n}\n</code></pre> <p>Step 2: Run to verify failure</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 methods not found.</p> <p>Step 3: Implement in <code>internal/storage/json.go</code></p> <ol> <li> <p>Add <code>APIKeys []*models.APIKey \\</code>json:\"api_keys\"`<code>to</code>JSONData`.</p> </li> <li> <p>Initialise in <code>ensureFileExists</code>: <pre><code>data = &amp;JSONData{\n    Applications: []*models.Application{},\n    Releases:     []*models.Release{},\n    APIKeys:      []*models.APIKey{},\n    LastUpdated:  time.Now(),\n}\n</code></pre></p> </li> <li> <p>Add the five methods. Each method calls <code>s.loadData()</code>, mutates <code>s.data.APIKeys</code>, then calls <code>s.saveData()</code>. Follow the same locking pattern as the existing application methods:</p> </li> </ol> <pre><code>func (j *JSONStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {\n    j.mu.Lock()\n    defer j.mu.Unlock()\n    if err := j.loadData(); err != nil {\n        return err\n    }\n    c := *key\n    j.data.APIKeys = append(j.data.APIKeys, &amp;c)\n    return j.saveData()\n}\n\nfunc (j *JSONStorage) GetAPIKeyByHash(ctx context.Context, hash string) (*models.APIKey, error) {\n    j.mu.RLock()\n    defer j.mu.RUnlock()\n    if err := j.loadData(); err != nil {\n        return nil, err\n    }\n    for _, k := range j.data.APIKeys {\n        if k.KeyHash == hash {\n            c := *k\n            return &amp;c, nil\n        }\n    }\n    return nil, ErrNotFound\n}\n\nfunc (j *JSONStorage) ListAPIKeys(ctx context.Context) ([]*models.APIKey, error) {\n    j.mu.RLock()\n    defer j.mu.RUnlock()\n    if err := j.loadData(); err != nil {\n        return nil, err\n    }\n    out := make([]*models.APIKey, len(j.data.APIKeys))\n    for i, k := range j.data.APIKeys {\n        c := *k\n        out[i] = &amp;c\n    }\n    return out, nil\n}\n\nfunc (j *JSONStorage) UpdateAPIKey(ctx context.Context, key *models.APIKey) error {\n    j.mu.Lock()\n    defer j.mu.Unlock()\n    if err := j.loadData(); err != nil {\n        return err\n    }\n    for i, k := range j.data.APIKeys {\n        if k.ID == key.ID {\n            c := *key\n            j.data.APIKeys[i] = &amp;c\n            return j.saveData()\n        }\n    }\n    return ErrNotFound\n}\n\nfunc (j *JSONStorage) DeleteAPIKey(ctx context.Context, id string) error {\n    j.mu.Lock()\n    defer j.mu.Unlock()\n    if err := j.loadData(); err != nil {\n        return err\n    }\n    for i, k := range j.data.APIKeys {\n        if k.ID == id {\n            j.data.APIKeys = append(j.data.APIKeys[:i], j.data.APIKeys[i+1:]...)\n            return j.saveData()\n        }\n    }\n    return ErrNotFound\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/json.go internal/storage/json_test.go\ngit commit -m \"feat(storage/json): implement APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-5-sqlite-schema-and-queries","title":"Task 5: SQLite schema and queries","text":"<p>Files: - Create: <code>internal/storage/sqlc/schema/sqlite/004_api_keys.sql</code> - Create: <code>internal/storage/sqlc/queries/sqlite/api_keys.sql</code></p> <p>Context: The sqlc tool generates Go code from SQL. Add a migration file for the <code>api_keys</code> table and a queries file. Run <code>make sqlc-generate</code> afterwards. The schema follows the same conventions as <code>001_initial.sql</code>: <code>TEXT</code> primary key, <code>TEXT NOT NULL DEFAULT (datetime('now'))</code> timestamps, JSON array as <code>TEXT</code> for <code>permissions</code>.</p> <p>Step 1: Create the schema migration</p> <pre><code>-- internal/storage/sqlc/schema/sqlite/004_api_keys.sql\n-- API keys table (SQLite version)\nCREATE TABLE api_keys (\n    id          TEXT NOT NULL PRIMARY KEY,\n    name        TEXT NOT NULL,\n    key_hash    TEXT NOT NULL UNIQUE,\n    prefix      TEXT NOT NULL,\n    permissions TEXT NOT NULL DEFAULT '[]', -- JSON array as TEXT\n    enabled     INTEGER NOT NULL DEFAULT 1,\n    created_at  TEXT NOT NULL DEFAULT (datetime('now')),\n    updated_at  TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE INDEX idx_api_keys_hash ON api_keys(key_hash);\n\nCREATE TRIGGER update_api_keys_updated_at\n    AFTER UPDATE ON api_keys\n    FOR EACH ROW\nBEGIN\n    UPDATE api_keys SET updated_at = datetime('now') WHERE id = NEW.id;\nEND;\n</code></pre> <p>Step 2: Create the query file</p> <pre><code>-- internal/storage/sqlc/queries/sqlite/api_keys.sql\n\n-- name: CreateAPIKey :exec\nINSERT INTO api_keys (id, name, key_hash, prefix, permissions, enabled, created_at, updated_at)\nVALUES (?, ?, ?, ?, ?, ?, ?, ?);\n\n-- name: GetAPIKeyByHash :one\nSELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at\nFROM api_keys\nWHERE key_hash = ?;\n\n-- name: ListAPIKeys :many\nSELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at\nFROM api_keys\nORDER BY created_at;\n\n-- name: UpdateAPIKey :exec\nUPDATE api_keys\nSET name = ?, permissions = ?, enabled = ?, updated_at = ?\nWHERE id = ?;\n\n-- name: DeleteAPIKey :exec\nDELETE FROM api_keys\nWHERE id = ?;\n</code></pre> <p>Step 3: Run sqlc-generate</p> <pre><code>make sqlc-generate\n</code></pre> <p>Expected: new file <code>internal/storage/sqlc/sqlite/api_keys.sql.go</code> created; <code>internal/storage/sqlc/sqlite/models.go</code> updated with an <code>ApiKey</code> struct.</p> <p>Step 4: Commit</p> <pre><code>git add internal/storage/sqlc/schema/sqlite/004_api_keys.sql \\\n        internal/storage/sqlc/queries/sqlite/api_keys.sql \\\n        internal/storage/sqlc/sqlite/\ngit commit -m \"feat(storage/sqlc/sqlite): add api_keys table schema and generated queries\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-6-postgresql-schema-and-queries","title":"Task 6: PostgreSQL schema and queries","text":"<p>Files: - Create: <code>internal/storage/sqlc/schema/postgres/004_api_keys.sql</code> - Create: <code>internal/storage/sqlc/queries/postgres/api_keys.sql</code></p> <p>Context: Same as Task 5 but using PostgreSQL syntax: <code>TIMESTAMPTZ</code>, <code>JSONB</code> for permissions, <code>$1</code>-style placeholders, and a trigger using the existing <code>update_updated_at_column()</code> function from <code>001_initial.sql</code>.</p> <p>Step 1: Create the schema migration</p> <pre><code>-- internal/storage/sqlc/schema/postgres/004_api_keys.sql\n-- API keys table (PostgreSQL version)\nCREATE TABLE api_keys (\n    id          TEXT        NOT NULL PRIMARY KEY,\n    name        TEXT        NOT NULL,\n    key_hash    TEXT        NOT NULL UNIQUE,\n    prefix      TEXT        NOT NULL,\n    permissions JSONB       NOT NULL DEFAULT '[]',\n    enabled     BOOLEAN     NOT NULL DEFAULT TRUE,\n    created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_api_keys_hash ON api_keys(key_hash);\n\nCREATE TRIGGER update_api_keys_updated_at\n    BEFORE UPDATE ON api_keys\n    FOR EACH ROW\n    EXECUTE FUNCTION update_updated_at_column();\n</code></pre> <p>Step 2: Create the query file</p> <pre><code>-- internal/storage/sqlc/queries/postgres/api_keys.sql\n\n-- name: CreateAPIKey :exec\nINSERT INTO api_keys (id, name, key_hash, prefix, permissions, enabled, created_at, updated_at)\nVALUES ($1, $2, $3, $4, $5, $6, $7, $8);\n\n-- name: GetAPIKeyByHash :one\nSELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at\nFROM api_keys\nWHERE key_hash = $1;\n\n-- name: ListAPIKeys :many\nSELECT id, name, key_hash, prefix, permissions, enabled, created_at, updated_at\nFROM api_keys\nORDER BY created_at;\n\n-- name: UpdateAPIKey :exec\nUPDATE api_keys\nSET name = $2, permissions = $3, enabled = $4, updated_at = $5\nWHERE id = $1;\n\n-- name: DeleteAPIKey :exec\nDELETE FROM api_keys\nWHERE id = $1;\n</code></pre> <p>Step 3: Run sqlc-generate</p> <pre><code>make sqlc-generate\n</code></pre> <p>Expected: <code>internal/storage/sqlc/postgres/api_keys.sql.go</code> created; <code>models.go</code> updated.</p> <p>Step 4: Commit</p> <pre><code>git add internal/storage/sqlc/schema/postgres/004_api_keys.sql \\\n        internal/storage/sqlc/queries/postgres/api_keys.sql \\\n        internal/storage/sqlc/postgres/\ngit commit -m \"feat(storage/sqlc/postgres): add api_keys table schema and generated queries\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-7-sqlite-storage-apikey-methods","title":"Task 7: SQLite storage \u2014 APIKey methods","text":"<p>Files: - Modify: <code>internal/storage/sqlite.go</code> - Modify: <code>internal/storage/sqlite_test.go</code> - Create: <code>internal/storage/dbconvert.go</code> (add helpers, do not replace \u2014 see context)</p> <p>Context: <code>SQLiteStorage</code> uses the sqlc-generated <code>Queries</code> type. After <code>make sqlc-generate</code> in Tasks 5\u20136, the generated package <code>sqlcite</code> has <code>ApiKey</code> rows and query methods. Convert between <code>sqlcite.ApiKey</code> and <code>models.APIKey</code> using the same pattern as <code>dbconvert.go</code> does for applications. The <code>permissions</code> field is a JSON TEXT column in SQLite.</p> <p>Step 1: Add conversion helpers to <code>internal/storage/dbconvert.go</code></p> <p>Append (do not replace) the following functions:</p> <pre><code>// marshalPermissions serialises a permissions slice to JSON.\nfunc marshalPermissions(perms []string) ([]byte, error) {\n    if perms == nil {\n        perms = []string{}\n    }\n    return json.Marshal(perms)\n}\n\n// unmarshalPermissionsFromString parses a JSON string into a permissions slice.\nfunc unmarshalPermissionsFromString(data string) ([]string, error) {\n    if data == \"\" {\n        return []string{}, nil\n    }\n    var perms []string\n    if err := json.Unmarshal([]byte(data), &amp;perms); err != nil {\n        return nil, fmt.Errorf(\"unmarshal permissions: %w\", err)\n    }\n    if perms == nil {\n        perms = []string{}\n    }\n    return perms, nil\n}\n</code></pre> <p>Step 2: Write failing tests</p> <p>Add to <code>internal/storage/sqlite_test.go</code>:</p> <pre><code>func TestSQLiteStorage_APIKeyCRUD(t *testing.T) {\n    s := newTestSQLiteStorage(t) // use existing helper\n    ctx := context.Background()\n\n    raw, _ := models.GenerateAPIKey()\n    key := models.NewAPIKey(models.NewKeyID(), \"deploy\", raw, []string{\"write\"})\n\n    require.NoError(t, s.CreateAPIKey(ctx, key))\n\n    got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)\n    require.NoError(t, err)\n    assert.Equal(t, key.ID, got.ID)\n    assert.Equal(t, []string{\"write\"}, got.Permissions)\n\n    keys, err := s.ListAPIKeys(ctx)\n    require.NoError(t, err)\n    assert.Len(t, keys, 1)\n\n    key.Name = \"deploy-v2\"\n    key.Permissions = []string{\"write\", \"read\"}\n    require.NoError(t, s.UpdateAPIKey(ctx, key))\n\n    got, _ = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Equal(t, \"deploy-v2\", got.Name)\n\n    require.NoError(t, s.DeleteAPIKey(ctx, key.ID))\n    _, err = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Error(t, err)\n}\n</code></pre> <p>Step 3: Run to verify failure</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 methods not defined.</p> <p>Step 4: Implement in <code>internal/storage/sqlite.go</code></p> <p>Look up the generated function names in <code>internal/storage/sqlc/sqlite/api_keys.sql.go</code>. They will be methods on <code>*sqlcite.Queries</code>, e.g. <code>q.CreateAPIKey(ctx, sqlcite.CreateAPIKeyParams{...})</code>.</p> <p>Add a helper to convert <code>sqlcite.ApiKey</code> \u2192 <code>*models.APIKey</code>:</p> <pre><code>func sqliteAPIKeyToModel(row sqlcite.ApiKey) (*models.APIKey, error) {\n    perms, err := unmarshalPermissionsFromString(row.Permissions)\n    if err != nil {\n        return nil, err\n    }\n    createdAt, _ := time.Parse(\"2006-01-02T15:04:05Z\", row.CreatedAt)\n    updatedAt, _ := time.Parse(\"2006-01-02T15:04:05Z\", row.UpdatedAt)\n    return &amp;models.APIKey{\n        ID:          row.ID,\n        Name:        row.Name,\n        KeyHash:     row.KeyHash,\n        Prefix:      row.Prefix,\n        Permissions: perms,\n        Enabled:     row.Enabled,\n        CreatedAt:   createdAt,\n        UpdatedAt:   updatedAt,\n    }, nil\n}\n</code></pre> <p>Then implement the five methods using the generated queries. For <code>CreateAPIKey</code>: <pre><code>func (s *SQLiteStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {\n    permsJSON, err := marshalPermissions(key.Permissions)\n    if err != nil {\n        return err\n    }\n    return s.queries.CreateAPIKey(ctx, sqlcite.CreateAPIKeyParams{\n        ID:          key.ID,\n        Name:        key.Name,\n        KeyHash:     key.KeyHash,\n        Prefix:      key.Prefix,\n        Permissions: string(permsJSON),\n        Enabled:     key.Enabled,\n        CreatedAt:   key.CreatedAt.UTC().Format(\"2006-01-02T15:04:05Z\"),\n        UpdatedAt:   key.UpdatedAt.UTC().Format(\"2006-01-02T15:04:05Z\"),\n    })\n}\n</code></pre></p> <p>Use the same pattern for the remaining four methods. For <code>GetAPIKeyByHash</code>, call <code>s.queries.GetAPIKeyByHash(ctx, hash)</code> and convert with <code>sqliteAPIKeyToModel</code>. Return <code>ErrNotFound</code> when the sqlc result is <code>sql.ErrNoRows</code>. For <code>UpdateAPIKey</code>, the generated params use <code>(id, name, permissions, enabled, updated_at)</code> \u2014 match the column order in your query.</p> <p>Step 5: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 6: Commit</p> <pre><code>git add internal/storage/sqlite.go internal/storage/sqlite_test.go internal/storage/dbconvert.go\ngit commit -m \"feat(storage/sqlite): implement APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-8-postgresql-storage-apikey-methods","title":"Task 8: PostgreSQL storage \u2014 APIKey methods","text":"<p>Files: - Modify: <code>internal/storage/postgres.go</code> - Modify: <code>internal/storage/postgres_test.go</code></p> <p>Context: Same pattern as Task 7. PostgreSQL uses JSONB for permissions (stored as <code>pgtype.Text</code> or a raw JSON string depending on how sqlc generates it \u2014 check <code>internal/storage/sqlc/postgres/models.go</code> after generation). Timestamps use <code>time.Time</code> via <code>pgx</code>. The test helper <code>newTestPostgresStorage</code> may require a running database; if one isn't available in the test environment, add a <code>t.Skip(\"requires postgres\")</code> guard consistent with how the existing postgres tests skip.</p> <p>Step 1: Write failing tests</p> <p>Add to <code>internal/storage/postgres_test.go</code> (mirroring the SQLite test structure and existing skip guard):</p> <pre><code>func TestPostgresStorage_APIKeyCRUD(t *testing.T) {\n    s := newTestPostgresStorage(t) // skips if no DB available\n    ctx := context.Background()\n\n    raw, _ := models.GenerateAPIKey()\n    key := models.NewAPIKey(models.NewKeyID(), \"ci\", raw, []string{\"write\"})\n\n    require.NoError(t, s.CreateAPIKey(ctx, key))\n\n    got, err := s.GetAPIKeyByHash(ctx, key.KeyHash)\n    require.NoError(t, err)\n    assert.Equal(t, key.ID, got.ID)\n    assert.Equal(t, []string{\"write\"}, got.Permissions)\n\n    key.Name = \"ci-v2\"\n    require.NoError(t, s.UpdateAPIKey(ctx, key))\n\n    require.NoError(t, s.DeleteAPIKey(ctx, key.ID))\n    _, err = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.Error(t, err)\n}\n</code></pre> <p>Step 2: Implement in <code>internal/storage/postgres.go</code></p> <p>Inspect <code>internal/storage/sqlc/postgres/models.go</code> for the generated <code>ApiKey</code> type and <code>internal/storage/sqlc/postgres/api_keys.sql.go</code> for the query method signatures.</p> <p>Add a conversion helper <code>postgresAPIKeyToModel</code> similar to the SQLite version; handle the JSONB permissions field. Then implement the five methods using the generated queries.</p> <p>Step 3: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS (postgres tests skip if no DB).</p> <p>Step 4: Commit</p> <pre><code>git add internal/storage/postgres.go internal/storage/postgres_test.go\ngit commit -m \"feat(storage/postgres): implement APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-9-instrumentedstorage-apikey-methods","title":"Task 9: InstrumentedStorage \u2014 APIKey methods","text":"<p>Files: - Modify: <code>internal/observability/storage.go</code> - Modify: <code>internal/observability/storage_test.go</code></p> <p>Context: <code>InstrumentedStorage</code> in <code>internal/observability/storage.go</code> wraps a <code>storage.Storage</code> and records OTel spans + metrics for each method. It must implement the five new interface methods. Each method follows the existing pattern: call <code>s.startSpan(...)</code>, defer <code>s.recordDuration(...)</code>, call the inner method, and call <code>s.recordError(...)</code> on failure.</p> <p>Look at an existing method such as <code>GetApplication</code> or <code>Ping</code> in <code>storage.go</code> to understand the exact instrumentation pattern, then repeat it for each new method.</p> <p>Step 1: Write failing tests</p> <p>Add to <code>internal/observability/storage_test.go</code> \u2014 use the existing test setup (mock inner storage or a MemoryStorage):</p> <pre><code>func TestInstrumentedStorage_APIKeyMethods(t *testing.T) {\n    inner, _ := storage.NewMemoryStorage(storage.Config{})\n    s, err := NewInstrumentedStorage(inner)\n    require.NoError(t, err)\n    ctx := context.Background()\n\n    raw, _ := models.GenerateAPIKey()\n    key := models.NewAPIKey(models.NewKeyID(), \"test\", raw, []string{\"read\"})\n\n    assert.NoError(t, s.CreateAPIKey(ctx, key))\n    _, err = s.GetAPIKeyByHash(ctx, key.KeyHash)\n    assert.NoError(t, err)\n    _, err = s.ListAPIKeys(ctx)\n    assert.NoError(t, err)\n    key.Name = \"test2\"\n    assert.NoError(t, s.UpdateAPIKey(ctx, key))\n    assert.NoError(t, s.DeleteAPIKey(ctx, key.ID))\n}\n</code></pre> <p>Step 2: Implement the five methods in <code>internal/observability/storage.go</code></p> <p>Follow the existing pattern exactly. Example for <code>CreateAPIKey</code>:</p> <pre><code>func (s *InstrumentedStorage) CreateAPIKey(ctx context.Context, key *models.APIKey) error {\n    ctx, span := s.startSpan(ctx, \"CreateAPIKey\")\n    start := time.Now()\n    defer s.recordDuration(ctx, \"CreateAPIKey\", start)\n    defer span.End()\n    err := s.inner.CreateAPIKey(ctx, key)\n    s.recordError(ctx, \"CreateAPIKey\", err)\n    return err\n}\n</code></pre> <p>Repeat for the other four methods. Do not add new OTel attributes beyond what the existing pattern uses.</p> <p>Step 3: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 4: Commit</p> <pre><code>git add internal/observability/storage.go internal/observability/storage_test.go\ngit commit -m \"feat(observability): instrument APIKey CRUD methods\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-10-bootstrap-seeding","title":"Task 10: Bootstrap seeding","text":"<p>Files: - Modify: <code>cmd/updater/updater.go</code></p> <p>Context: After storage is initialised (and optionally wrapped with <code>InstrumentedStorage</code>), check if <code>config.Security.BootstrapKey</code> is set. If it is, hash it and call <code>GetAPIKeyByHash</code>. If not found, create the key in storage. This is idempotent \u2014 safe to call on every restart.</p> <p>Step 1: Add <code>seedBootstrapKey</code> function</p> <p>Add after <code>initializeStorage</code> in <code>cmd/updater/updater.go</code>:</p> <pre><code>// seedBootstrapKey inserts the configured bootstrap key into storage if it\n// does not already exist. It is a no-op when BootstrapKey is empty.\nfunc seedBootstrapKey(ctx context.Context, store storage.Storage, cfg *models.Config) error {\n    raw := cfg.Security.BootstrapKey\n    if raw == \"\" {\n        return nil\n    }\n    hash := models.HashAPIKey(raw)\n    if _, err := store.GetAPIKeyByHash(ctx, hash); err == nil {\n        // Already seeded.\n        return nil\n    }\n    key := models.NewAPIKey(models.NewKeyID(), \"bootstrap\", raw, []string{\"admin\"})\n    if err := store.CreateAPIKey(ctx, key); err != nil {\n        return fmt.Errorf(\"seed bootstrap key: %w\", err)\n    }\n    slog.Info(\"bootstrap API key seeded\", \"id\", key.ID, \"prefix\", key.Prefix)\n    return nil\n}\n</code></pre> <p>Step 2: Call it in <code>main</code></p> <p>In <code>main()</code>, after <code>activeStorage</code> is assigned, add:</p> <pre><code>if err := seedBootstrapKey(context.Background(), activeStorage, cfg); err != nil {\n    slog.Error(\"Failed to seed bootstrap key\", \"error\", err)\n    os.Exit(1)\n}\n</code></pre> <p>Step 3: Build</p> <pre><code>make build\n</code></pre> <p>Expected: successful build.</p> <p>Step 4: Commit</p> <pre><code>git add cmd/updater/updater.go\ngit commit -m \"feat(cmd): seed bootstrap API key into storage on startup\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-11-update-auth-and-admin-middleware-to-use-storage","title":"Task 11: Update auth and admin middleware to use storage","text":"<p>Files: - Modify: <code>internal/api/routes.go</code> - Modify: <code>internal/api/middleware.go</code> - Modify: <code>internal/api/middleware_admin.go</code> - Modify: <code>internal/api/handlers_admin.go</code></p> <p>Context: Four functions currently look up keys from <code>config.Security.APIKeys</code> (a <code>[]models.APIKey</code> slice that no longer exists). They must all switch to querying storage by SHA-256 hash. Storage is already available on <code>*Handlers</code>; thread it through to the middleware closures via the <code>SetupRoutes</code> parameters.</p> <p>Note: After removing <code>APIKeys []APIKey</code> from <code>SecurityConfig</code> in Task 1, these four functions will already have compile errors \u2014 fix them here.</p> <p>Step 1: Update <code>authMiddleware</code> in <code>routes.go</code></p> <p>Change signature from: <pre><code>func authMiddleware(securityConfig models.SecurityConfig) mux.MiddlewareFunc\n</code></pre> To: <pre><code>func authMiddleware(securityConfig models.SecurityConfig, store storage.Storage) mux.MiddlewareFunc\n</code></pre></p> <p>Replace the loop body with a storage lookup: <pre><code>token := authHeader[len(prefix):]\nhash := models.HashAPIKey(token)\nvalidKey, err := store.GetAPIKeyByHash(r.Context(), hash)\nif err != nil || !validKey.Enabled {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusUnauthorized)\n    json.NewEncoder(w).Encode(models.NewErrorResponse(\"Invalid API key\", models.ErrorCodeUnauthorized))\n    return\n}\nctx := context.WithValue(r.Context(), \"api_key\", validKey)\nnext.ServeHTTP(w, r.WithContext(ctx))\n</code></pre></p> <p>In <code>SetupRoutes</code>, update all calls from <code>authMiddleware(config.Security)</code> to <code>authMiddleware(config.Security, handlers.storage)</code>.</p> <p>Step 2: Update <code>OptionalAuth</code> in <code>middleware.go</code></p> <p>Same signature change: add <code>store storage.Storage</code> parameter. Replace the loop with: <pre><code>hash := models.HashAPIKey(token)\nvalidKey, err := store.GetAPIKeyByHash(r.Context(), hash)\nif err == nil &amp;&amp; validKey.Enabled {\n    ctx := context.WithValue(r.Context(), \"api_key\", validKey)\n    next.ServeHTTP(w, r.WithContext(ctx))\n    return\n}\nnext.ServeHTTP(w, r)\n</code></pre></p> <p>In <code>SetupRoutes</code>, update the call from <code>OptionalAuth(config.Security)</code> to <code>OptionalAuth(config.Security, handlers.storage)</code>.</p> <p>Step 3: Update <code>isValidAdminKey</code> and <code>adminSessionMiddleware</code> in <code>middleware_admin.go</code></p> <p><code>isValidAdminKey</code> needs a context and storage: <pre><code>func isValidAdminKey(ctx context.Context, key string, store storage.Storage) bool {\n    if key == \"\" {\n        return false\n    }\n    // Dev mode: no keys in storage \u2192 accept any non-empty key\n    keys, err := store.ListAPIKeys(ctx)\n    if err != nil || len(keys) == 0 {\n        return true\n    }\n    hash := models.HashAPIKey(key)\n    ak, err := store.GetAPIKeyByHash(ctx, hash)\n    if err != nil || !ak.Enabled {\n        return false\n    }\n    return ak.HasPermission(\"admin\")\n}\n</code></pre></p> <p>Update <code>adminSessionMiddleware</code> signature to accept <code>store storage.Storage</code>: <pre><code>func adminSessionMiddleware(cfg models.SecurityConfig, store storage.Storage) mux.MiddlewareFunc\n</code></pre></p> <p>Pass <code>r.Context()</code> and <code>store</code> to <code>isValidAdminKey</code>.</p> <p>In <code>SetupRoutes</code>, update the call: <pre><code>adminRouter.Use(adminSessionMiddleware(config.Security, handlers.storage))\n</code></pre></p> <p>Step 4: Update <code>AdminLogin</code> handler in <code>handlers_admin.go</code></p> <p><code>AdminLogin</code> calls <code>isValidAdminKey(key, h.securityConfig)</code> \u2014 update to pass context and storage: <pre><code>if !isValidAdminKey(r.Context(), key, h.storage) {\n</code></pre></p> <p>Step 5: Build</p> <pre><code>make build\n</code></pre> <p>Expected: successful build, no remaining compile errors referencing <code>APIKeys</code>.</p> <p>Step 6: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 7: Commit</p> <pre><code>git add internal/api/routes.go internal/api/middleware.go \\\n        internal/api/middleware_admin.go internal/api/handlers_admin.go\ngit commit -m \"feat(api): switch auth middleware to storage-backed key lookup\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-12-rest-handlers-for-key-management","title":"Task 12: REST handlers for key management","text":"<p>Files: - Create: <code>internal/api/handlers_keys.go</code> - Modify: <code>internal/api/routes.go</code> - Create: <code>internal/api/handlers_keys_test.go</code></p> <p>Context: Four handlers implement the key management REST API. They follow the same pattern as <code>handlers_admin.go</code>: decode JSON, call storage, return JSON. All four require <code>admin</code> permission and emit security audit log events.</p> <p>Step 1: Write failing tests</p> <pre><code>// internal/api/handlers_keys_test.go\npackage api_test\n\n// Table-driven tests for all four handlers using httptest.NewRecorder() and\n// a MemoryStorage instance. Cover: happy path, missing fields, not found,\n// permission denied (non-admin key).\n\nfunc TestListAPIKeys(t *testing.T) { ... }\nfunc TestCreateAPIKey(t *testing.T) { ... }\nfunc TestUpdateAPIKey(t *testing.T) { ... }\nfunc TestDeleteAPIKey(t *testing.T) { ... }\n</code></pre> <p>Use the same test setup pattern as existing handler tests in the <code>api</code> package.</p> <p>Step 2: Run to verify failure</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 handlers not defined.</p> <p>Step 3: Create <code>internal/api/handlers_keys.go</code></p> <pre><code>package api\n\nimport (\n    \"encoding/json\"\n    \"log/slog\"\n    \"net/http\"\n    \"time\"\n    \"updater/internal/models\"\n\n    \"github.com/google/uuid\"\n    \"github.com/gorilla/mux\"\n)\n\n// createAPIKeyRequest is the request body for POST /api/v1/admin/keys.\ntype createAPIKeyRequest struct {\n    Name        string   `json:\"name\"`\n    Permissions []string `json:\"permissions\"`\n}\n\n// createAPIKeyResponse includes the raw key \u2014 returned exactly once.\ntype createAPIKeyResponse struct {\n    ID          string    `json:\"id\"`\n    Name        string    `json:\"name\"`\n    Key         string    `json:\"key\"`\n    Prefix      string    `json:\"prefix\"`\n    Permissions []string  `json:\"permissions\"`\n    Enabled     bool      `json:\"enabled\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n}\n\n// apiKeyResponse is the metadata-only view (no raw key, no hash).\ntype apiKeyResponse struct {\n    ID          string    `json:\"id\"`\n    Name        string    `json:\"name\"`\n    Prefix      string    `json:\"prefix\"`\n    Permissions []string  `json:\"permissions\"`\n    Enabled     bool      `json:\"enabled\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n    UpdatedAt   time.Time `json:\"updated_at\"`\n}\n\n// updateAPIKeyRequest is the request body for PATCH /api/v1/admin/keys/{id}.\n// All fields are optional.\ntype updateAPIKeyRequest struct {\n    Name        *string   `json:\"name\"`\n    Permissions []string  `json:\"permissions\"`\n    Enabled     *bool     `json:\"enabled\"`\n}\n\nfunc apiKeyToResponse(k *models.APIKey) apiKeyResponse {\n    return apiKeyResponse{\n        ID:          k.ID,\n        Name:        k.Name,\n        Prefix:      k.Prefix,\n        Permissions: k.Permissions,\n        Enabled:     k.Enabled,\n        CreatedAt:   k.CreatedAt,\n        UpdatedAt:   k.UpdatedAt,\n    }\n}\n\n// ListAPIKeys handles GET /api/v1/admin/keys\nfunc (h *Handlers) ListAPIKeys(w http.ResponseWriter, r *http.Request) {\n    keys, err := h.storage.ListAPIKeys(r.Context())\n    if err != nil {\n        writeJSONError(w, http.StatusInternalServerError, \"failed to list keys\", models.ErrorCodeInternalError)\n        return\n    }\n    resp := make([]apiKeyResponse, len(keys))\n    for i, k := range keys {\n        resp[i] = apiKeyToResponse(k)\n    }\n    writeJSON(w, http.StatusOK, resp)\n}\n\n// CreateAPIKey handles POST /api/v1/admin/keys\nfunc (h *Handlers) CreateAPIKey(w http.ResponseWriter, r *http.Request) {\n    var req createAPIKeyRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        writeJSONError(w, http.StatusBadRequest, \"invalid request body\", models.ErrorCodeInvalidRequest)\n        return\n    }\n    if req.Name == \"\" {\n        writeJSONError(w, http.StatusBadRequest, \"name is required\", models.ErrorCodeInvalidRequest)\n        return\n    }\n    if len(req.Permissions) == 0 {\n        writeJSONError(w, http.StatusBadRequest, \"permissions is required\", models.ErrorCodeInvalidRequest)\n        return\n    }\n\n    rawKey, err := models.GenerateAPIKey()\n    if err != nil {\n        writeJSONError(w, http.StatusInternalServerError, \"failed to generate key\", models.ErrorCodeInternalError)\n        return\n    }\n\n    key := models.NewAPIKey(models.NewKeyID(), req.Name, rawKey, req.Permissions)\n    if err := h.storage.CreateAPIKey(r.Context(), key); err != nil {\n        writeJSONError(w, http.StatusInternalServerError, \"failed to create key\", models.ErrorCodeInternalError)\n        return\n    }\n\n    actor := actorKeyID(r)\n    slog.Info(\"api key created\",\n        \"event\", \"security_audit\",\n        \"action\", \"create\",\n        \"key_id\", key.ID,\n        \"key_name\", key.Name,\n        \"actor_key_id\", actor,\n    )\n\n    writeJSON(w, http.StatusCreated, createAPIKeyResponse{\n        ID:          key.ID,\n        Name:        key.Name,\n        Key:         rawKey,\n        Prefix:      key.Prefix,\n        Permissions: key.Permissions,\n        Enabled:     key.Enabled,\n        CreatedAt:   key.CreatedAt,\n    })\n}\n\n// UpdateAPIKey handles PATCH /api/v1/admin/keys/{id}\nfunc (h *Handlers) UpdateAPIKey(w http.ResponseWriter, r *http.Request) {\n    id := mux.Vars(r)[\"id\"]\n    var req updateAPIKeyRequest\n    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n        writeJSONError(w, http.StatusBadRequest, \"invalid request body\", models.ErrorCodeInvalidRequest)\n        return\n    }\n\n    // Fetch existing key to apply partial updates\n    keys, err := h.storage.ListAPIKeys(r.Context())\n    if err != nil {\n        writeJSONError(w, http.StatusInternalServerError, \"failed to fetch keys\", models.ErrorCodeInternalError)\n        return\n    }\n    var key *models.APIKey\n    for _, k := range keys {\n        if k.ID == id {\n            c := *k\n            key = &amp;c\n            break\n        }\n    }\n    if key == nil {\n        writeJSONError(w, http.StatusNotFound, \"key not found\", models.ErrorCodeNotFound)\n        return\n    }\n\n    if req.Name != nil {\n        key.Name = *req.Name\n    }\n    if req.Permissions != nil {\n        key.Permissions = req.Permissions\n    }\n    if req.Enabled != nil {\n        key.Enabled = *req.Enabled\n    }\n    key.UpdatedAt = time.Now().UTC()\n\n    if err := h.storage.UpdateAPIKey(r.Context(), key); err != nil {\n        writeJSONError(w, http.StatusInternalServerError, \"failed to update key\", models.ErrorCodeInternalError)\n        return\n    }\n\n    slog.Info(\"api key updated\",\n        \"event\", \"security_audit\",\n        \"action\", \"update\",\n        \"key_id\", key.ID,\n        \"key_name\", key.Name,\n        \"actor_key_id\", actorKeyID(r),\n    )\n\n    writeJSON(w, http.StatusOK, apiKeyToResponse(key))\n}\n\n// DeleteAPIKey handles DELETE /api/v1/admin/keys/{id}\nfunc (h *Handlers) DeleteAPIKey(w http.ResponseWriter, r *http.Request) {\n    id := mux.Vars(r)[\"id\"]\n    if err := h.storage.DeleteAPIKey(r.Context(), id); err != nil {\n        writeJSONError(w, http.StatusNotFound, \"key not found\", models.ErrorCodeNotFound)\n        return\n    }\n\n    slog.Info(\"api key deleted\",\n        \"event\", \"security_audit\",\n        \"action\", \"delete\",\n        \"key_id\", id,\n        \"actor_key_id\", actorKeyID(r),\n    )\n\n    w.WriteHeader(http.StatusNoContent)\n}\n\n// actorKeyID extracts the ID of the authenticated key making this request.\nfunc actorKeyID(r *http.Request) string {\n    if k, ok := r.Context().Value(\"api_key\").(*models.APIKey); ok {\n        return k.ID\n    }\n    return \"unknown\"\n}\n\n// writeJSON encodes v as JSON with the given status code.\nfunc writeJSON(w http.ResponseWriter, status int, v any) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(status)\n    json.NewEncoder(w).Encode(v)\n}\n\n// writeJSONError writes a standard error JSON response.\nfunc writeJSONError(w http.ResponseWriter, status int, msg string, code models.ErrorCode) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(status)\n    json.NewEncoder(w).Encode(models.NewErrorResponse(msg, code))\n}\n</code></pre> <p>Note: Check <code>internal/api/handlers.go</code> and other handler files \u2014 <code>writeJSON</code> and <code>writeJSONError</code> may already exist under different names. Use the existing helpers if present rather than redefining.</p> <p>Step 4: Register routes in <code>routes.go</code></p> <p>In the <code>config.Security.EnableAuth</code> branch, after the existing admin release-deletion block, add:</p> <pre><code>// API key management (admin permission required)\nkeyAdminAPI := api.PathPrefix(\"/admin/keys\").Subrouter()\nkeyAdminAPI.Use(authMiddleware(config.Security, handlers.storage))\nkeyAdminAPI.Use(RequirePermission(PermissionAdmin))\nkeyAdminAPI.HandleFunc(\"\", handlers.ListAPIKeys).Methods(\"GET\")\nkeyAdminAPI.HandleFunc(\"\", handlers.CreateAPIKey).Methods(\"POST\")\nkeyAdminAPI.HandleFunc(\"/{id}\", handlers.UpdateAPIKey).Methods(\"PATCH\")\nkeyAdminAPI.HandleFunc(\"/{id}\", handlers.DeleteAPIKey).Methods(\"DELETE\")\n</code></pre> <p>Also add the same routes in the <code>else</code> branch (auth disabled) for consistency: <pre><code>api.HandleFunc(\"/admin/keys\", handlers.ListAPIKeys).Methods(\"GET\")\napi.HandleFunc(\"/admin/keys\", handlers.CreateAPIKey).Methods(\"POST\")\napi.HandleFunc(\"/admin/keys/{id}\", handlers.UpdateAPIKey).Methods(\"PATCH\")\napi.HandleFunc(\"/admin/keys/{id}\", handlers.DeleteAPIKey).Methods(\"DELETE\")\n</code></pre></p> <p>Step 5: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 6: Commit</p> <pre><code>git add internal/api/handlers_keys.go internal/api/handlers_keys_test.go internal/api/routes.go\ngit commit -m \"feat(api): add REST handlers for API key management\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-13-admin-ui-key-management-pages","title":"Task 13: Admin UI \u2014 key management pages","text":"<p>Files: - Create: <code>internal/api/admin/templates/keys.html</code> - Modify: <code>internal/api/admin/templates/partials/</code> (nav partial to add Keys link) - Modify: <code>internal/api/handlers_admin.go</code> - Modify: <code>internal/api/routes.go</code></p> <p>Context: The admin UI uses HTMX + Go templates embedded with <code>go:embed</code>. Look at <code>applications.html</code> and <code>partials/</code> for the page structure and flash message pattern to follow. Create a keys list page with inline HTMX delete/toggle and a create form page.</p> <p>Step 1: Explore existing admin templates structure</p> <p>Run: <pre><code>find internal/api/admin -name \"*.html\" | head -20\n</code></pre></p> <p>Look at <code>internal/api/admin/templates/applications.html</code> for layout conventions, and <code>internal/api/admin/templates/partials/nav.html</code> (if it exists) for navigation.</p> <p>Step 2: Create <code>internal/api/admin/templates/keys.html</code></p> <p>Model after <code>applications.html</code>. The page shows a table with columns: Prefix, Name, Permissions, Status, Created, Actions. Each row has: - An HTMX delete button: <code>hx-delete=\"/admin/keys/{id}\" hx-confirm=\"Revoke this key?\" hx-target=\"closest tr\" hx-swap=\"outerHTML\"</code> - An HTMX enable/disable toggle: <code>hx-post=\"/admin/keys/{id}/toggle\"</code></p> <p>Includes a \"New Key\" link to <code>/admin/keys/new</code>.</p> <p>Step 3: Create <code>internal/api/admin/templates/keys_new.html</code></p> <p>A form with fields for Name and Permissions (checkboxes: read, write, admin). On successful creation, the server renders a <code>keys_created.html</code> partial that shows the raw key in a styled read-only input with a JS copy button and a prominent \"This key will not be shown again\" warning.</p> <p>Step 4: Add data structs and handlers to <code>handlers_admin.go</code></p> <p>Add data types: <pre><code>type adminKeysData struct {\n    adminBaseData\n    Keys []models.APIKey\n}\n\ntype adminNewKeyData struct {\n    adminBaseData\n    Error string\n    CreatedKey *createdKeyData\n}\n\ntype createdKeyData struct {\n    Name   string\n    Key    string // raw key \u2014 shown once\n    Prefix string\n}\n</code></pre></p> <p>Add handlers: <pre><code>func (h *Handlers) AdminListKeys(w http.ResponseWriter, r *http.Request)  { ... }\nfunc (h *Handlers) AdminNewKeyForm(w http.ResponseWriter, r *http.Request) { ... }\nfunc (h *Handlers) AdminCreateKey(w http.ResponseWriter, r *http.Request) { ... }\nfunc (h *Handlers) AdminDeleteKey(w http.ResponseWriter, r *http.Request) { ... }\nfunc (h *Handlers) AdminToggleKey(w http.ResponseWriter, r *http.Request) { ... }\n</code></pre></p> <p><code>AdminCreateKey</code> calls <code>models.GenerateAPIKey()</code>, then <code>storage.CreateAPIKey</code>, then re-renders the new-key form with <code>createdKeyData</code> populated.</p> <p><code>AdminDeleteKey</code> calls <code>storage.DeleteAPIKey</code> and returns either an empty 200 (for HTMX swap) or redirects.</p> <p><code>AdminToggleKey</code> reads the key from storage, flips <code>Enabled</code>, calls <code>UpdateAPIKey</code>, and returns an HTMX fragment.</p> <p>Step 5: Register routes in <code>routes.go</code></p> <p>Add to <code>adminRouter</code>: <pre><code>adminRouter.HandleFunc(\"/keys\", handlers.AdminListKeys).Methods(\"GET\")\nadminRouter.HandleFunc(\"/keys/new\", handlers.AdminNewKeyForm).Methods(\"GET\")\nadminRouter.HandleFunc(\"/keys\", handlers.AdminCreateKey).Methods(\"POST\")\nadminRouter.HandleFunc(\"/keys/{id}\", handlers.AdminDeleteKey).Methods(\"DELETE\")\nadminRouter.HandleFunc(\"/keys/{id}/toggle\", handlers.AdminToggleKey).Methods(\"POST\")\n</code></pre></p> <p>Step 6: Build and smoke test</p> <pre><code>make build\nmake run\n</code></pre> <p>Navigate to <code>http://localhost:8080/admin/keys</code> and verify the page loads.</p> <p>Step 7: Commit</p> <pre><code>git add internal/api/admin/ internal/api/handlers_admin.go internal/api/routes.go\ngit commit -m \"feat(admin): add API key management pages to admin UI\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-14-update-openapi-spec","title":"Task 14: Update OpenAPI spec","text":"<p>Files: - Modify: <code>internal/api/openapi/openapi.yaml</code></p> <p>Context: The OpenAPI spec is maintained manually. Add the four new endpoints and their schemas. Run <code>make openapi-validate</code> after editing to catch syntax errors. Follow the structure of existing endpoint entries in the file.</p> <p>Step 1: Add schemas</p> <p>In the <code>components.schemas</code> section, add:</p> <pre><code>APIKeyMeta:\n  type: object\n  properties:\n    id: { type: string, format: uuid }\n    name: { type: string }\n    prefix: { type: string }\n    permissions:\n      type: array\n      items: { type: string }\n    enabled: { type: boolean }\n    created_at: { type: string, format: date-time }\n    updated_at: { type: string, format: date-time }\n\nCreateAPIKeyRequest:\n  type: object\n  required: [name, permissions]\n  properties:\n    name: { type: string }\n    permissions:\n      type: array\n      items: { type: string }\n\nCreateAPIKeyResponse:\n  allOf:\n    - $ref: '#/components/schemas/APIKeyMeta'\n  properties:\n    key: { type: string, description: \"Raw key value \u2014 returned exactly once\" }\n\nUpdateAPIKeyRequest:\n  type: object\n  properties:\n    name: { type: string }\n    permissions:\n      type: array\n      items: { type: string }\n    enabled: { type: boolean }\n</code></pre> <p>Step 2: Add path entries</p> <p>Add under <code>paths</code>:</p> <pre><code>/api/v1/admin/keys:\n  get:\n    summary: List API keys\n    tags: [Admin]\n    security: [{ BearerAuth: [] }]\n    responses:\n      '200':\n        description: List of API key metadata\n        content:\n          application/json:\n            schema:\n              type: array\n              items: { $ref: '#/components/schemas/APIKeyMeta' }\n  post:\n    summary: Create an API key\n    tags: [Admin]\n    security: [{ BearerAuth: [] }]\n    requestBody:\n      required: true\n      content:\n        application/json:\n          schema: { $ref: '#/components/schemas/CreateAPIKeyRequest' }\n    responses:\n      '201':\n        description: Key created \u2014 raw key returned once\n        content:\n          application/json:\n            schema: { $ref: '#/components/schemas/CreateAPIKeyResponse' }\n\n/api/v1/admin/keys/{id}:\n  patch:\n    summary: Update an API key\n    tags: [Admin]\n    security: [{ BearerAuth: [] }]\n    parameters:\n      - in: path\n        name: id\n        required: true\n        schema: { type: string }\n    requestBody:\n      content:\n        application/json:\n          schema: { $ref: '#/components/schemas/UpdateAPIKeyRequest' }\n    responses:\n      '200':\n        description: Updated key metadata\n        content:\n          application/json:\n            schema: { $ref: '#/components/schemas/APIKeyMeta' }\n      '404':\n        description: Key not found\n  delete:\n    summary: Revoke an API key\n    tags: [Admin]\n    security: [{ BearerAuth: [] }]\n    parameters:\n      - in: path\n        name: id\n        required: true\n        schema: { type: string }\n    responses:\n      '204':\n        description: Key revoked\n      '404':\n        description: Key not found\n</code></pre> <p>Step 3: Validate</p> <pre><code>make openapi-validate\n</code></pre> <p>Expected: validation passes with no errors.</p> <p>Step 4: Commit</p> <pre><code>git add internal/api/openapi/openapi.yaml\ngit commit -m \"docs(openapi): document API key management endpoints\"\n</code></pre>"},{"location":"plans/2026-02-16-admin-key-management/#task-15-final-check","title":"Task 15: Final check","text":"<p>Step 1: Run full test suite</p> <pre><code>make check\n</code></pre> <p>Expected: fmt + vet + tests all pass.</p> <p>Step 2: Run integration tests</p> <pre><code>make integration-test\n</code></pre> <p>Expected: PASS.</p> <p>Step 3: Build docs</p> <pre><code>make docs-build\n</code></pre> <p>Expected: OpenAPI validation passes and docs site builds.</p> <p>Step 4: Commit if anything was adjusted</p> <pre><code>git add -A\ngit commit -m \"chore: final cleanup after key management implementation\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-design/","title":"GitHub CI Pipeline Design","text":"<p>Date: 2026-02-16</p>"},{"location":"plans/2026-02-16-github-ci-design/#overview","title":"Overview","text":"<p>A GitHub Actions CI pipeline that validates every push to <code>main</code> and every PR targeting <code>main</code>. All checks mirror the local development workflow via Docker, ensuring parity between local and CI environments.</p>"},{"location":"plans/2026-02-16-github-ci-design/#goals","title":"Goals","text":"<ul> <li>Run the full test suite on every PR and push to main</li> <li>Enforce formatting, vet, and OpenAPI spec validity</li> <li>Enforce a coverage ratchet: coverage must never decrease</li> <li>Run static security analysis (gosec) with threshold-based failure</li> <li>Surface security findings in the GitHub Security tab</li> </ul>"},{"location":"plans/2026-02-16-github-ci-design/#workflow-structure","title":"Workflow Structure","text":"<p>Two parallel jobs in <code>.github/workflows/ci.yml</code>:</p> <pre><code>graph LR\n    trigger[Push / PR] --&gt; ci[ci job]\n    trigger --&gt; security[security job]\n    ci --&gt; done[Done]\n    security --&gt; done</code></pre> <p>Triggers: - <code>push</code> to <code>main</code> - <code>pull_request</code> targeting <code>main</code></p>"},{"location":"plans/2026-02-16-github-ci-design/#job-ci","title":"Job: ci","text":"<p>Runs on <code>ubuntu-latest</code> using Docker-in-Docker (all Make targets run inside Docker).</p> Step Command Fails on Format check <code>make fmt-check</code> Any unformatted file Vet <code>make vet</code> Any vet error Test <code>make test</code> Any test failure Coverage <code>make cover</code> + threshold check Coverage below <code>.github/coverage-threshold</code> OpenAPI validate <code>make openapi-validate</code> Invalid OpenAPI spec"},{"location":"plans/2026-02-16-github-ci-design/#job-security","title":"Job: security","text":"<p>Runs on <code>ubuntu-latest</code> with native Go 1.25.0 (no Docker needed for gosec).</p> <p>Requires <code>permissions: security-events: write</code> for SARIF upload.</p> Step Detail Install gosec <code>go install github.com/securego/gosec/v2/cmd/gosec@latest</code> Generate SARIF <code>gosec -no-fail -fmt sarif -out gosec.sarif ./...</code> Upload to Security tab <code>github/codeql-action/upload-sarif</code> with <code>gosec.sarif</code> Enforce threshold <code>gosec -severity high -confidence medium ./...</code> \u2014 fails on High severity + Medium or High confidence findings <p>SARIF is always uploaded (even when findings exist) so developers can inspect findings in the GitHub Security tab regardless of build outcome.</p>"},{"location":"plans/2026-02-16-github-ci-design/#coverage-ratchet","title":"Coverage Ratchet","text":"<p>Coverage is enforced via a committed threshold file:</p> <ul> <li>File: <code>.github/coverage-threshold</code> \u2014 contains a single float, e.g. <code>78.4</code></li> <li>CI: reads the file, parses coverage from <code>make cover</code> output, fails if current &lt; threshold</li> <li>Developer workflow: update the file in the PR when coverage increases \u2014 the diff makes improvements explicit and reviewable</li> <li>Initial value: set to the current coverage percentage on first run</li> </ul>"},{"location":"plans/2026-02-16-github-ci-design/#new-make-targets","title":"New Make Targets","text":"<p>Three new targets added to support CI and local parity:</p>"},{"location":"plans/2026-02-16-github-ci-design/#make-fmt-check","title":"<code>make fmt-check</code>","text":"<p>Checks formatting without modifying files. Uses <code>gofmt -l</code> and fails if any files need formatting.</p> <pre><code>fmt-check: ## Check formatting (non-destructive)\n    docker run --rm -v $(PWD):/app -w /app golang:1.25 \\\n        sh -c 'test -z \"$(gofmt -l .)\"'\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-design/#make-cover","title":"<code>make cover</code>","text":"<p>Runs tests with coverage and prints a parseable total line.</p> <pre><code>cover: ## Run tests with coverage report\n    docker run --rm -v $(PWD):/app -w /app golang:1.25 \\\n        go test -coverprofile=coverage.out ./... &amp;&amp; \\\n        go tool cover -func=coverage.out | grep ^total\n</code></pre> <p>Outputs: <code>total: (statements)  78.4%</code></p>"},{"location":"plans/2026-02-16-github-ci-design/#make-security","title":"<code>make security</code>","text":"<p>Runs gosec locally using the official Docker image, matching CI threshold.</p> <pre><code>security: ## Run gosec security scanner\n    docker run --rm \\\n        -v $(PWD):/app \\\n        -w /app \\\n        securego/gosec:latest \\\n        -severity high -confidence medium ./...\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-design/#security-scan-thresholds","title":"Security Scan Thresholds","text":"Dimension Threshold Severity High only Confidence Medium and above <p>Findings below threshold appear in the GitHub Security tab but do not fail the build. Specific false positives can be suppressed inline with <code>// #nosec G###</code> comments.</p>"},{"location":"plans/2026-02-16-github-ci-design/#files-created-or-modified","title":"Files Created or Modified","text":"File Change <code>.github/workflows/ci.yml</code> New \u2014 GitHub Actions workflow <code>.github/coverage-threshold</code> New \u2014 coverage ratchet baseline <code>make/go.mk</code> Modified \u2014 add <code>fmt-check</code>, <code>cover</code>, <code>security</code> targets <code>mkdocs.yml</code> Modified \u2014 add CI design doc to Plans nav"},{"location":"plans/2026-02-16-github-ci-implementation/","title":"GitHub CI Pipeline Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add GitHub Actions CI with format check, vet, test, coverage ratchet, OpenAPI validation, and gosec security scanning.</p> <p>Architecture: Two parallel GitHub Actions jobs \u2014 <code>ci</code> (Docker-in-Docker, runs existing Make targets) and <code>security</code> (native Go, runs gosec). Coverage is enforced via a committed threshold file <code>.github/coverage-threshold</code>. Three new Make targets (<code>fmt-check</code>, <code>cover</code>, <code>security</code>) mirror CI behaviour locally.</p> <p>Tech Stack: GitHub Actions, Docker-in-Docker, gosec (<code>securego/gosec</code>), <code>github/codeql-action</code> for SARIF upload, existing <code>golang:1.25-alpine</code> Docker image.</p>"},{"location":"plans/2026-02-16-github-ci-implementation/#context","title":"Context","text":"<p>Root Makefile (<code>Makefile</code>) defines the <code>GO_DOCKER</code> variable used by all Go Make targets:</p> <pre><code>GO_IMAGE   := golang:1.25-alpine\nGO_MOD_CACHE   := $(APP_NAME)-go-mod-cache\nGO_BUILD_CACHE := $(APP_NAME)-go-build-cache\nGO_DOCKER  := docker run --rm \\\n    -v \"$(CURDIR):/app\" \\\n    -v \"$(GO_MOD_CACHE):/go/pkg/mod\" \\\n    -v \"$(GO_BUILD_CACHE):/root/.cache/go-build\" \\\n    -w /app \\\n    -e CGO_ENABLED=0 \\\n    $(GO_IMAGE)\n</code></pre> <p>Go targets live in <code>make/go.mk</code>. The <code>$(GO_DOCKER)</code> variable is available to all targets in <code>make/*.mk</code> via the root Makefile includes.</p> <p>Key constraint: No CGO. <code>CGO_ENABLED=0</code> is already set in <code>GO_DOCKER</code>.</p>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-1-add-fmt-check-make-target","title":"Task 1: Add <code>fmt-check</code> Make target","text":"<p>Files: - Modify: <code>make/go.mk</code></p> <p>Step 1: Add the target</p> <p>Open <code>make/go.mk</code>. After the <code>fmt</code> target, add:</p> <pre><code>fmt-check: ## Check formatting without modifying files\n    $(GO_DOCKER) sh -c 'unformatted=$$(gofmt -l .); [ -z \"$$unformatted\" ] || (printf \"Unformatted files:\\n$$unformatted\\n\" &amp;&amp; exit 1)'\n</code></pre> <p>Note the Makefile quoting rules: <code>$$</code> escapes <code>$</code> in Make, producing a single <code>$</code> in the shell. The <code>sh -c</code> wrapper is needed because <code>gofmt -l</code> is a shell pipeline.</p> <p>Also add <code>fmt-check</code> to the <code>.PHONY</code> line at the top of <code>make/go.mk</code>.</p> <p>Step 2: Verify it passes on well-formatted code</p> <p>Run: <pre><code>make fmt-check\n</code></pre></p> <p>Expected: exits 0 with no output (all files are already formatted).</p> <p>Step 3: Verify it fails on unformatted code</p> <p>Temporarily add a blank line in the wrong place in any <code>.go</code> file (e.g., add two blank lines where one is expected), then run:</p> <pre><code>make fmt-check\n</code></pre> <p>Expected: output like: <pre><code>Unformatted files:\ninternal/api/handler.go\nmake: *** [fmt-check] Error 1\n</code></pre></p> <p>Revert the temporary change.</p> <p>Step 4: Commit</p> <pre><code>git add make/go.mk\ngit commit -m \"feat(make): add fmt-check target\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-2-add-cover-make-target","title":"Task 2: Add <code>cover</code> Make target","text":"<p>Files: - Modify: <code>make/go.mk</code></p> <p>Step 1: Add the target</p> <p>In <code>make/go.mk</code>, after the <code>test</code> target, add:</p> <pre><code>cover: ## Run tests with coverage report\n    $(GO_DOCKER) sh -c 'go test -coverprofile=coverage.out ./... &amp;&amp; go tool cover -func=coverage.out | grep ^total'\n</code></pre> <p>Add <code>cover</code> to the <code>.PHONY</code> line.</p> <p>Step 2: Run it and capture the output</p> <pre><code>make cover\n</code></pre> <p>Expected output ends with a line like: <pre><code>total:          (statements)    82.3%\n</code></pre></p> <p>(The exact percentage will vary. Note it down \u2014 you will need it in Task 3.)</p> <p>Step 3: Verify the output is parseable</p> <p>Run: <pre><code>make cover | awk '/^total/ {gsub(/%/, \"\", $3); print $3}'\n</code></pre></p> <p>Expected: a bare float, e.g. <code>82.3</code>. This is the shell expression CI will use.</p> <p>Step 4: Add <code>coverage.out</code> to <code>.gitignore</code></p> <p>The coverage profile file should not be committed. Add it:</p> <pre><code>echo \"coverage.out\" &gt;&gt; .gitignore\n</code></pre> <p>Verify: <pre><code>git status\n</code></pre></p> <p>Expected: <code>coverage.out</code> not shown as untracked (or not present yet \u2014 either is fine).</p> <p>Step 5: Commit</p> <pre><code>git add make/go.mk .gitignore\ngit commit -m \"feat(make): add cover target\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-3-set-the-initial-coverage-threshold","title":"Task 3: Set the initial coverage threshold","text":"<p>Files: - Create: <code>.github/coverage-threshold</code></p> <p>Step 1: Run cover and get the percentage</p> <pre><code>make cover | awk '/^total/ {gsub(/%/, \"\", $3); print $3}'\n</code></pre> <p>Note the output, e.g. <code>82.3</code>.</p> <p>Step 2: Write the threshold file</p> <p>Create <code>.github/coverage-threshold</code> with exactly the percentage value on a single line, no trailing newline:</p> <pre><code>82.3\n</code></pre> <p>(Replace <code>82.3</code> with the actual value from Step 1.)</p> <p>Step 3: Commit</p> <pre><code>git add .github/coverage-threshold\ngit commit -m \"ci: set initial coverage threshold\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-4-add-security-make-target","title":"Task 4: Add <code>security</code> Make target","text":"<p>Files: - Modify: <code>make/go.mk</code></p> <p>Step 1: Add the target</p> <p>In <code>make/go.mk</code>, at the end, add:</p> <pre><code>security: ## Run gosec security scanner\n    docker run --rm \\\n        -v \"$(CURDIR):/app\" \\\n        -w /app \\\n        securego/gosec:latest \\\n        -severity high -confidence medium ./...\n</code></pre> <p>Note: this target uses its own <code>docker run</code> directly (not <code>$(GO_DOCKER)</code>) because it uses a different image (<code>securego/gosec:latest</code> instead of <code>golang:1.25-alpine</code>).</p> <p>Add <code>security</code> to the <code>.PHONY</code> line.</p> <p>Step 2: Run it</p> <pre><code>make security\n</code></pre> <p>Expected: either exits 0 with no findings, or prints any High severity + Medium/High confidence findings. If findings are printed, investigate each one \u2014 they may be legitimate issues to fix or false positives to suppress with <code>// #nosec G###</code>.</p> <p>If any findings are legitimate, fix them now before continuing.</p> <p>Step 3: Commit</p> <pre><code>git add make/go.mk\ngit commit -m \"feat(make): add security target\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-5-create-the-github-actions-workflow","title":"Task 5: Create the GitHub Actions workflow","text":"<p>Files: - Create: <code>.github/workflows/ci.yml</code></p> <p>Step 1: Create the workflows directory</p> <pre><code>mkdir -p .github/workflows\n</code></pre> <p>Step 2: Write the workflow file</p> <p>Create <code>.github/workflows/ci.yml</code>:</p> <pre><code>name: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Check formatting\n        run: make fmt-check\n\n      - name: Vet\n        run: make vet\n\n      - name: Test\n        run: make test\n\n      - name: Coverage\n        run: |\n          COVERAGE=$(make cover | awk '/^total/ {gsub(/%/, \"\", $3); print $3}')\n          THRESHOLD=$(cat .github/coverage-threshold)\n          echo \"Coverage:  ${COVERAGE}%\"\n          echo \"Threshold: ${THRESHOLD}%\"\n          awk \"BEGIN {\n            if (${COVERAGE} + 0 &lt; ${THRESHOLD} + 0) {\n              print \\\"FAIL: coverage \\\" ${COVERAGE} \\\"% is below threshold \\\" ${THRESHOLD} \\\"%\\\"\n              exit 1\n            }\n            print \\\"PASS: coverage \\\" ${COVERAGE} \\\"% meets threshold \\\" ${THRESHOLD} \\\"%\\\"\n          }\"\n\n      - name: Validate OpenAPI spec\n        run: make openapi-validate\n\n  security:\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-go@v5\n        with:\n          go-version: '1.25.0'\n\n      - name: Install gosec\n        run: go install github.com/securego/gosec/v2/cmd/gosec@latest\n\n      - name: Generate SARIF report\n        run: gosec -no-fail -fmt sarif -out gosec.sarif ./...\n\n      - name: Upload to GitHub Security tab\n        uses: github/codeql-action/upload-sarif@v3\n        with:\n          sarif_file: gosec.sarif\n\n      - name: Enforce security threshold\n        run: gosec -severity high -confidence medium ./...\n</code></pre> <p>Step 3: Commit</p> <pre><code>git add .github/workflows/ci.yml\ngit commit -m \"ci: add GitHub Actions CI workflow\"\n</code></pre>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-6-validate-ci-passes","title":"Task 6: Validate CI passes","text":"<p>Step 1: Push to a branch and open a PR</p> <pre><code>git checkout -b ci/setup\ngit push -u origin ci/setup\n</code></pre> <p>Then open a PR targeting <code>main</code> on GitHub.</p> <p>Step 2: Watch the Actions tab</p> <p>Navigate to the PR on GitHub \u2192 Actions tab. Both <code>ci</code> and <code>security</code> jobs should appear running in parallel.</p> <p>Expected outcome for each job:</p> <p><code>ci</code> job: - <code>Check formatting</code> \u2014 green - <code>Vet</code> \u2014 green - <code>Test</code> \u2014 green - <code>Coverage</code> \u2014 green, prints <code>PASS: coverage X% meets threshold Y%</code> - <code>Validate OpenAPI spec</code> \u2014 green</p> <p><code>security</code> job: - <code>Install gosec</code> \u2014 green - <code>Generate SARIF report</code> \u2014 green (always succeeds due to <code>-no-fail</code>) - <code>Upload to GitHub Security tab</code> \u2014 green - <code>Enforce security threshold</code> \u2014 green (no High + Medium/High findings)</p> <p>Step 3: If any job fails, investigate</p> <p>Common failure modes:</p> Failure Fix <code>fmt-check</code> fails Run <code>make fmt</code> locally, commit the result <code>Cover</code> fails with parse error Check <code>make cover</code> output manually; ensure the <code>total:</code> line is present <code>Coverage</code> below threshold Either increase test coverage or lower the threshold if the initial value was wrong <code>gosec</code> threshold fails Fix the finding or suppress with <code>// #nosec G###</code> if it is a false positive <code>openapi-validate</code> fails Fix the OpenAPI spec at <code>internal/api/openapi/openapi.yaml</code> <p>Step 4: Merge the PR</p> <p>Once all checks are green, merge via GitHub UI.</p>"},{"location":"plans/2026-02-16-github-ci-implementation/#task-7-update-documentation","title":"Task 7: Update documentation","text":"<p>Files: - Modify: <code>docs/plans/2026-02-16-github-ci-implementation.md</code> \u2014 already exists (this file)</p> <p>No additional documentation is needed beyond the design doc (<code>docs/plans/2026-02-16-github-ci-design.md</code>) already committed. The Make targets are self-documenting via <code>## comments</code> visible in <code>make help</code>.</p>"},{"location":"plans/2026-02-16-github-pages-design/","title":"GitHub Pages with Versioned Docs \u2014 Design","text":"<p>Date: 2026-02-16 Status: Approved</p>"},{"location":"plans/2026-02-16-github-pages-design/#overview","title":"Overview","text":"<p>Publish the MkDocs documentation site to GitHub Pages with versioned docs managed by <code>mike</code>. Development docs are published on every push to <code>main</code> under the <code>dev</code> label. Tagged releases publish under their version number (e.g., <code>v1.2.0</code>) and update a <code>latest</code> alias that serves as the site default.</p>"},{"location":"plans/2026-02-16-github-pages-design/#goals","title":"Goals","text":"<ul> <li>Visitors landing on the docs site without a version in the URL see the latest stable release.</li> <li>The <code>dev</code> label always reflects the current state of <code>main</code>.</li> <li>Each <code>v*</code> tag produces a permanent, browsable version of the docs.</li> <li>No local tooling required beyond what already exists; deployment runs entirely in CI.</li> </ul>"},{"location":"plans/2026-02-16-github-pages-design/#approach","title":"Approach","text":"<p><code>mike</code> manages multiple doc versions on a single <code>gh-pages</code> branch. MkDocs Material has native support for <code>mike</code> via its version picker UI. This is the standard, supported approach for versioned MkDocs sites.</p>"},{"location":"plans/2026-02-16-github-pages-design/#components","title":"Components","text":""},{"location":"plans/2026-02-16-github-pages-design/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>New file: <code>.github/workflows/docs.yml</code></p> <p>Triggers:</p> Event Condition Action <code>push</code> branch <code>main</code> Deploy as <code>dev</code> <code>push</code> tag matching <code>v*</code> Deploy as version + update <code>latest</code> alias <p>Permissions: <code>contents: write</code> (to push to <code>gh-pages</code> branch).</p> <p>Steps:</p> <ol> <li><code>actions/checkout@v4</code> with <code>fetch-depth: 0</code> \u2014 mike requires full git history to manage <code>gh-pages</code>.</li> <li><code>actions/setup-python@v5</code></li> <li><code>pip install mkdocs-material mike</code></li> <li>Configure git user identity for the commit mike makes to <code>gh-pages</code>.</li> <li>On <code>main</code> push: <code>mike deploy --push --update-aliases dev</code></li> <li>On <code>v*</code> tag push: <code>mike deploy --push --update-aliases $VERSION latest</code> then <code>mike set-default --push latest</code></li> </ol>"},{"location":"plans/2026-02-16-github-pages-design/#mkdocs-configuration","title":"MkDocs Configuration","text":"<p>One change to <code>mkdocs.yml</code>:</p> <ul> <li>Set <code>site_url</code> to <code>https://griffinskudder.github.io/updater/</code>. The field is currently empty, which breaks mike's URL resolution when switching between versions.</li> </ul> <p><code>extra.version.provider: mike</code> and <code>extra.version.default: latest</code> are already present \u2014 no further changes needed.</p>"},{"location":"plans/2026-02-16-github-pages-design/#github-pages-repository-setting","title":"GitHub Pages Repository Setting","text":"<p>One-time manual configuration: set Pages source to the <code>gh-pages</code> branch, root <code>/</code>, in Settings \u2192 Pages \u2192 Source. Mike creates and manages the <code>gh-pages</code> branch automatically on first deploy.</p>"},{"location":"plans/2026-02-16-github-pages-design/#data-flow","title":"Data Flow","text":"<pre><code>flowchart TD\n    A[Push to main] --&gt;|trigger| W[docs.yml workflow]\n    B[Push v* tag] --&gt;|trigger| W\n    W --&gt; C{Which trigger?}\n    C --&gt;|main| D[\"mike deploy dev --push\"]\n    C --&gt;|tag| E[\"mike deploy vX.Y.Z latest --push\"]\n    E --&gt; F[\"mike set-default latest --push\"]\n    D --&gt; G[gh-pages branch]\n    F --&gt; G\n    G --&gt; H[GitHub Pages]\n    H --&gt; I[https://griffinskudder.github.io/updater/]</code></pre>"},{"location":"plans/2026-02-16-github-pages-design/#versioning-scheme","title":"Versioning Scheme","text":"Label Source Default? <code>dev</code> <code>main</code> branch No <code>vX.Y.Z</code> <code>vX.Y.Z</code> tag No <code>latest</code> Alias \u2192 most recent <code>vX.Y.Z</code> Yes"},{"location":"plans/2026-02-16-github-pages-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Version retention policy (all versions are kept indefinitely).</li> <li>Custom domain configuration.</li> <li>PR preview deployments.</li> </ul>"},{"location":"plans/2026-02-16-github-pages-implementation/","title":"GitHub Pages with Versioned Docs \u2014 Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Publish the MkDocs site to GitHub Pages with versioned docs managed by <code>mike</code> \u2014 <code>dev</code> on every push to <code>main</code>, tagged releases as version numbers, with the latest stable release as the default landing page.</p> <p>Architecture: A new <code>.github/workflows/docs.yml</code> workflow triggers on pushes to <code>main</code> and <code>v*</code> tags. It installs <code>mkdocs-material</code> and <code>mike</code> via pip, then uses <code>mike deploy</code> to publish to the <code>gh-pages</code> branch. MkDocs Material's native version picker reads the <code>mike</code>-managed version list from <code>gh-pages</code>.</p> <p>Tech Stack: <code>mike</code> (MkDocs versioning), <code>mkdocs-material</code>, GitHub Actions, GitHub Pages (serving from <code>gh-pages</code> branch).</p>"},{"location":"plans/2026-02-16-github-pages-implementation/#task-1-set-site_url-in-mkdocsyml","title":"Task 1: Set <code>site_url</code> in <code>mkdocs.yml</code>","text":"<p>Files: - Modify: <code>mkdocs.yml:4</code></p> <p><code>mike</code> requires <code>site_url</code> to resolve cross-version URLs correctly. It is currently empty.</p> <p>Step 1: Update <code>site_url</code></p> <p>In <code>mkdocs.yml</code>, change line 4 from:</p> <pre><code>site_url: \"\"\n</code></pre> <p>to:</p> <pre><code>site_url: https://griffinskudder.github.io/updater/\n</code></pre> <p>Step 2: Verify the docs build</p> <pre><code>make docs-build\n</code></pre> <p>Expected: build completes without errors. The <code>site/</code> directory is populated.</p> <p>Step 3: Commit</p> <pre><code>git add mkdocs.yml\ngit commit -m \"chore(docs): set site_url for GitHub Pages\"\n</code></pre>"},{"location":"plans/2026-02-16-github-pages-implementation/#task-2-create-the-github-actions-docs-workflow","title":"Task 2: Create the GitHub Actions docs workflow","text":"<p>Files: - Create: <code>.github/workflows/docs.yml</code></p> <p>Step 1: Create the workflow file</p> <p>Create <code>.github/workflows/docs.yml</code> with the following content:</p> <pre><code>name: Docs\n\non:\n  push:\n    branches: [main]\n  push:\n    tags: ['v*']\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: pip install mkdocs-material mike\n\n      - name: Configure git credentials\n        run: |\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n\n      - name: Deploy dev docs\n        if: github.ref == 'refs/heads/main'\n        run: mike deploy --push --update-aliases dev\n\n      - name: Deploy versioned docs\n        if: startsWith(github.ref, 'refs/tags/v')\n        run: |\n          VERSION=${GITHUB_REF#refs/tags/}\n          mike deploy --push --update-aliases \"$VERSION\" latest\n          mike set-default --push latest\n</code></pre> <p>Note: <code>fetch-depth: 0</code> is required \u2014 <code>mike</code> reads and writes the <code>gh-pages</code> branch, which needs the full git history to avoid overwriting previous versions.</p> <p><code>--update-aliases</code> ensures the <code>latest</code> alias always points to the version being deployed, replacing any previous pointer.</p> <p>Step 2: Commit</p> <pre><code>git add .github/workflows/docs.yml\ngit commit -m \"ci: add GitHub Pages docs deployment workflow\"\n</code></pre>"},{"location":"plans/2026-02-16-github-pages-implementation/#task-3-add-implementation-plan-to-docs-nav-and-commit","title":"Task 3: Add implementation plan to docs nav and commit","text":"<p>Files: - Modify: <code>mkdocs.yml</code></p> <p>Step 1: Add implementation plan to nav</p> <p>In <code>mkdocs.yml</code>, find the <code>Plans:</code> section in <code>nav</code> and add:</p> <pre><code>    - GitHub Pages Implementation: plans/2026-02-16-github-pages-implementation.md\n</code></pre> <p>after the existing <code>GitHub Pages Design</code> entry.</p> <p>Step 2: Verify the docs build</p> <pre><code>make docs-build\n</code></pre> <p>Expected: build completes without errors.</p> <p>Step 3: Commit</p> <pre><code>git add mkdocs.yml docs/plans/2026-02-16-github-pages-implementation.md\ngit commit -m \"docs: add GitHub Pages implementation plan\"\n</code></pre>"},{"location":"plans/2026-02-16-github-pages-implementation/#task-4-configure-github-pages-in-repository-settings-manual","title":"Task 4: Configure GitHub Pages in repository settings (manual)","text":"<p>This is a one-time action in the GitHub web UI. <code>mike</code> creates and manages the <code>gh-pages</code> branch automatically on first deploy, but GitHub Pages won't serve it until you point the setting at it.</p> <p>Step 1: Push changes to <code>main</code></p> <pre><code>git push\n</code></pre> <p>This triggers the workflow and creates the <code>gh-pages</code> branch with the <code>dev</code> docs.</p> <p>Step 2: Wait for the workflow to complete</p> <p>In the GitHub Actions tab, confirm the <code>Docs</code> workflow run succeeds and the <code>gh-pages</code> branch now exists.</p> <p>Step 3: Configure GitHub Pages source</p> <p>Go to the repository on GitHub: Settings \u2192 Pages \u2192 Build and deployment \u2192 Source.</p> <p>Set: - Source: <code>Deploy from a branch</code> - Branch: <code>gh-pages</code> - Folder: <code>/ (root)</code></p> <p>Save. GitHub Pages will begin serving from <code>https://griffinskudder.github.io/updater/</code>.</p> <p>Step 4: Verify</p> <p>Visit <code>https://griffinskudder.github.io/updater/</code>. The site should load and show the <code>dev</code> docs (there are no tagged releases yet, so <code>latest</code> does not exist; the <code>dev</code> docs will be visible directly).</p> <p>Once a <code>v*</code> tag is pushed, the <code>latest</code> alias will be created and the default will switch to the tagged version.</p>"},{"location":"plans/2026-02-16-issue-fixes-design/","title":"Issue Fixes Design","text":"<p>Date: 2026-02-16 Scope: All 9 open GitHub issues (#1-#9) Approach: Three focused PRs delivered in priority order: security first, behavioural bugs second, CI quality third.</p>"},{"location":"plans/2026-02-16-issue-fixes-design/#overview","title":"Overview","text":"<p>Nine confirmed issues were filed against the codebase covering security bugs, behavioural bugs, a performance problem, and CI gaps. This document records the agreed design for fixing all nine in three sequential pull requests.</p> <pre><code>graph LR\n    A[\"PR 1: fix/security&lt;br/&gt;Issues #1 #2 #3\"] --&gt; B[\"PR 2: fix/bugs&lt;br/&gt;Issues #4 #5 #6 #8\"]\n    B --&gt; C[\"PR 3: feat/ci-quality&lt;br/&gt;Issues #7 #9\"]</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-design/#pr-1-fixsecurity-closes-1-2-3","title":"PR 1 \u2014 <code>fix/security</code> (closes #1, #2, #3)","text":""},{"location":"plans/2026-02-16-issue-fixes-design/#problem-summary","title":"Problem summary","text":"Issue Location Problem #1 <code>internal/storage/json.go:66,135</code> Directory created with <code>0644</code> (non-traversable); data file world-readable #2 <code>internal/api/handlers_admin.go:146-163</code> Login cookie missing <code>Secure: true</code>; logout cookie attributes inconsistent #3 <code>internal/api/handlers_admin.go:120</code> Flash redirect URL built by string concatenation without URL-encoding"},{"location":"plans/2026-02-16-issue-fixes-design/#changes","title":"Changes","text":"<p><code>internal/storage/json.go</code></p> <ul> <li>Line 66: <code>os.MkdirAll(..., 0644)</code> \u2192 <code>os.MkdirAll(..., 0700)</code></li> <li><code>0700</code> = owner read/write/execute; no access for group or world.</li> <li>Without the execute bit the directory cannot be entered by anyone, making the storage provider non-functional on a fresh deployment.</li> <li>Line 135: <code>os.WriteFile(..., 0644)</code> \u2192 <code>os.WriteFile(..., 0600)</code></li> <li><code>0600</code> = owner read/write only; data file is not world-readable on multi-user systems.</li> </ul> <p><code>internal/api/handlers_admin.go</code></p> <p>Login cookie (lines 146-152) \u2014 add <code>Secure: true</code>: <pre><code>http.SetCookie(w, &amp;http.Cookie{\n    Name:     \"admin_session\",\n    Value:    key,\n    Path:     \"/admin\",\n    HttpOnly: true,\n    Secure:   true,\n    SameSite: http.SameSiteStrictMode,\n})\n</code></pre></p> <p>Logout cookie (lines 158-163) \u2014 match all attributes so browsers recognise it as the same cookie: <pre><code>http.SetCookie(w, &amp;http.Cookie{\n    Name:     \"admin_session\",\n    Value:    \"\",\n    Path:     \"/admin\",\n    MaxAge:   -1,\n    HttpOnly: true,\n    Secure:   true,\n    SameSite: http.SameSiteStrictMode,\n})\n</code></pre></p> <p><code>addFlash</code> (line 115-121) \u2014 replace string concatenation with <code>url.Values</code>: <pre><code>func addFlash(base, msg, flashType string) string {\n    u, err := url.Parse(base)\n    if err != nil {\n        return base\n    }\n    q := u.Query()\n    q.Set(\"flash\", msg)\n    q.Set(\"flash_type\", flashType)\n    u.RawQuery = q.Encode()\n    return u.String()\n}\n</code></pre></p> <p>Add <code>\"net/url\"</code> to the import block.</p>"},{"location":"plans/2026-02-16-issue-fixes-design/#tests","title":"Tests","text":"<ul> <li><code>TestAddFlash_EncodesSpecialCharacters</code>: verify <code>&amp;</code>, <code>=</code>, and <code>#</code> in message are percent-encoded and do not inject extra query parameters.</li> <li><code>TestAdminLogin_Cookie</code>: assert response sets cookie with <code>Secure=true</code>, <code>HttpOnly</code>, <code>SameSite=Strict</code>.</li> <li><code>TestAdminLogout_Cookie</code>: assert logout cookie has identical <code>Path</code>, <code>HttpOnly</code>, <code>Secure</code>, <code>SameSite</code> to the login cookie.</li> </ul>"},{"location":"plans/2026-02-16-issue-fixes-design/#pr-2-fixbugs-closes-4-5-6-8","title":"PR 2 \u2014 <code>fix/bugs</code> (closes #4, #5, #6, #8)","text":""},{"location":"plans/2026-02-16-issue-fixes-design/#problem-summary_1","title":"Problem summary","text":"Issue Location Problem #4 <code>Dockerfile:7</code> Build image <code>golang:1.26-alpine</code> does not match <code>go.mod</code> which declares <code>go 1.25.0</code> #5 <code>Dockerfile:60</code> Static-binary check exits 0 on failure (<code>\\|\\| echo</code>) instead of failing the build #6 <code>internal/storage/json.go:83-124</code> TOCTOU race: cache checked under <code>RLock</code>, released, then <code>os.Stat</code> runs unprotected before <code>WLock</code> is acquired #8 <code>.github/workflows/ci.yml</code> Tests run without <code>-race</code>; concurrent components (storage, rate limiter) have undetected races"},{"location":"plans/2026-02-16-issue-fixes-design/#changes_1","title":"Changes","text":"<p><code>Dockerfile</code></p> <p>Line 7: <pre><code>FROM golang:1.25-alpine AS builder\n</code></pre></p> <p>Line 60: <pre><code>ldd updater 2&gt;&amp;1 | grep -q \"not a dynamic executable\" || \\\n  (echo \"FAILED: binary is not statically linked\" &amp;&amp; exit 1)\n</code></pre></p> <p><code>internal/storage/json.go</code> \u2014 <code>loadData()</code> TOCTOU fix</p> <p>Consolidate all shared-state access under a single write lock. The double-checked locking pattern re-validates cache state immediately after acquiring the write lock, eliminating the race window:</p> <pre><code>func (j *JSONStorage) loadData() error {\n    // Fast path: cache valid (read lock).\n    j.mu.RLock()\n    if j.data != nil &amp;&amp; time.Now().Before(j.cacheExpiry) {\n        j.mu.RUnlock()\n        return nil\n    }\n    j.mu.RUnlock()\n\n    // Slow path: acquire write lock and re-check.\n    j.mu.Lock()\n    defer j.mu.Unlock()\n\n    // Re-validate: another goroutine may have loaded while we waited.\n    if j.data != nil &amp;&amp; time.Now().Before(j.cacheExpiry) {\n        return nil\n    }\n\n    // All shared-state reads and writes from here are under the write lock.\n    info, err := os.Stat(j.filePath)\n    if err != nil {\n        return fmt.Errorf(\"failed to stat file: %w\", err)\n    }\n\n    if j.data != nil &amp;&amp; !info.ModTime().After(j.lastModified) {\n        j.cacheExpiry = time.Now().Add(j.cacheTTL)\n        return nil\n    }\n\n    fileData, err := os.ReadFile(j.filePath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read file: %w\", err)\n    }\n\n    var data JSONData\n    if err := json.Unmarshal(fileData, &amp;data); err != nil {\n        return fmt.Errorf(\"failed to unmarshal JSON: %w\", err)\n    }\n\n    j.data = &amp;data\n    j.lastModified = info.ModTime()\n    j.cacheExpiry = time.Now().Add(j.cacheTTL)\n    return nil\n}\n</code></pre> <p><code>.github/workflows/ci.yml</code></p> <p>Add a race-detection step in the <code>ci</code> job, after the coverage step: <pre><code>- name: Race detector\n  run: go test -race ./...\n</code></pre></p> <p>This is kept separate from the coverage step to avoid interfering with the coverage threshold calculation.</p>"},{"location":"plans/2026-02-16-issue-fixes-design/#tests_1","title":"Tests","text":"<ul> <li><code>TestLoadData_ConcurrentAccess</code> in <code>internal/storage/json_test.go</code>: launch 20 goroutines all calling <code>loadData</code> on the same <code>JSONStorage</code> instance concurrently. Assert that no goroutine returns an error and that <code>j.data</code> is non-nil afterward. This test is designed to be run with <code>-race</code> to catch the original data race.</li> </ul>"},{"location":"plans/2026-02-16-issue-fixes-design/#pr-3-featci-quality-closes-7-9","title":"PR 3 \u2014 <code>feat/ci-quality</code> (closes #7, #9)","text":""},{"location":"plans/2026-02-16-issue-fixes-design/#problem-summary_2","title":"Problem summary","text":"Issue Location Problem #7 <code>internal/update/service.go:350-357</code> Manual O(n\u00b2) bubble sort where <code>sort.Slice</code> (O(n log n)) would be simpler and faster #9 <code>.github/workflows/ci.yml</code> <code>internal/integration/integration_test.go</code> exists but is never run in CI"},{"location":"plans/2026-02-16-issue-fixes-design/#changes_2","title":"Changes","text":"<p><code>internal/update/service.go</code> \u2014 <code>sortReleases</code></p> <p>Replace the nested bubble-sort loops with a single stdlib call. The <code>less</code> closure and the <code>sortOrder</code> reversal logic above it are unchanged:</p> <pre><code>sort.Slice(releases, less)\n</code></pre> <p>The <code>\"sort\"</code> package is already imported in the file.</p> <p><code>.github/workflows/ci.yml</code></p> <p>Add an integration test step in the <code>ci</code> job, after the race detector step: <pre><code>- name: Integration tests\n  run: go test -v ./internal/integration/...\n</code></pre></p> <p>No build tags are required. The integration tests use <code>httptest.NewServer</code> and operate entirely in-process; no external services are needed.</p> <p>A pre-implementation check confirms the integration tests pass with <code>make test</code> before the CI step is added.</p>"},{"location":"plans/2026-02-16-issue-fixes-design/#tests_2","title":"Tests","text":"<ul> <li>No new tests required. The existing service-layer tests exercise <code>sortReleases</code> output and will catch regressions. The integration tests are already written.</li> </ul>"},{"location":"plans/2026-02-16-issue-fixes-design/#implementation-order","title":"Implementation Order","text":"<ol> <li>Branch <code>fix/security</code> from <code>main</code> \u2014 implement PR 1 changes and tests, open PR, merge.</li> <li>Branch <code>fix/bugs</code> from <code>main</code> (post-merge) \u2014 implement PR 2 changes and tests, open PR, merge.</li> <li>Branch <code>feat/ci-quality</code> from <code>main</code> (post-merge) \u2014 implement PR 3 changes, confirm integration tests pass, open PR, merge.</li> </ol>"},{"location":"plans/2026-02-16-issue-fixes-design/#non-goals","title":"Non-Goals","text":"<ul> <li>No new features are introduced.</li> <li>No refactoring beyond the minimal change required to fix each issue.</li> <li>No changes to the OpenAPI spec (no API surface is modified).</li> </ul>"},{"location":"plans/2026-02-16-issue-fixes-implementation/","title":"Issue Fixes Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Fix all 9 open GitHub issues across three focused PRs: security bugs (#1-3), behavioural bugs (#4-6, #8), and CI quality (#7, #9).</p> <p>Architecture: Each PR is an independent branch off <code>main</code>, merged in order. Security PR first; bugs PR second; CI quality third. All changes are minimal \u2014 no refactoring beyond what each issue requires. Tests are written before implementation (TDD).</p> <p>Tech Stack: Go 1.25, <code>net/url</code> (stdlib), <code>sync</code> (stdlib), <code>sort</code> (stdlib), GitHub Actions, Docker (Makefile targets).</p>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#pr-1-fixsecurity-closes-1-2-3","title":"PR 1: <code>fix/security</code> \u2014 Closes #1, #2, #3","text":""},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-1-branch","title":"Task 1: Branch","text":"<p>Step 1: Create and switch to the branch</p> <pre><code>git checkout -b fix/security\n</code></pre> <p>Expected: prompt shows <code>fix/security</code>.</p> <p>Step 2: Commit</p> <p>No files changed yet \u2014 just the branch.</p>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-2-fix-json-storage-file-permissions-1","title":"Task 2: Fix JSON storage file permissions (#1)","text":"<p>Files: - Modify: <code>internal/storage/json.go:66</code> and <code>internal/storage/json.go:135</code> - Test: <code>internal/storage/json_test.go</code></p> <p>Step 1: Write the failing tests</p> <p>In <code>internal/storage/json_test.go</code>, add after the <code>TestNewJSONStorage</code> function:</p> <pre><code>func TestNewJSONStorage_FilePermissions(t *testing.T) {\n    if os.Getenv(\"GOOS\") == \"windows\" {\n        t.Skip(\"permission bits are not enforced on Windows\")\n    }\n    tempDir := t.TempDir()\n    filePath := filepath.Join(tempDir, \"subdir\", \"test.json\")\n\n    storage, err := NewJSONStorage(Config{Type: \"json\", Path: filePath})\n    require.NoError(t, err)\n    defer storage.Close()\n\n    // Directory must be traversable by owner only.\n    dirInfo, err := os.Stat(filepath.Dir(filePath))\n    require.NoError(t, err)\n    assert.Equal(t, os.FileMode(0700), dirInfo.Mode().Perm(),\n        \"directory should be 0700 (owner rwx only)\")\n\n    // Data file must be readable/writable by owner only.\n    fileInfo, err := os.Stat(filePath)\n    require.NoError(t, err)\n    assert.Equal(t, os.FileMode(0600), fileInfo.Mode().Perm(),\n        \"data file should be 0600 (owner rw only)\")\n}\n</code></pre> <p>Add <code>\"os\"</code> to the import block of <code>json_test.go</code> (it is already imported, verify with a search).</p> <p>Step 2: Run the tests to confirm they fail</p> <pre><code>make test\n</code></pre> <p>Expected: <code>FAIL</code> \u2014 directory permission is <code>0644</code>, file permission is <code>0644</code>.</p> <p>Step 3: Fix the permissions</p> <p>In <code>internal/storage/json.go</code>:</p> <p>Line 66, change: <pre><code>if err := os.MkdirAll(filepath.Dir(j.filePath), 0644); err != nil {\n</code></pre> to: <pre><code>if err := os.MkdirAll(filepath.Dir(j.filePath), 0700); err != nil {\n</code></pre></p> <p>Line 135, change: <pre><code>if err := os.WriteFile(j.filePath, fileData, 0644); err != nil {\n</code></pre> to: <pre><code>if err := os.WriteFile(j.filePath, fileData, 0600); err != nil {\n</code></pre></p> <p>Step 4: Run the tests to confirm they pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/storage</code></p> <p>Step 5: Commit</p> <pre><code>git add internal/storage/json.go internal/storage/json_test.go\ngit commit -m \"fix(storage): restrict JSON directory to 0700 and data file to 0600\n\nCloses #1\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-3-fix-admin-session-cookie-missing-secure-flag-2","title":"Task 3: Fix admin session cookie missing Secure flag (#2)","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go:146-163</code> - Test: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Update the existing login cookie test</p> <p>In <code>internal/api/handlers_admin_test.go</code>, find <code>TestAdminLogin_POST_ValidKey_Redirects</code>. Inside the cookie loop, add assertions for <code>Secure</code> and <code>SameSite</code> alongside the existing <code>HttpOnly</code> check:</p> <pre><code>for _, c := range cookies {\n    if c.Name == \"admin_session\" {\n        assert.Equal(t, \"admin-key\", c.Value)\n        assert.True(t, c.HttpOnly)\n        assert.True(t, c.Secure, \"login cookie must carry Secure flag\")\n        assert.Equal(t, http.SameSiteStrictMode, c.SameSite, \"login cookie must be SameSite=Strict\")\n        found = true\n    }\n}\n</code></pre> <p>Step 2: Update the existing logout cookie test</p> <p>In <code>TestAdminLogout_ClearsCookieAndRedirects</code>, update the cookie loop:</p> <pre><code>for _, c := range rec.Result().Cookies() {\n    if c.Name == \"admin_session\" {\n        assert.Equal(t, -1, c.MaxAge)\n        assert.True(t, c.HttpOnly, \"logout cookie must be HttpOnly\")\n        assert.True(t, c.Secure, \"logout cookie must carry Secure flag\")\n        assert.Equal(t, http.SameSiteStrictMode, c.SameSite, \"logout cookie must be SameSite=Strict\")\n    }\n}\n</code></pre> <p>Step 3: Run the tests to confirm they fail</p> <pre><code>make test\n</code></pre> <p>Expected: <code>FAIL</code> \u2014 <code>Secure</code> is <code>false</code>, <code>SameSite</code> is <code>0</code>.</p> <p>Step 4: Fix the login cookie</p> <p>In <code>internal/api/handlers_admin.go</code>, replace lines 146-152:</p> <pre><code>http.SetCookie(w, &amp;http.Cookie{\n    Name:     \"admin_session\",\n    Value:    key,\n    Path:     \"/admin\",\n    HttpOnly: true,\n    Secure:   true,\n    SameSite: http.SameSiteStrictMode,\n})\n</code></pre> <p>Step 5: Fix the logout cookie</p> <p>Replace lines 158-163:</p> <pre><code>http.SetCookie(w, &amp;http.Cookie{\n    Name:     \"admin_session\",\n    Value:    \"\",\n    Path:     \"/admin\",\n    MaxAge:   -1,\n    HttpOnly: true,\n    Secure:   true,\n    SameSite: http.SameSiteStrictMode,\n})\n</code></pre> <p>Step 6: Run the tests to confirm they pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/api</code></p> <p>Step 7: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"fix(api): add Secure flag to admin session cookie and fix logout attributes\n\nCloses #2\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-4-fix-flash-message-url-encoding-3","title":"Task 4: Fix flash message URL encoding (#3)","text":"<p>Files: - Modify: <code>internal/api/handlers_admin.go:115-121</code> - Test: <code>internal/api/handlers_admin_test.go</code></p> <p>Step 1: Write the failing tests</p> <p>Add to <code>internal/api/handlers_admin_test.go</code>:</p> <pre><code>func TestAddFlash_EncodesSpecialCharacters(t *testing.T) {\n    // A message containing URL-significant characters must not inject extra params.\n    result := addFlash(\"/admin/apps\", \"error: path=foo&amp;admin=true\", \"error\")\n    u, err := url.Parse(result)\n    require.NoError(t, err)\n    assert.Equal(t, \"error: path=foo&amp;admin=true\", u.Query().Get(\"flash\"),\n        \"flash message must be fully decoded back to the original string\")\n    assert.Equal(t, \"error\", u.Query().Get(\"flash_type\"))\n    assert.Len(t, u.Query(), 2, \"must have exactly 2 query params \u2014 no injection\")\n}\n\nfunc TestAddFlash_WithExistingQueryString(t *testing.T) {\n    result := addFlash(\"/admin/apps?page=2\", \"saved\", \"success\")\n    u, err := url.Parse(result)\n    require.NoError(t, err)\n    assert.Equal(t, \"saved\", u.Query().Get(\"flash\"))\n    assert.Equal(t, \"2\", u.Query().Get(\"page\"), \"existing query params must be preserved\")\n}\n</code></pre> <p><code>\"net/url\"</code> is already imported in <code>handlers_admin_test.go</code> (it is used for <code>url.Values</code> in the login test). Verify.</p> <p>Step 2: Run the tests to confirm they fail</p> <pre><code>make test\n</code></pre> <p>Expected: <code>FAIL</code> \u2014 <code>TestAddFlash_EncodesSpecialCharacters</code> fails because the raw <code>&amp;</code> breaks the query string.</p> <p>Step 3: Rewrite addFlash</p> <p>In <code>internal/api/handlers_admin.go</code>, replace the <code>addFlash</code> function (lines 115-121):</p> <pre><code>// addFlash appends flash query params to a redirect URL.\n// msg and flashType are URL-encoded so special characters cannot inject extra parameters.\nfunc addFlash(base, msg, flashType string) string {\n    u, err := url.Parse(base)\n    if err != nil {\n        return base\n    }\n    q := u.Query()\n    q.Set(\"flash\", msg)\n    q.Set(\"flash_type\", flashType)\n    u.RawQuery = q.Encode()\n    return u.String()\n}\n</code></pre> <p>Step 4: Add <code>\"net/url\"</code> to the import block</p> <p>In <code>internal/api/handlers_admin.go</code>, update the import block to include <code>\"net/url\"</code> and remove <code>\"strings\"</code> (which was only used by the old <code>addFlash</code>):</p> <pre><code>import (\n    \"embed\"\n    \"html/template\"\n    \"log/slog\"\n    \"net/http\"\n    \"net/url\"\n    \"updater/internal/models\"\n\n    \"github.com/gorilla/mux\"\n)\n</code></pre> <p>Step 5: Run vet to catch any remaining unused imports</p> <pre><code>make vet\n</code></pre> <p>Expected: no errors.</p> <p>Step 6: Run the tests to confirm they pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/api</code></p> <p>Step 7: Commit</p> <pre><code>git add internal/api/handlers_admin.go internal/api/handlers_admin_test.go\ngit commit -m \"fix(api): URL-encode flash message query parameters in addFlash\n\nCloses #3\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-5-open-pr-1","title":"Task 5: Open PR 1","text":"<p>Step 1: Push the branch</p> <pre><code>git push -u origin fix/security\n</code></pre> <p>Step 2: Open pull request</p> <pre><code>gh pr create \\\n  --title \"fix(security): cookie Secure flag, flash URL encoding, file permissions\" \\\n  --body \"Closes #1, #2, #3\n\n## Changes\n- Restrict JSON storage directory to \\`0700\\` and data file to \\`0600\\`\n- Add \\`Secure: true\\` to admin session cookie; align logout cookie attributes\n- URL-encode flash message parameters with \\`url.Values\\` to prevent query injection\n\n## Test plan\n- [ ] \\`make test\\` passes\n- [ ] \\`make vet\\` passes\" \\\n  --base main\n</code></pre> <p>Step 3: After review and CI pass, merge and pull main</p> <pre><code>git checkout main &amp;&amp; git pull\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#pr-2-fixbugs-closes-4-5-6-8","title":"PR 2: <code>fix/bugs</code> \u2014 Closes #4, #5, #6, #8","text":""},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-6-branch","title":"Task 6: Branch","text":"<pre><code>git checkout main &amp;&amp; git checkout -b fix/bugs\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-7-fix-dockerfile-go-version-mismatch-4","title":"Task 7: Fix Dockerfile Go version mismatch (#4)","text":"<p>Files: - Modify: <code>Dockerfile:7</code></p> <p>Step 1: Apply the fix</p> <p>In <code>Dockerfile</code>, change line 7 from: <pre><code>FROM golang:1.26-alpine AS builder\n</code></pre> to: <pre><code>FROM golang:1.25-alpine AS builder\n</code></pre></p> <p>Step 2: Verify the Makefile already uses 1.25</p> <p><code>Makefile</code> line 11 already sets <code>GO_IMAGE := golang:1.25-alpine</code>. The Dockerfile is now consistent.</p> <p>Step 3: Commit</p> <pre><code>git add Dockerfile\ngit commit -m \"fix(docker): align builder image with go.mod toolchain (1.25)\n\nCloses #4\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-8-fix-dockerfile-static-binary-check-5","title":"Task 8: Fix Dockerfile static-binary check (#5)","text":"<p>Files: - Modify: <code>Dockerfile:60</code></p> <p>Step 1: Apply the fix</p> <p>In <code>Dockerfile</code>, change line 60 from: <pre><code>RUN ldd updater 2&gt;&amp;1 | grep -q \"not a dynamic executable\" || echo \"Binary is statically linked\"\n</code></pre> to: <pre><code>RUN ldd updater 2&gt;&amp;1 | grep -q \"not a dynamic executable\" || \\\n  (echo \"FAILED: binary is not statically linked\" &amp;&amp; exit 1)\n</code></pre></p> <p>Step 2: Commit</p> <pre><code>git add Dockerfile\ngit commit -m \"fix(docker): fail build when binary is not statically linked\n\nCloses #5\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-9-fix-toctou-race-in-loaddata-and-add-race-detection-ci-6-8","title":"Task 9: Fix TOCTOU race in loadData and add race-detection CI (#6, #8)","text":"<p>Files: - Modify: <code>internal/storage/json.go:83-124</code> (<code>loadData</code> function) - Modify: <code>.github/workflows/ci.yml</code> - Test: <code>internal/storage/json_test.go</code></p> <p>Step 1: Write the failing concurrent test</p> <p>Add to <code>internal/storage/json_test.go</code> (add <code>\"sync\"</code> to imports):</p> <pre><code>func TestJSONStorage_ConcurrentLoad(t *testing.T) {\n    storage := setupTestStorage(t)\n    defer storage.Close()\n\n    // Expire the cache to force all goroutines to hit the slow path.\n    storage.mu.Lock()\n    storage.cacheExpiry = time.Time{}\n    storage.mu.Unlock()\n\n    const n = 20\n    errs := make(chan error, n)\n    var wg sync.WaitGroup\n    wg.Add(n)\n    for i := 0; i &lt; n; i++ {\n        go func() {\n            defer wg.Done()\n            errs &lt;- storage.loadData()\n        }()\n    }\n    wg.Wait()\n    close(errs)\n\n    for err := range errs {\n        assert.NoError(t, err)\n    }\n    storage.mu.RLock()\n    assert.NotNil(t, storage.data)\n    storage.mu.RUnlock()\n}\n</code></pre> <p>Step 2: Run the test with race detection to confirm the race</p> <p>The race detector requires CGO, which the Docker target disables. Run natively if Go is installed locally:</p> <pre><code>go test -race ./internal/storage/... -run TestJSONStorage_ConcurrentLoad -v\n</code></pre> <p>Expected: <code>DATA RACE</code> reported (this confirms the existing bug).</p> <p>If you don't have Go installed locally, skip this verification step and trust the CI race job (added in Task 9 step 5 below).</p> <p>Step 3: Rewrite loadData with double-checked locking</p> <p>Replace the entire <code>loadData</code> function in <code>internal/storage/json.go</code> (lines 83-124):</p> <pre><code>// loadData loads data from the JSON file with caching.\n// It uses double-checked locking: a fast read-lock path for cache hits,\n// and a write-lock slow path with re-validation to prevent TOCTOU races.\nfunc (j *JSONStorage) loadData() error {\n    // Fast path: cache is still valid.\n    j.mu.RLock()\n    if j.data != nil &amp;&amp; time.Now().Before(j.cacheExpiry) {\n        j.mu.RUnlock()\n        return nil\n    }\n    j.mu.RUnlock()\n\n    // Slow path: acquire write lock and re-validate before doing any I/O.\n    j.mu.Lock()\n    defer j.mu.Unlock()\n\n    // Another goroutine may have loaded while we waited for the write lock.\n    if j.data != nil &amp;&amp; time.Now().Before(j.cacheExpiry) {\n        return nil\n    }\n\n    // Stat and all subsequent reads are done under the write lock.\n    info, err := os.Stat(j.filePath)\n    if err != nil {\n        return fmt.Errorf(\"failed to stat file: %w\", err)\n    }\n\n    // If the file hasn't changed, extend the cache and return.\n    if j.data != nil &amp;&amp; !info.ModTime().After(j.lastModified) {\n        j.cacheExpiry = time.Now().Add(j.cacheTTL)\n        return nil\n    }\n\n    fileData, err := os.ReadFile(j.filePath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read file: %w\", err)\n    }\n\n    var data JSONData\n    if err := json.Unmarshal(fileData, &amp;data); err != nil {\n        return fmt.Errorf(\"failed to unmarshal JSON: %w\", err)\n    }\n\n    j.data = &amp;data\n    j.lastModified = info.ModTime()\n    j.cacheExpiry = time.Now().Add(j.cacheTTL)\n    return nil\n}\n</code></pre> <p>Step 4: Run tests to confirm they pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/storage</code></p> <p>Step 5: Add race-detection job to CI</p> <p>In <code>.github/workflows/ci.yml</code>, add a new <code>race</code> job after the <code>security</code> job:</p> <pre><code>  race:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-go@v5\n        with:\n          go-version-file: 'go.mod'\n\n      - name: Race detector\n        run: go test -race ./...\n</code></pre> <p>Note: This job sets up Go natively (not via Docker) so CGO is available for the race detector. This matches the pattern already used by the <code>security</code> job.</p> <p>Step 6: Commit</p> <pre><code>git add internal/storage/json.go internal/storage/json_test.go .github/workflows/ci.yml\ngit commit -m \"fix(storage): eliminate TOCTOU race in loadData with double-checked locking\n\nAdd race-detection CI job to catch concurrent storage and rate-limit bugs.\n\nCloses #6, #8\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-10-open-pr-2","title":"Task 10: Open PR 2","text":"<p>Step 1: Push the branch</p> <pre><code>git push -u origin fix/bugs\n</code></pre> <p>Step 2: Open pull request</p> <pre><code>gh pr create \\\n  --title \"fix(bugs): Dockerfile Go version, static-binary check, loadData TOCTOU race, race CI\" \\\n  --body \"Closes #4, #5, #6, #8\n\n## Changes\n- Align Dockerfile builder image with \\`go.mod\\` toolchain (\\`golang:1.25-alpine\\`)\n- Static-binary check now fails the build on non-static output\n- \\`loadData\\` rewritten with double-checked locking to eliminate TOCTOU race\n- New \\`race\\` CI job runs \\`go test -race ./...\\` on every PR\n\n## Test plan\n- [ ] \\`make test\\` passes\n- [ ] \\`make vet\\` passes\n- [ ] CI race job passes\" \\\n  --base main\n</code></pre> <p>Step 3: After review and CI pass, merge and pull main</p> <pre><code>git checkout main &amp;&amp; git pull\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#pr-3-featci-quality-closes-7-9","title":"PR 3: <code>feat/ci-quality</code> \u2014 Closes #7, #9","text":""},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-11-branch","title":"Task 11: Branch","text":"<pre><code>git checkout main &amp;&amp; git checkout -b feat/ci-quality\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-12-replace-bubble-sort-with-sortslice-7","title":"Task 12: Replace bubble sort with sort.Slice (#7)","text":"<p>Files: - Modify: <code>internal/update/service.go:350-357</code></p> <p>Step 1: Locate the bubble sort</p> <p>The <code>sortReleases</code> method on <code>*Service</code> (around line 313) ends with nested loops:</p> <pre><code>for i := 0; i &lt; len(releases)-1; i++ {\n    for j := 0; j &lt; len(releases)-i-1; j++ {\n        if less(j+1, j) {\n            releases[j], releases[j+1] = releases[j+1], releases[j]\n        }\n    }\n}\n</code></pre> <p>Step 2: Run existing tests to establish baseline</p> <pre><code>make test\n</code></pre> <p>Expected: all pass. Note the output.</p> <p>Step 3: Replace the loops</p> <p>Delete the nested loop block and replace with:</p> <pre><code>sort.Slice(releases, less)\n</code></pre> <p>The <code>\"sort\"</code> import is already present in <code>service.go</code> (it is used elsewhere in the file). If not, add it.</p> <p>Step 4: Run tests to confirm they still pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/update</code> \u2014 same results as baseline.</p> <p>Step 5: Commit</p> <pre><code>git add internal/update/service.go\ngit commit -m \"perf(update): replace O(n\u00b2) bubble sort with sort.Slice in sortReleases\n\nCloses #7\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-13-add-integration-tests-to-ci-9","title":"Task 13: Add integration tests to CI (#9)","text":"<p>Files: - Modify: <code>.github/workflows/ci.yml</code></p> <p>Step 1: Verify integration tests pass locally</p> <pre><code>make test\n</code></pre> <p>The <code>make test</code> target runs <code>go test ./...</code> which includes <code>./internal/integration/...</code>. Check that the integration package passes. If it fails, fix before proceeding.</p> <p>Step 2: Confirm the integration tests need no external services</p> <p>The tests in <code>internal/integration/integration_test.go</code> use: - <code>t.TempDir()</code> for storage - <code>httptest.NewServer</code> for the HTTP layer</p> <p>No database or running server is required. The tests are fully self-contained.</p> <p>Step 3: Add the integration test step to CI</p> <p>In <code>.github/workflows/ci.yml</code>, add a step in the <code>ci</code> job after the <code>Validate OpenAPI spec</code> step:</p> <pre><code>      - name: Integration tests\n        run: make test\n</code></pre> <p>Note: <code>make test</code> already runs <code>go test ./...</code>, which includes the integration package. This step makes the intent explicit in the CI log output. If you want a truly separate, labelled step, you can use <code>go test -v ./internal/integration/...</code> instead \u2014 but that requires adding <code>actions/setup-go</code> to the <code>ci</code> job, since <code>ci</code> currently relies on Docker-based Make targets. Keeping it as <code>make test</code> avoids that change.</p> <p>Actually, since <code>make test</code> already covers integration tests, the most accurate fix for issue #9 is adding a clearly-labelled step that documents this intent. Replace the existing <code>Coverage</code> step comment:</p> <p>Alternatively: the current <code>Coverage</code> step already runs all tests via <code>make cover</code> (which calls <code>go test ./...</code>). The issue is that integration tests were implicitly running but not visibly tracked. Add an explicit step:</p> <p>In the <code>ci</code> job, after <code>Validate OpenAPI spec</code>:</p> <pre><code>      - name: Integration tests\n        run: make test\n</code></pre> <p>This ensures integration tests are visibly executed and fail the job if they regress.</p> <p>Step 4: Run tests to confirm integration tests pass</p> <pre><code>make test\n</code></pre> <p>Expected: <code>ok   updater/internal/integration</code></p> <p>Step 5: Commit</p> <pre><code>git add .github/workflows/ci.yml\ngit commit -m \"ci: make integration tests an explicit CI step\n\nCloses #9\"\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#task-14-open-pr-3","title":"Task 14: Open PR 3","text":"<p>Step 1: Push the branch</p> <pre><code>git push -u origin feat/ci-quality\n</code></pre> <p>Step 2: Open pull request</p> <pre><code>gh pr create \\\n  --title \"feat(ci): replace bubble sort with sort.Slice, add integration test CI step\" \\\n  --body \"Closes #7, #9\n\n## Changes\n- Replace O(n\u00b2) bubble sort in \\`sortReleases\\` with \\`sort.Slice\\` (O(n log n))\n- Add explicit integration test step to CI so regressions are visibly tracked\n\n## Test plan\n- [ ] \\`make test\\` passes (including integration package)\n- [ ] \\`make vet\\` passes\" \\\n  --base main\n</code></pre> <p>Step 3: After review and CI pass, merge</p> <pre><code>git checkout main &amp;&amp; git pull\n</code></pre>"},{"location":"plans/2026-02-16-issue-fixes-implementation/#summary","title":"Summary","text":"PR Branch Issues Key files 1 <code>fix/security</code> #1 #2 #3 <code>internal/storage/json.go</code>, <code>internal/api/handlers_admin.go</code> 2 <code>fix/bugs</code> #4 #5 #6 #8 <code>Dockerfile</code>, <code>internal/storage/json.go</code>, <code>.github/workflows/ci.yml</code> 3 <code>feat/ci-quality</code> #7 #9 <code>internal/update/service.go</code>, <code>.github/workflows/ci.yml</code> <p>Run <code>make check</code> (format + vet + test) before opening each PR.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/","title":"Proxy Delegation Design","text":"<p>Date: 2026-02-18 Status: Approved</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#problem","title":"Problem","text":"<p>The updater service currently implements CORS, rate limiting, trusted proxy handling, and a JWT secret field in its own application layer. These concerns are better owned by a reverse proxy (nginx, Traefik) that sits in front of the service in every production deployment. Keeping them in the application adds configuration surface, code to maintain, and test coverage obligations without providing value that the proxy layer does not already supply.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#decision","title":"Decision","text":"<p>Remove the four features from the application entirely. The service will document which proxy configuration replaces each removed feature and will emit startup warnings if deprecated config keys are still present in the YAML.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#scope","title":"Scope","text":""},{"location":"plans/2026-02-18-proxy-delegation-design/#removed-from-the-application","title":"Removed from the application","text":"Feature Location Notes <code>CORSConfig</code> type + <code>server.cors</code> block <code>internal/models/config.go</code> Proxy sets <code>Access-Control-Allow-*</code> headers <code>RateLimitConfig</code> type + <code>security.rate_limit</code> block <code>internal/models/config.go</code> Proxy enforces request limits <code>SecurityConfig.TrustedProxies</code> <code>internal/models/config.go</code> Proxy is unconditionally trusted <code>SecurityConfig.JWTSecret</code> <code>internal/models/config.go</code> Unused in the current codebase <code>corsMiddleware</code> + <code>WithRateLimiter</code> wiring <code>internal/api/routes.go</code> ~30 lines <code>internal/ratelimit/</code> package entire directory <code>limiter.go</code>, <code>memory.go</code>, <code>middleware.go</code> + tests Rate limiter wiring <code>cmd/updater/updater.go</code> ~8 lines CORS + rate limit tests <code>internal/api/security_test.go</code>, <code>internal/models/config_test.go</code> Remove only the cases for removed features"},{"location":"plans/2026-02-18-proxy-delegation-design/#unchanged","title":"Unchanged","text":"<ul> <li>API key authentication (<code>authMiddleware</code>, <code>OptionalAuth</code>)</li> <li>Permission enforcement (<code>RequirePermission</code>, read/write/admin hierarchy)</li> <li>Admin cookie session middleware (<code>adminSessionMiddleware</code>)</li> <li><code>EnableAuth</code> config toggle</li> <li>All HTTP handlers, OpenAPI spec, request/response models</li> <li>Logging middleware, panic recovery middleware</li> </ul>"},{"location":"plans/2026-02-18-proxy-delegation-design/#deprecation-warning","title":"Deprecation Warning","text":"<p>On startup, <code>LoadConfig</code> will perform a second decode into a <code>deprecatedConfig</code> struct that retains the old fields:</p> <pre><code>type deprecatedConfig struct {\n    Server   struct { CORS interface{} `yaml:\"cors\"` }         `yaml:\"server\"`\n    Security struct {\n        JWTSecret      string      `yaml:\"jwt_secret\"`\n        TrustedProxies interface{} `yaml:\"trusted_proxies\"`\n        RateLimit      interface{} `yaml:\"rate_limit\"`\n    } `yaml:\"security\"`\n}\n</code></pre> <p>If any field is non-zero, a <code>slog.Warn</code> is emitted naming the offending key and pointing to <code>docs/reverse-proxy.md</code>. The service continues to start normally \u2014 no fatal error.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#new-files","title":"New Files","text":"<pre><code>examples/\n  nginx/\n    nginx.conf          # TLS termination, CORS, rate limiting, X-Forwarded-For\n    docker-compose.yml  # nginx + updater compose\n  traefik/\n    docker-compose.yml  # Traefik v3 + updater with CORS middleware, rate limiting, Let's Encrypt TLS\ndocs/\n  reverse-proxy.md      # Overview: what the proxy must handle, links to examples\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-design/#updated-files","title":"Updated Files","text":"File Change <code>docker/nginx/nginx.conf</code> Add <code>Access-Control-Allow-*</code> headers; update comments <code>examples/config.yaml</code> Remove <code>cors</code>, <code>jwt_secret</code>, <code>rate_limit</code>, <code>trusted_proxies</code>, stale <code>api_keys</code> <code>docs/SECURITY.md</code> Remove CORS and rate limiting sections; add \"Proxy Layer\" section <code>docs/ARCHITECTURE.md</code> Update security features list <code>mkdocs.yml</code> Add <code>reverse-proxy.md</code> to nav <code>internal/models/config.go</code> Remove four config types/fields and their defaults <code>internal/models/config_test.go</code> Remove <code>RateLimitConfig</code> and <code>CORSConfig</code> test cases <code>internal/api/routes.go</code> Remove <code>corsMiddleware</code>, <code>WithRateLimiter</code>; remove CORS opt-in block <code>internal/api/security_test.go</code> Remove CORS header assertion tests <code>cmd/updater/updater.go</code> Remove <code>ratelimit</code> import and limiter construction <code>internal/config/</code> Add <code>checkDeprecatedKeys</code> function"},{"location":"plans/2026-02-18-proxy-delegation-design/#proxy-responsibilities","title":"Proxy Responsibilities","text":""},{"location":"plans/2026-02-18-proxy-delegation-design/#cors","title":"CORS","text":"<p>nginx sets <code>Access-Control-Allow-*</code> response headers on all proxied requests. The service no longer handles preflight OPTIONS responses for CORS purposes (the existing OPTIONS handler for unknown routes returns 204 and is unrelated to CORS).</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#rate-limiting","title":"Rate limiting","text":"<p>nginx uses two <code>limit_req_zone</code> zones keyed on <code>$binary_remote_addr</code> to approximate the app's two-tier behaviour:</p> <ul> <li>Anonymous zone: lower rate (equivalent to the former <code>requests_per_minute</code> / <code>burst_size</code>)</li> <li>A separate zone for the <code>/api/</code> path at a higher rate reflects the former <code>authenticated_requests_per_minute</code></li> </ul> <p>A true per-key authenticated rate limit requires custom logic (e.g., <code>auth_request</code> + Redis) and is out of scope.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#tls","title":"TLS","text":"<p>Both nginx and Traefik examples terminate TLS externally and forward plain HTTP to the service on port 8080.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#real-client-ip","title":"Real client IP","text":"<p><code>X-Forwarded-For</code> and <code>X-Real-IP</code> are forwarded by the proxy. The service's request logging reads <code>r.RemoteAddr</code> which will be the proxy's IP. If real client IPs are needed in logs, handlers should read <code>X-Real-IP</code>. This is a known trade-off \u2014 no logging change is in scope for this PR.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#breaking-config-change","title":"Breaking Config Change","text":"<p>Operators using <code>server.cors</code>, <code>security.rate_limit</code>, <code>security.jwt_secret</code>, or <code>security.trusted_proxies</code> in their YAML files will see startup warnings but no crash. They should migrate those concerns to their reverse proxy and remove the deprecated keys from their config.</p>"},{"location":"plans/2026-02-18-proxy-delegation-design/#out-of-scope","title":"Out of Scope","text":"<ul> <li>Updating request logging to use the forwarded real IP</li> <li>Distributed rate limiting (Redis-backed) for HA deployments \u2014 this is tracked in roadmap item 3.2</li> <li>Multi-tenancy changes</li> </ul>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/","title":"Proxy Delegation Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Remove CORS, rate limiting, JWT secret, and trusted proxies from the application and replace them with nginx and Traefik example configurations, plus startup warnings for stale config keys.</p> <p>Architecture: All four features are deleted from Go source; the <code>internal/ratelimit/</code> package is removed entirely. A <code>warnDeprecatedKeys</code> function in <code>internal/config/config.go</code> performs a second YAML decode on startup to detect stale operator configs and emit <code>slog.Warn</code> messages. Reverse-proxy sample configs in <code>examples/nginx/</code> and <code>examples/traefik/</code> provide operators with drop-in replacements.</p> <p>Tech Stack: Go 1.25, <code>gopkg.in/yaml.v3</code>, <code>log/slog</code>, nginx, Traefik v3</p> <p>Design doc: <code>docs/plans/2026-02-18-proxy-delegation-design.md</code></p> <p>Branch: Create a new branch from <code>main</code> before starting \u2014 do not implement on <code>docs/reconcile-and-autogen</code>.</p> <pre><code>git checkout main\ngit pull\ngit checkout -b feat/proxy-delegation\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-1-delete-internalratelimit-and-remove-its-wiring-from-cmdupdaterupdatergo","title":"Task 1: Delete <code>internal/ratelimit/</code> and remove its wiring from <code>cmd/updater/updater.go</code>","text":"<p>Files: - Delete: <code>internal/ratelimit/</code> (entire directory \u2014 limiter.go, memory.go, memory_test.go, middleware.go, middleware_test.go) - Modify: <code>cmd/updater/updater.go</code></p> <p>Step 1: Delete the ratelimit package</p> <pre><code>git rm -r internal/ratelimit/\n</code></pre> <p>Expected: 5 files staged for deletion.</p> <p>Step 2: Remove the import and wiring from <code>cmd/updater/updater.go</code></p> <p>Remove the import line: <pre><code>\"updater/internal/ratelimit\"\n</code></pre></p> <p>Remove the entire block at lines 107\u2013127 (the rate limiter initialization): <pre><code>// Initialize rate limiter if enabled\nif cfg.Security.RateLimit.Enabled {\n    rlCfg := cfg.Security.RateLimit\n    ...\n    routeOpts = append(routeOpts, api.WithRateLimiter(ratelimit.Middleware(anonLimiter, authLimiter)))\n}\n</code></pre></p> <p>The <code>routeOpts</code> slice declaration and the OTel append above it are unaffected \u2014 leave them.</p> <p>Step 3: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: compilation fails because <code>api.WithRateLimiter</code> still exists and references <code>net/http</code> but takes no ratelimit argument. That is fine \u2014 <code>WithRateLimiter</code> will be removed in Task 4. For now, the compilation error is from <code>updater.go</code> referencing the deleted package, which should now be clean. If <code>WithRateLimiter</code> is referenced nowhere else, the build should succeed. Verify with:</p> <pre><code>make build\n</code></pre> <p>Expected: BUILD SUCCESS (the ratelimit package is gone and no import references it).</p> <p>Step 4: Commit</p> <pre><code>git add cmd/updater/updater.go\ngit commit -m \"feat: remove internal/ratelimit package and wiring\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-2-remove-corsconfig-from-models-and-environment-loader","title":"Task 2: Remove <code>CORSConfig</code> from models and environment loader","text":"<p>Files: - Modify: <code>internal/models/config.go</code> - Modify: <code>internal/models/config_test.go</code> - Modify: <code>internal/config/config.go</code></p> <p>Step 1: Remove <code>CORSConfig</code> type and <code>CORS</code> field from <code>internal/models/config.go</code></p> <p>Delete the entire <code>CORSConfig</code> struct (lines 64\u201370): <pre><code>type CORSConfig struct {\n    Enabled        bool     `yaml:\"enabled\" json:\"enabled\"`\n    AllowedOrigins []string `yaml:\"allowed_origins\" json:\"allowed_origins\"`\n    AllowedMethods []string `yaml:\"allowed_methods\" json:\"allowed_methods\"`\n    AllowedHeaders []string `yaml:\"allowed_headers\" json:\"allowed_headers\"`\n    MaxAge         int      `yaml:\"max_age\" json:\"max_age\"`\n}\n</code></pre></p> <p>Remove the <code>CORS</code> field from <code>ServerConfig</code>: <pre><code>CORS         CORSConfig    `yaml:\"cors\" json:\"cors\"`\n</code></pre></p> <p>Remove the <code>CORS</code> default block from <code>NewDefaultConfig()</code>: <pre><code>CORS: CORSConfig{\n    Enabled:        true,\n    AllowedOrigins: []string{\"*\"},\n    AllowedMethods: []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n    AllowedHeaders: []string{\"*\"},\n    MaxAge:         86400,\n},\n</code></pre></p> <p>Also update the comment in <code>NewDefaultConfig()</code> \u2014 remove the line \"- Rate limiting enabled: Prevent abuse from the start\".</p> <p>Step 2: Remove CORS env var handling from <code>internal/config/config.go</code></p> <p>Delete this entire block (lines 102\u2013123): <pre><code>// CORS configuration\nif cors := os.Getenv(\"UPDATER_CORS_ENABLED\"); cors != \"\" {\n    config.Server.CORS.Enabled = strings.ToLower(cors) == \"true\"\n}\nif origins := os.Getenv(\"UPDATER_CORS_ALLOWED_ORIGINS\"); origins != \"\" {\n    config.Server.CORS.AllowedOrigins = strings.Split(origins, \",\")\n}\nif methods := os.Getenv(\"UPDATER_CORS_ALLOWED_METHODS\"); methods != \"\" {\n    config.Server.CORS.AllowedMethods = strings.Split(methods, \",\")\n}\nif headers := os.Getenv(\"UPDATER_CORS_ALLOWED_HEADERS\"); headers != \"\" {\n    config.Server.CORS.AllowedHeaders = strings.Split(headers, \",\")\n}\nif maxAge := os.Getenv(\"UPDATER_CORS_MAX_AGE\"); maxAge != \"\" {\n    if age, err := strconv.Atoi(maxAge); err == nil {\n        config.Server.CORS.MaxAge = age\n    }\n}\n</code></pre></p> <p>Step 3: Remove CORS tests from <code>internal/models/config_test.go</code></p> <p>Search for any test cases, table rows, or struct literals that reference <code>CORSConfig</code> or <code>Server.CORS</code>. Remove them. The test functions themselves may survive if they test other fields \u2014 only remove the CORS-specific assertions and struct fields.</p> <p>Step 4: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS (CORS middleware still exists in routes.go but doesn't reference <code>CORSConfig</code> directly at this point \u2014 it will be removed in Task 4).</p> <p>Step 5: Commit</p> <pre><code>git add internal/models/config.go internal/models/config_test.go internal/config/config.go\ngit commit -m \"feat: remove CORSConfig from models and environment loader\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-3-remove-ratelimitconfig-jwtsecret-and-trustedproxies-from-models-and-environment-loader","title":"Task 3: Remove <code>RateLimitConfig</code>, <code>JWTSecret</code>, and <code>TrustedProxies</code> from models and environment loader","text":"<p>Files: - Modify: <code>internal/models/config.go</code> - Modify: <code>internal/models/config_test.go</code> - Modify: <code>internal/config/config.go</code></p> <p>Step 1: Remove fields from <code>SecurityConfig</code> in <code>internal/models/config.go</code></p> <p>The current struct: <pre><code>type SecurityConfig struct {\n    BootstrapKey string          `yaml:\"bootstrap_key\" json:\"bootstrap_key\"`\n    RateLimit    RateLimitConfig `yaml:\"rate_limit\" json:\"rate_limit\"`\n    JWTSecret    string          `yaml:\"jwt_secret\" json:\"jwt_secret\"`\n    EnableAuth     bool     `yaml:\"enable_auth\" json:\"enable_auth\"`\n    TrustedProxies []string `yaml:\"trusted_proxies\" json:\"trusted_proxies\"`\n}\n</code></pre></p> <p>After removal: <pre><code>// SecurityConfig holds authentication and authorisation settings.\ntype SecurityConfig struct {\n    // BootstrapKey is the initial admin API key seeded into storage on first startup\n    // when the api_keys table is empty. Required when EnableAuth is true.\n    // Set via the UPDATER_BOOTSTRAP_KEY environment variable or security.bootstrap_key\n    // in the config file. After the first startup, keys are managed via the REST API.\n    BootstrapKey string `yaml:\"bootstrap_key\" json:\"bootstrap_key\"`\n    // EnableAuth toggles API key authentication. When false all endpoints are public.\n    EnableAuth bool `yaml:\"enable_auth\" json:\"enable_auth\"`\n}\n</code></pre></p> <p>Step 2: Delete <code>RateLimitConfig</code> type entirely</p> <p>Remove the entire <code>RateLimitConfig</code> struct (lines 102\u2013116).</p> <p>Step 3: Remove defaults from <code>NewDefaultConfig()</code></p> <p>Delete this block from <code>NewDefaultConfig()</code>: <pre><code>Security: SecurityConfig{\n    RateLimit: RateLimitConfig{\n        Enabled:                        true,\n        RequestsPerMinute:              60,\n        BurstSize:                      10,\n        AuthenticatedRequestsPerMinute: 120,\n        AuthenticatedBurstSize:         20,\n        CleanupInterval:                5 * time.Minute,\n    },\n    EnableAuth:     false,\n    TrustedProxies: []string{},\n},\n</code></pre></p> <p>Replace with: <pre><code>Security: SecurityConfig{\n    EnableAuth: false,\n},\n</code></pre></p> <p>Step 4: Remove from <code>internal/config/config.go</code></p> <p>Delete the JWT secret env var block: <pre><code>if secret := os.Getenv(\"UPDATER_JWT_SECRET\"); secret != \"\" {\n    config.Security.JWTSecret = secret\n}\n</code></pre></p> <p>Delete the rate limit env var blocks: <pre><code>if rateLimit := os.Getenv(\"UPDATER_RATE_LIMIT_ENABLED\"); rateLimit != \"\" {\n    config.Security.RateLimit.Enabled = strings.ToLower(rateLimit) == \"true\"\n}\nif rpm := os.Getenv(\"UPDATER_RATE_LIMIT_RPM\"); rpm != \"\" {\n    if r, err := strconv.Atoi(rpm); err == nil {\n        config.Security.RateLimit.RequestsPerMinute = r\n    }\n}\nif burst := os.Getenv(\"UPDATER_RATE_LIMIT_BURST\"); burst != \"\" {\n    if b, err := strconv.Atoi(burst); err == nil {\n        config.Security.RateLimit.BurstSize = b\n    }\n}\n</code></pre></p> <p>In <code>SaveExample</code>, remove: <pre><code>config.Security.JWTSecret = \"your-jwt-secret-here\"\n</code></pre></p> <p>Step 5: Remove rate limit tests from <code>internal/models/config_test.go</code></p> <p>Delete <code>TestRateLimitConfig_Structure</code> (line 864 onward). Remove any table rows that set <code>RateLimitConfig</code> fields in other test functions.</p> <p>Step 6: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS. The build may still reference <code>WithRateLimiter</code> in routes.go \u2014 that is removed in Task 4.</p> <p>Step 7: Commit</p> <pre><code>git add internal/models/config.go internal/models/config_test.go internal/config/config.go\ngit commit -m \"feat: remove RateLimitConfig, JWTSecret, and TrustedProxies from config\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-4-remove-corsmiddleware-and-withratelimiter-from-the-api-router","title":"Task 4: Remove <code>corsMiddleware</code> and <code>WithRateLimiter</code> from the API router","text":"<p>Files: - Modify: <code>internal/api/routes.go</code> - Modify: <code>internal/api/security_test.go</code></p> <p>Step 1: Remove from <code>internal/api/routes.go</code></p> <p>Delete the <code>corsMiddleware</code> function (lines 176\u2013201) in its entirety.</p> <p>Delete the <code>WithRateLimiter</code> function: <pre><code>// WithRateLimiter adds rate limiting middleware to the router.\nfunc WithRateLimiter(middleware func(http.Handler) http.Handler) RouteOption {\n    return func(r *mux.Router) {\n        r.Use(middleware)\n    }\n}\n</code></pre></p> <p>Remove the CORS opt-in block from <code>SetupRoutes</code>: <pre><code>if config.Server.CORS.Enabled {\n    router.Use(corsMiddleware(config.Server.CORS))\n}\n</code></pre></p> <p>Remove the now-unused helper functions <code>contains</code> and <code>joinStrings</code> at the bottom of the file if nothing else references them. Verify with <code>make vet</code>.</p> <p>Step 2: Remove CORS tests from <code>internal/api/security_test.go</code></p> <p>Remove all test cases or sub-tests that set <code>CORS: models.CORSConfig{...}</code> on the test config or assert on <code>Access-Control-Allow-*</code> response headers. The <code>TestCORSHeaders</code> sub-test (around line 762) should be deleted entirely.</p> <p>For any test that builds a <code>models.Config</code> with a <code>Server.CORS</code> field, remove that field from the struct literal \u2014 the surrounding test itself may remain if it tests something else.</p> <p>Step 3: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS and no compilation errors.</p> <p>Step 4: Run vet to catch unused imports</p> <pre><code>make vet\n</code></pre> <p>Fix any unused imports (e.g., <code>fmt</code> if it was only used by <code>corsMiddleware</code>).</p> <p>Step 5: Commit</p> <pre><code>git add internal/api/routes.go internal/api/security_test.go\ngit commit -m \"feat: remove corsMiddleware and WithRateLimiter from router\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-5-add-deprecation-warning-for-stale-config-keys","title":"Task 5: Add deprecation warning for stale config keys","text":"<p>Files: - Modify: <code>internal/config/config.go</code> - Modify: <code>internal/config/config_test.go</code></p> <p>Step 1: Write the failing test first</p> <p>Add this test to <code>internal/config/config_test.go</code>:</p> <pre><code>func TestWarnDeprecatedKeys(t *testing.T) {\n    tests := []struct {\n        name     string\n        yaml     string\n        wantWarn []string\n    }{\n        {\n            name:     \"no deprecated keys\",\n            yaml:     \"server:\\n  port: 8080\\n\",\n            wantWarn: nil,\n        },\n        {\n            name:     \"cors key warns\",\n            yaml:     \"server:\\n  cors:\\n    enabled: true\\n\",\n            wantWarn: []string{\"server.cors\"},\n        },\n        {\n            name:     \"rate_limit key warns\",\n            yaml:     \"security:\\n  rate_limit:\\n    enabled: true\\n\",\n            wantWarn: []string{\"security.rate_limit\"},\n        },\n        {\n            name:     \"jwt_secret key warns\",\n            yaml:     \"security:\\n  jwt_secret: \\\"abc\\\"\\n\",\n            wantWarn: []string{\"security.jwt_secret\"},\n        },\n        {\n            name:     \"trusted_proxies key warns\",\n            yaml:     \"security:\\n  trusted_proxies:\\n    - \\\"10.0.0.1\\\"\\n\",\n            wantWarn: []string{\"security.trusted_proxies\"},\n        },\n        {\n            name: \"all deprecated keys warn\",\n            yaml: \"server:\\n  cors:\\n    enabled: true\\nsecurity:\\n  jwt_secret: \\\"x\\\"\\n  rate_limit:\\n    enabled: true\\n  trusted_proxies: []\\n\",\n            wantWarn: []string{\"server.cors\", \"security.jwt_secret\", \"security.rate_limit\", \"security.trusted_proxies\"},\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            var warnings []string\n            handler := slog.NewJSONHandler(io.Discard, &amp;slog.HandlerOptions{Level: slog.LevelWarn})\n            // Replace with a capturing handler\n            capturingHandler := &amp;capturingSlogHandler{warned: &amp;warnings}\n            logger := slog.New(capturingHandler)\n            orig := slog.Default()\n            slog.SetDefault(logger)\n            defer slog.SetDefault(orig)\n\n            _ = handler // suppress unused var\n\n            warnDeprecatedKeys([]byte(tt.yaml))\n\n            if len(tt.wantWarn) == 0 &amp;&amp; len(warnings) &gt; 0 {\n                t.Errorf(\"expected no warnings, got %v\", warnings)\n            }\n            for _, want := range tt.wantWarn {\n                found := false\n                for _, w := range warnings {\n                    if strings.Contains(w, want) {\n                        found = true\n                        break\n                    }\n                }\n                if !found {\n                    t.Errorf(\"expected warning containing %q, got %v\", want, warnings)\n                }\n            }\n        })\n    }\n}\n\n// capturingSlogHandler captures Warn-level log messages for testing.\ntype capturingSlogHandler struct {\n    warned *[]string\n}\n\nfunc (h *capturingSlogHandler) Enabled(_ context.Context, level slog.Level) bool {\n    return level &gt;= slog.LevelWarn\n}\n\nfunc (h *capturingSlogHandler) Handle(_ context.Context, r slog.Record) error {\n    *h.warned = append(*h.warned, r.Message)\n    return nil\n}\n\nfunc (h *capturingSlogHandler) WithAttrs(_ []slog.Attr) slog.Handler { return h }\nfunc (h *capturingSlogHandler) WithGroup(_ string) slog.Handler      { return h }\n</code></pre> <p>Add imports to <code>config_test.go</code> if missing: <code>\"context\"</code>, <code>\"io\"</code>, <code>\"log/slog\"</code>, <code>\"strings\"</code>.</p> <p>Step 2: Run the test to confirm it fails</p> <pre><code>make test\n</code></pre> <p>Expected: FAIL \u2014 <code>warnDeprecatedKeys</code> is not defined yet.</p> <p>Step 3: Implement <code>warnDeprecatedKeys</code> in <code>internal/config/config.go</code></p> <p>Add this type and function before <code>loadFromFile</code>:</p> <pre><code>// deprecatedConfig mirrors removed config fields for detecting stale operator configs.\ntype deprecatedConfig struct {\n    Server struct {\n        CORS interface{} `yaml:\"cors\"`\n    } `yaml:\"server\"`\n    Security struct {\n        JWTSecret      string      `yaml:\"jwt_secret\"`\n        TrustedProxies interface{} `yaml:\"trusted_proxies\"`\n        RateLimit      interface{} `yaml:\"rate_limit\"`\n    } `yaml:\"security\"`\n}\n\n// warnDeprecatedKeys logs a warning for each removed config key found in the YAML data.\n// The service continues to start normally \u2014 these keys are silently ignored by the main decoder.\nfunc warnDeprecatedKeys(data []byte) {\n    var dep deprecatedConfig\n    if err := yaml.Unmarshal(data, &amp;dep); err != nil {\n        return\n    }\n    if dep.Server.CORS != nil {\n        slog.Warn(\"Config key 'server.cors' is no longer supported; configure CORS at your reverse proxy. See docs/reverse-proxy.md.\")\n    }\n    if dep.Security.JWTSecret != \"\" {\n        slog.Warn(\"Config key 'security.jwt_secret' is no longer used and can be removed from your config file.\")\n    }\n    if dep.Security.TrustedProxies != nil {\n        slog.Warn(\"Config key 'security.trusted_proxies' is no longer supported; configure proxy trust at your reverse proxy. See docs/reverse-proxy.md.\")\n    }\n    if dep.Security.RateLimit != nil {\n        slog.Warn(\"Config key 'security.rate_limit' is no longer supported; configure rate limiting at your reverse proxy. See docs/reverse-proxy.md.\")\n    }\n}\n</code></pre> <p>Call it from <code>loadFromFile</code>, after reading the file and before unmarshaling into the main config:</p> <pre><code>func loadFromFile(config *models.Config, filePath string) error {\n    if _, err := os.Stat(filePath); os.IsNotExist(err) {\n        return fmt.Errorf(\"config file not found: %s\", filePath)\n    }\n    data, err := os.ReadFile(filePath)\n    if err != nil {\n        return fmt.Errorf(\"failed to read config file: %w\", err)\n    }\n    warnDeprecatedKeys(data)  // &lt;-- add this line\n    if err := yaml.Unmarshal(data, config); err != nil {\n        return fmt.Errorf(\"failed to parse YAML config: %w\", err)\n    }\n    return nil\n}\n</code></pre> <p>Step 4: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add internal/config/config.go internal/config/config_test.go\ngit commit -m \"feat: warn on deprecated config keys at startup\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-6-add-reverse-proxy-example-files-and-clean-up-existing-configs","title":"Task 6: Add reverse-proxy example files and clean up existing configs","text":"<p>Files: - Create: <code>examples/nginx/nginx.conf</code> - Create: <code>examples/nginx/docker-compose.yml</code> - Create: <code>examples/traefik/docker-compose.yml</code> - Modify: <code>docker/nginx/nginx.conf</code> - Modify: <code>examples/config.yaml</code> - Delete: <code>configs/security-examples.yaml</code> (entirely obsolete \u2014 uses removed config keys and old API key format)</p> <p>Step 1: Delete the obsolete security examples config</p> <pre><code>git rm configs/security-examples.yaml\n</code></pre> <p>Step 2: Create <code>examples/nginx/nginx.conf</code></p> <pre><code># Updater Service \u2014 nginx Reverse Proxy\n# Handles TLS termination, CORS, rate limiting, and real-IP forwarding.\n# The updater service runs on port 8080 and performs no TLS, CORS, or rate limiting itself.\n\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    sendfile on;\n    server_tokens off;\n\n    include /etc/nginx/mime.types;\n    default_type application/octet-stream;\n\n    # Rate limiting: two zones keyed on client IP.\n    # Adjust rates to match your traffic profile.\n    limit_req_zone $binary_remote_addr zone=api_anon:10m rate=60r/m;\n    limit_req_zone $binary_remote_addr zone=api_auth:10m rate=300r/m;\n\n    # Logging\n    log_format main '$remote_addr - [$time_local] \"$request\" $status \"$http_user_agent\"';\n    access_log /var/log/nginx/access.log main;\n    error_log  /var/log/nginx/error.log warn;\n\n    upstream updater {\n        server updater:8080;\n        keepalive 32;\n    }\n\n    # HTTP -&gt; HTTPS redirect\n    server {\n        listen 80;\n        server_name _;\n\n        location /.well-known/acme-challenge/ {\n            root /var/www/certbot;\n        }\n\n        location / {\n            return 301 https://$host$request_uri;\n        }\n    }\n\n    server {\n        listen 443 ssl http2;\n        server_name api.example.com;  # Replace with your domain\n\n        ssl_certificate     /etc/nginx/ssl/fullchain.pem;\n        ssl_certificate_key /etc/nginx/ssl/privkey.pem;\n        ssl_protocols       TLSv1.2 TLSv1.3;\n        ssl_prefer_server_ciphers off;\n        ssl_session_cache   shared:SSL:10m;\n        ssl_session_timeout 10m;\n\n        # Security headers\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always;\n        add_header X-Content-Type-Options    nosniff always;\n        add_header X-Frame-Options           DENY always;\n        add_header Referrer-Policy           \"strict-origin-when-cross-origin\" always;\n\n        # CORS \u2014 adjust allowed origins for your frontend domain(s)\n        add_header Access-Control-Allow-Origin  \"*\" always;\n        add_header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\" always;\n        add_header Access-Control-Allow-Headers \"Authorization, Content-Type\" always;\n        add_header Access-Control-Max-Age       86400 always;\n\n        # Health check (higher rate limit; no auth required)\n        location = /health {\n            limit_req zone=api_anon burst=10 nodelay;\n            proxy_pass         http://updater;\n            proxy_set_header   Host              $host;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n        }\n\n        # Public update-check endpoints (anonymous rate limit)\n        location ~ ^/api/v1/(updates|check|latest) {\n            if ($request_method = OPTIONS) { return 204; }\n            limit_req zone=api_anon burst=20 nodelay;\n            client_max_body_size 64k;\n            proxy_pass         http://updater;\n            proxy_set_header   Host              $host;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n            proxy_connect_timeout 5s;\n            proxy_read_timeout    10s;\n        }\n\n        # Authenticated API endpoints (higher rate limit)\n        location /api/ {\n            if ($request_method = OPTIONS) { return 204; }\n            limit_req zone=api_auth burst=50 nodelay;\n            client_max_body_size 1M;\n            proxy_pass         http://updater;\n            proxy_set_header   Host              $host;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n            proxy_connect_timeout 5s;\n            proxy_read_timeout    30s;\n        }\n\n        # Admin UI\n        location /admin/ {\n            limit_req zone=api_auth burst=20 nodelay;\n            proxy_pass         http://updater;\n            proxy_set_header   Host              $host;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n        }\n\n        location / {\n            return 404;\n        }\n    }\n}\n</code></pre> <p>Step 3: Create <code>examples/nginx/docker-compose.yml</code></p> <pre><code># Updater Service with nginx reverse proxy\n# Suitable for production deployments where TLS certificates are already present on the host.\n# Copy your fullchain.pem and privkey.pem into ./ssl/ before starting.\n#\n# Usage:\n#   cp /etc/letsencrypt/live/api.example.com/fullchain.pem ssl/\n#   cp /etc/letsencrypt/live/api.example.com/privkey.pem   ssl/\n#   UPDATER_BOOTSTRAP_KEY=$(openssl rand -base64 32) docker compose up -d\n\nservices:\n  updater:\n    image: ghcr.io/griffinskudder/updater:latest\n    environment:\n      UPDATER_BOOTSTRAP_KEY: \"${UPDATER_BOOTSTRAP_KEY}\"\n      UPDATER_ENABLE_AUTH: \"true\"\n      UPDATER_STORAGE_TYPE: \"sqlite\"\n      UPDATER_DATABASE_DSN: \"/data/updater.db\"\n      UPDATER_LOG_FORMAT: \"json\"\n    volumes:\n      - updater_data:/data\n    expose:\n      - \"8080\"\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"wget\", \"-qO-\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 5s\n      retries: 3\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n      - ./ssl:/etc/nginx/ssl:ro\n    depends_on:\n      updater:\n        condition: service_healthy\n    restart: unless-stopped\n\nvolumes:\n  updater_data:\n</code></pre> <p>Step 4: Create <code>examples/traefik/docker-compose.yml</code></p> <pre><code># Updater Service with Traefik v3 reverse proxy\n# Traefik handles TLS (Let's Encrypt), CORS middleware, and rate limiting via labels.\n#\n# Usage:\n#   Replace api.example.com and admin@example.com with your values.\n#   UPDATER_BOOTSTRAP_KEY=$(openssl rand -base64 32) docker compose up -d\n\nservices:\n  traefik:\n    image: traefik:v3\n    command:\n      - \"--providers.docker=true\"\n      - \"--providers.docker.exposedbydefault=false\"\n      - \"--entrypoints.web.address=:80\"\n      - \"--entrypoints.websecure.address=:443\"\n      - \"--entrypoints.web.http.redirections.entrypoint.to=websecure\"\n      - \"--entrypoints.web.http.redirections.entrypoint.scheme=https\"\n      - \"--certificatesresolvers.letsencrypt.acme.httpchallenge=true\"\n      - \"--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web\"\n      - \"--certificatesresolvers.letsencrypt.acme.email=admin@example.com\"\n      - \"--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json\"\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n      - \"traefik_certs:/letsencrypt\"\n    restart: unless-stopped\n\n  updater:\n    image: ghcr.io/griffinskudder/updater:latest\n    environment:\n      UPDATER_BOOTSTRAP_KEY: \"${UPDATER_BOOTSTRAP_KEY}\"\n      UPDATER_ENABLE_AUTH: \"true\"\n      UPDATER_STORAGE_TYPE: \"sqlite\"\n      UPDATER_DATABASE_DSN: \"/data/updater.db\"\n      UPDATER_LOG_FORMAT: \"json\"\n    volumes:\n      - updater_data:/data\n    expose:\n      - \"8080\"\n    restart: unless-stopped\n    labels:\n      - \"traefik.enable=true\"\n\n      # Router: HTTPS with Let's Encrypt\n      - \"traefik.http.routers.updater.rule=Host(`api.example.com`)\"\n      - \"traefik.http.routers.updater.entrypoints=websecure\"\n      - \"traefik.http.routers.updater.tls.certresolver=letsencrypt\"\n      - \"traefik.http.routers.updater.middlewares=updater-cors,updater-ratelimit,updater-security\"\n\n      # CORS middleware \u2014 adjust Access-Control-Allow-Origin for your frontend domain\n      - \"traefik.http.middlewares.updater-cors.headers.accesscontrolallowmethods=GET,POST,PUT,DELETE,OPTIONS\"\n      - \"traefik.http.middlewares.updater-cors.headers.accesscontrolalloworiginlist=*\"\n      - \"traefik.http.middlewares.updater-cors.headers.accesscontrolallowheaders=Authorization,Content-Type\"\n      - \"traefik.http.middlewares.updater-cors.headers.accesscontrolmaxage=86400\"\n\n      # Rate limit middleware (per IP; adjust average and burst to match your traffic)\n      - \"traefik.http.middlewares.updater-ratelimit.ratelimit.average=60\"\n      - \"traefik.http.middlewares.updater-ratelimit.ratelimit.burst=20\"\n      - \"traefik.http.middlewares.updater-ratelimit.ratelimit.period=1m\"\n\n      # Security headers\n      - \"traefik.http.middlewares.updater-security.headers.stsSeconds=31536000\"\n      - \"traefik.http.middlewares.updater-security.headers.stsIncludeSubdomains=true\"\n      - \"traefik.http.middlewares.updater-security.headers.contentTypeNosniff=true\"\n      - \"traefik.http.middlewares.updater-security.headers.frameDeny=true\"\n\nvolumes:\n  updater_data:\n  traefik_certs:\n</code></pre> <p>Step 5: Update <code>docker/nginx/nginx.conf</code></p> <p>Add CORS headers to the existing <code>location /api/</code> block:</p> <pre><code># CORS \u2014 the updater service does not set CORS headers itself\nadd_header Access-Control-Allow-Origin  \"*\" always;\nadd_header Access-Control-Allow-Methods \"GET, POST, PUT, DELETE, OPTIONS\" always;\nadd_header Access-Control-Allow-Headers \"Authorization, Content-Type\" always;\nadd_header Access-Control-Max-Age       86400 always;\n</code></pre> <p>Add before the <code>proxy_pass</code> line in the <code>/api/</code> location. Also add an OPTIONS preflight handler: <pre><code>if ($request_method = OPTIONS) {\n    return 204;\n}\n</code></pre></p> <p>Step 6: Update <code>examples/config.yaml</code></p> <p>Remove the <code>cors</code>, <code>rate_limit</code>, <code>trusted_proxies</code>, <code>jwt_secret</code>, and old <code>api_keys</code> sections. The file should become:</p> <pre><code># Example configuration for the updater service.\n# Rate limiting, CORS, and TLS are handled by the reverse proxy (see examples/nginx/ or examples/traefik/).\n\nserver:\n  port: 8080\n  host: \"0.0.0.0\"\n  read_timeout: 30s\n  write_timeout: 30s\n  idle_timeout: 60s\n\nstorage:\n  type: \"json\"\n  path: \"./data/releases.json\"\n  database:\n    driver: \"sqlite3\"\n    dsn: \"\"\n    max_open_conns: 25\n    max_idle_conns: 5\n    conn_max_lifetime: 300s\n    conn_max_idle_time: 300s\n\nsecurity:\n  enable_auth: true\n  bootstrap_key: \"${UPDATER_BOOTSTRAP_KEY}\"\n\nlogging:\n  level: \"info\"\n  format: \"json\"\n  output: \"stdout\"\n\ncache:\n  enabled: true\n  type: \"memory\"\n  ttl: 300s\n\nmetrics:\n  enabled: true\n  path: \"/metrics\"\n  port: 9090\n</code></pre> <p>Step 7: Run tests</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 8: Commit</p> <pre><code>git add examples/nginx/ examples/traefik/ docker/nginx/nginx.conf examples/config.yaml\ngit commit -m \"feat: add nginx and Traefik reverse proxy examples\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#task-7-update-documentation","title":"Task 7: Update documentation","text":"<p>Files: - Create: <code>docs/reverse-proxy.md</code> - Modify: <code>docs/SECURITY.md</code> - Modify: <code>docs/ARCHITECTURE.md</code> - Modify: <code>mkdocs.yml</code></p> <p>Step 1: Create <code>docs/reverse-proxy.md</code></p> <pre><code># Reverse Proxy\n\nThe updater service does not enforce CORS headers, rate limits, or TLS itself.\nThese concerns must be configured at the reverse proxy layer for every production deployment.\n\n## Why a reverse proxy?\n\nA reverse proxy (nginx, Traefik, Caddy, Cloudflare) provides these features with\nmore flexibility and less operational overhead than embedding them in the service:\n\n- TLS termination and certificate renewal (Let's Encrypt)\n- CORS header management per route and origin\n- Rate limiting with IP-based and token-bucket strategies\n- Security headers (HSTS, CSP, X-Frame-Options)\n- Load balancing across multiple service replicas\n\n## Example configurations\n\nReady-to-use configurations are provided in the `examples/` directory:\n\n| Directory | Proxy | What it provides |\n|-----------|-------|-----------------|\n| `examples/nginx/` | nginx | TLS (manual certs), CORS, rate limiting, security headers |\n| `examples/traefik/` | Traefik v3 | TLS (Let's Encrypt), CORS middleware, rate limiting, security headers |\n\nEach directory contains an `nginx.conf` or `docker-compose.yml` ready to use with minor substitution of your domain and certificate paths.\n\n## Real client IP in logs\n\nWhen running behind a proxy, `r.RemoteAddr` in the service will be the proxy's IP, not the client's IP.\nThe nginx and Traefik examples forward `X-Real-IP` and `X-Forwarded-For`. If you need the client IP in service logs, read the `X-Real-IP` header in your application or configure your proxy to replace `RemoteAddr` directly.\n\n## TLS\n\nBoth example configurations terminate TLS at the proxy and forward plain HTTP to the service on port 8080.\nDo not expose port 8080 directly to the internet.\n\n## Migrating from previous config\n\nIf your `config.yaml` contains any of the following keys, they are no longer used.\nThe service will log a warning on startup and continue running.\nRemove them from your config and configure the equivalent at your proxy instead.\n\n| Removed config key | Proxy equivalent |\n|--------------------|-----------------|\n| `server.cors` | `add_header Access-Control-*` (nginx) or `headers` middleware (Traefik) |\n| `security.rate_limit` | `limit_req_zone` (nginx) or `rateLimit` middleware (Traefik) |\n| `security.trusted_proxies` | Proxy trust is unconditional \u2014 remove this key |\n| `security.jwt_secret` | Not used \u2014 remove this key |\n</code></pre> <p>Step 2: Update <code>docs/SECURITY.md</code></p> <p>Remove the entire \"Rate Limiting\" configuration section (including the yaml block with <code>requests_per_hour</code>).</p> <p>Remove the CORS configuration section if present.</p> <p>Replace them with a short \"Proxy Layer\" section:</p> <pre><code>## Proxy Layer\n\nRate limiting, CORS, and TLS are enforced by the reverse proxy in front of the service.\nSee [Reverse Proxy](reverse-proxy.md) for nginx and Traefik configuration examples.\n</code></pre> <p>Step 3: Update <code>docs/ARCHITECTURE.md</code></p> <p>In the Security Features list under the API section, remove: - \"Configurable CORS with allowed origins, methods, and headers\" - \"Rate limiting: token bucket, two-tier (anonymous vs authenticated)\" - Any reference to <code>TrustedProxies</code> or <code>JWTSecret</code></p> <p>Add instead: - \"CORS, rate limiting, and TLS delegated to the reverse proxy layer\"</p> <p>In the Configuration section, remove the <code>server.cors</code> and <code>security.rate_limit</code> env var entries from the environment variables table.</p> <p>Step 4: Update <code>mkdocs.yml</code></p> <p>Add <code>reverse-proxy.md</code> to the nav. A sensible location is under the top-level section alongside <code>docs/storage.md</code>:</p> <pre><code>- Reverse Proxy: reverse-proxy.md\n</code></pre> <p>Step 5: Run tests (docs changes \u2014 no unit tests required)</p> <pre><code>make test\n</code></pre> <p>Expected: PASS.</p> <p>Step 6: Commit</p> <pre><code>git add docs/reverse-proxy.md docs/SECURITY.md docs/ARCHITECTURE.md mkdocs.yml\ngit commit -m \"docs: add reverse-proxy guide, remove CORS and rate-limit config docs\"\n</code></pre>"},{"location":"plans/2026-02-18-proxy-delegation-implementation/#final-verification","title":"Final verification","text":"<p>After all tasks, run the full check:</p> <pre><code>make check\n</code></pre> <p>Expected: fmt + vet + test all pass.</p> <p>Optionally validate the docs build:</p> <pre><code>make docs-build\n</code></pre> <p>Expected: openapi-validate + docs-generate + docs-db + MkDocs all pass with no broken links.</p> <p>Then open a PR from <code>feat/proxy-delegation</code> to <code>main</code>.</p>"},{"location":"plans/future-enhancements/","title":"Future Enhancements","text":"<p>This document tracks potential enhancements and improvements that could be made to the updater service. These are not currently planned for implementation but represent opportunities for future development.</p>"},{"location":"plans/future-enhancements/#version-metadata-enhancements","title":"Version Metadata Enhancements","text":"<p>Building on the version metadata feature implemented in February 2026, the following enhancements could further improve observability and user experience.</p>"},{"location":"plans/future-enhancements/#1-admin-ui-version-display","title":"1. Admin UI Version Display","text":"<p>Status: Not Implemented Priority: Low Effort: Small (1-2 hours)</p> <p>Description:</p> <p>Add build metadata display to the admin UI dashboard and footer.</p> <p>Benefits: - Administrators can quickly verify which version is deployed - Helpful for troubleshooting and deployment verification - Provides deployment environment visibility</p> <p>Implementation:</p> <p>Add to admin dashboard (<code>/admin</code>): <pre><code>&lt;div class=\"version-info\"&gt;\n  &lt;strong&gt;Version:&lt;/strong&gt; {{.Version}}\n  &lt;span class=\"commit\"&gt;({{.GitCommit}})&lt;/span&gt;\n  &lt;span class=\"build-date\"&gt;Built: {{.BuildDate}}&lt;/span&gt;\n  &lt;span class=\"environment\"&gt;Environment: {{.Environment}}&lt;/span&gt;\n&lt;/div&gt;\n</code></pre></p> <p>Add to admin footer (all admin pages): <pre><code>&lt;footer&gt;\n  &lt;p&gt;Updater Service v{{.Version}} | Instance: {{.InstanceID}}&lt;/p&gt;\n&lt;/footer&gt;\n</code></pre></p> <p>Files to modify: - <code>internal/api/handlers.go</code> - Pass version info to admin templates - <code>web/templates/admin/*.html</code> - Add version display elements - <code>web/static/css/admin.css</code> - Style version display</p> <p>Considerations: - Keep styling minimal and unobtrusive - Consider making it a collapsible info panel - Environment badge could use color coding (dev=blue, staging=yellow, production=green)</p>"},{"location":"plans/future-enhancements/#2-error-response-metadata","title":"2. Error Response Metadata","text":"<p>Status: Not Implemented Priority: Low Effort: Small (1-2 hours)</p> <p>Description:</p> <p>Include build metadata in error responses to help with debugging and support.</p> <p>Benefits: - Support teams can quickly identify which version produced an error - Easier correlation between error reports and deployed versions - Helpful for diagnosing version-specific issues</p> <p>Current error response: <pre><code>{\n  \"error\": \"application not found\",\n  \"details\": \"application 'myapp' does not exist\",\n  \"status\": 404\n}\n</code></pre></p> <p>Enhanced error response: <pre><code>{\n  \"error\": \"application not found\",\n  \"details\": \"application 'myapp' does not exist\",\n  \"status\": 404,\n  \"metadata\": {\n    \"version\": \"v1.0.0\",\n    \"instance_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"timestamp\": \"2026-02-21T10:30:00Z\"\n  }\n}\n</code></pre></p> <p>Files to modify: - <code>internal/models/response.go</code> - Add ErrorResponse metadata field - <code>internal/api/handlers.go</code> - Include version info in error responses - <code>internal/api/openapi/openapi.yaml</code> - Update error response schema</p> <p>Considerations: - Only include in error responses, not in success responses (avoid payload bloat) - Keep metadata minimal (version, instance_id, timestamp) - Document in OpenAPI spec - Consider making this optional via configuration flag</p>"},{"location":"plans/future-enhancements/#3-version-comparison-endpoint","title":"3. Version Comparison Endpoint","text":"<p>Status: Not Implemented Priority: Low Effort: Medium (3-4 hours)</p> <p>Description:</p> <p>Add a <code>/version/compare</code> endpoint that compares the service version with a provided version string.</p> <p>Benefits: - Client applications can verify server compatibility - Useful for multi-version API support - Helps with rolling deployments and gradual rollouts</p> <p>Example usage: <pre><code>curl http://localhost:8080/version/compare?version=v1.0.0\n</code></pre></p> <p>Response: <pre><code>{\n  \"server_version\": \"v1.2.0\",\n  \"client_version\": \"v1.0.0\",\n  \"compatible\": true,\n  \"comparison\": \"newer\",\n  \"details\": \"Server is 2 minor versions ahead\"\n}\n</code></pre></p> <p>Implementation:</p> <p>New endpoint in <code>internal/api/handlers.go</code>: <pre><code>func (h *Handlers) CompareVersion(w http.ResponseWriter, r *http.Request) {\n    clientVersion := r.URL.Query().Get(\"version\")\n    if clientVersion == \"\" {\n        h.writeErrorResponse(w, http.StatusBadRequest, \"version parameter required\")\n        return\n    }\n\n    result := version.Compare(h.versionInfo.Version, clientVersion)\n    h.writeJSONResponse(w, http.StatusOK, result)\n}\n</code></pre></p> <p>Files to modify: - <code>internal/version/version.go</code> - Add Compare() function using semver - <code>internal/api/handlers.go</code> - Add CompareVersion handler - <code>internal/api/routes.go</code> - Register <code>/version/compare</code> route - <code>internal/api/openapi/openapi.yaml</code> - Document endpoint</p> <p>Considerations: - Use semantic versioning rules for comparison - Handle non-semver versions gracefully - Define compatibility rules (e.g., major version must match) - Consider rate limiting this endpoint</p>"},{"location":"plans/future-enhancements/#4-deployment-history-tracking","title":"4. Deployment History Tracking","text":"<p>Status: Not Implemented Priority: Low Effort: Large (2-3 days)</p> <p>Description:</p> <p>Track deployment history by persisting version information to storage on startup, creating an audit trail of deployments.</p> <p>Benefits: - Historical record of what versions were deployed and when - Helps with deployment auditing and compliance - Useful for rollback planning and incident investigation</p> <p>Data model: <pre><code>type DeploymentRecord struct {\n    ID          string    `json:\"id\"`\n    Version     string    `json:\"version\"`\n    GitCommit   string    `json:\"git_commit\"`\n    BuildDate   string    `json:\"build_date\"`\n    InstanceID  string    `json:\"instance_id\"`\n    Hostname    string    `json:\"hostname\"`\n    Environment string    `json:\"environment\"`\n    StartTime   time.Time `json:\"start_time\"`\n    EndTime     *time.Time `json:\"end_time,omitempty\"`\n}\n</code></pre></p> <p>New endpoints: - <code>GET /api/v1/admin/deployments</code> - List deployment history - <code>GET /api/v1/admin/deployments/current</code> - Show currently running instances</p> <p>Implementation considerations: - Add deployment_history table to database schema - Record deployment on service startup - Mark deployment as ended on graceful shutdown - Handle multiple concurrent instances (Kubernetes deployments) - Add retention policy (e.g., keep last 100 deployments or 90 days) - Require admin permission for access</p> <p>Files to modify: - <code>internal/storage/schema/*/002_deployment_history.sql</code> - New migration - <code>internal/storage/queries/*/deployments.sql</code> - CRUD queries - <code>internal/models/deployment.go</code> - DeploymentRecord model - <code>cmd/updater/updater.go</code> - Record deployment on startup - <code>internal/api/handlers.go</code> - Deployment history endpoints - <code>internal/api/routes.go</code> - Register new routes - <code>internal/api/openapi/openapi.yaml</code> - Document endpoints</p> <p>Storage considerations: - Not needed for memory or JSON storage (ephemeral) - PostgreSQL and SQLite only - Add index on start_time for efficient queries</p>"},{"location":"plans/future-enhancements/#5-build-metadata-in-metrics","title":"5. Build Metadata in Metrics","text":"<p>Status: Not Implemented Priority: Low Effort: Small (1 hour)</p> <p>Description:</p> <p>Add a Prometheus <code>build_info</code> metric with version metadata as labels.</p> <p>Benefits: - Version information queryable via Prometheus - Correlate metrics with specific versions - Alert on version changes or mismatches in a cluster</p> <p>Implementation:</p> <p>Add to <code>internal/observability/observability.go</code>: <pre><code>func (p *Provider) registerBuildInfo(ver version.Info) {\n    meter := p.meterProvider.Meter(\"updater\")\n\n    buildInfo, _ := meter.Int64ObservableGauge(\n        \"build_info\",\n        metric.WithDescription(\"Build and version information\"),\n    )\n\n    _, _ = meter.RegisterCallback(\n        func(ctx context.Context, o metric.Observer) error {\n            o.ObserveInt64(buildInfo, 1,\n                metric.WithAttributes(\n                    attribute.String(\"version\", ver.Version),\n                    attribute.String(\"git_commit\", ver.GitCommit),\n                    attribute.String(\"build_date\", ver.BuildDate),\n                ))\n            return nil\n        },\n        buildInfo,\n    )\n}\n</code></pre></p> <p>Prometheus query example: <pre><code>build_info{version=\"v1.0.0\"}\n</code></pre></p> <p>Files to modify: - <code>internal/observability/observability.go</code> - Add registerBuildInfo() call</p> <p>Considerations: - This is a gauge that always returns 1 with labels - Standard pattern used by many projects (Kubernetes, Prometheus itself) - Useful for Grafana dashboards showing deployed versions</p>"},{"location":"plans/future-enhancements/#implementation-priority","title":"Implementation Priority","text":"<p>If implementing these enhancements, the recommended order is:</p> <ol> <li>Build Metadata in Metrics (1 hour) - Highest value, lowest effort</li> <li>Admin UI Version Display (1-2 hours) - Visible, useful for operators</li> <li>Error Response Metadata (2 hours) - Helpful for debugging</li> <li>Version Comparison Endpoint (3-4 hours) - Useful for client compatibility</li> <li>Deployment History Tracking (2-3 days) - Most complex, consider if needed</li> </ol>"},{"location":"plans/future-enhancements/#related-documentation","title":"Related Documentation","text":"<ul> <li>ARCHITECTURE.md - Version package architecture</li> <li>observability.md - Resource attributes and build metadata</li> <li>logging.md - Global log fields</li> </ul>"}]}