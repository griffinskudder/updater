// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: releases.sql

package sqlcpg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRelease = `-- name: CreateRelease :exec
INSERT INTO releases (
    id, application_id, version, platform, architecture, download_url,
    checksum, checksum_type, file_size, release_notes, release_date,
    required, minimum_version, metadata, created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateReleaseParams struct {
	ID             string             `json:"id"`
	ApplicationID  string             `json:"application_id"`
	Version        string             `json:"version"`
	Platform       string             `json:"platform"`
	Architecture   string             `json:"architecture"`
	DownloadUrl    string             `json:"download_url"`
	Checksum       string             `json:"checksum"`
	ChecksumType   string             `json:"checksum_type"`
	FileSize       int64              `json:"file_size"`
	ReleaseNotes   pgtype.Text        `json:"release_notes"`
	ReleaseDate    pgtype.Timestamptz `json:"release_date"`
	Required       bool               `json:"required"`
	MinimumVersion pgtype.Text        `json:"minimum_version"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateRelease(ctx context.Context, arg CreateReleaseParams) error {
	_, err := q.db.Exec(ctx, createRelease,
		arg.ID,
		arg.ApplicationID,
		arg.Version,
		arg.Platform,
		arg.Architecture,
		arg.DownloadUrl,
		arg.Checksum,
		arg.ChecksumType,
		arg.FileSize,
		arg.ReleaseNotes,
		arg.ReleaseDate,
		arg.Required,
		arg.MinimumVersion,
		arg.Metadata,
		arg.CreatedAt,
	)
	return err
}

const deleteRelease = `-- name: DeleteRelease :exec
DELETE FROM releases
WHERE application_id = $1 AND version = $2 AND platform = $3 AND architecture = $4
`

type DeleteReleaseParams struct {
	ApplicationID string `json:"application_id"`
	Version       string `json:"version"`
	Platform      string `json:"platform"`
	Architecture  string `json:"architecture"`
}

func (q *Queries) DeleteRelease(ctx context.Context, arg DeleteReleaseParams) error {
	_, err := q.db.Exec(ctx, deleteRelease,
		arg.ApplicationID,
		arg.Version,
		arg.Platform,
		arg.Architecture,
	)
	return err
}

const getRelease = `-- name: GetRelease :one
SELECT id, application_id, version, platform, architecture, download_url,
       checksum, checksum_type, file_size, release_notes, release_date,
       required, minimum_version, metadata, created_at
FROM releases
WHERE application_id = $1 AND version = $2 AND platform = $3 AND architecture = $4
`

type GetReleaseParams struct {
	ApplicationID string `json:"application_id"`
	Version       string `json:"version"`
	Platform      string `json:"platform"`
	Architecture  string `json:"architecture"`
}

func (q *Queries) GetRelease(ctx context.Context, arg GetReleaseParams) (Release, error) {
	row := q.db.QueryRow(ctx, getRelease,
		arg.ApplicationID,
		arg.Version,
		arg.Platform,
		arg.Architecture,
	)
	var i Release
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.Version,
		&i.Platform,
		&i.Architecture,
		&i.DownloadUrl,
		&i.Checksum,
		&i.ChecksumType,
		&i.FileSize,
		&i.ReleaseNotes,
		&i.ReleaseDate,
		&i.Required,
		&i.MinimumVersion,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getReleaseByID = `-- name: GetReleaseByID :one
SELECT id, application_id, version, platform, architecture, download_url,
       checksum, checksum_type, file_size, release_notes, release_date,
       required, minimum_version, metadata, created_at
FROM releases
WHERE id = $1
`

func (q *Queries) GetReleaseByID(ctx context.Context, id string) (Release, error) {
	row := q.db.QueryRow(ctx, getReleaseByID, id)
	var i Release
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.Version,
		&i.Platform,
		&i.Architecture,
		&i.DownloadUrl,
		&i.Checksum,
		&i.ChecksumType,
		&i.FileSize,
		&i.ReleaseNotes,
		&i.ReleaseDate,
		&i.Required,
		&i.MinimumVersion,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const getReleasesByAppID = `-- name: GetReleasesByAppID :many
SELECT id, application_id, version, platform, architecture, download_url,
       checksum, checksum_type, file_size, release_notes, release_date,
       required, minimum_version, metadata, created_at
FROM releases
WHERE application_id = $1
ORDER BY release_date DESC
`

func (q *Queries) GetReleasesByAppID(ctx context.Context, applicationID string) ([]Release, error) {
	rows, err := q.db.Query(ctx, getReleasesByAppID, applicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Release{}
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Platform,
			&i.Architecture,
			&i.DownloadUrl,
			&i.Checksum,
			&i.ChecksumType,
			&i.FileSize,
			&i.ReleaseNotes,
			&i.ReleaseDate,
			&i.Required,
			&i.MinimumVersion,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReleasesByPlatformArch = `-- name: GetReleasesByPlatformArch :many
SELECT id, application_id, version, platform, architecture, download_url,
       checksum, checksum_type, file_size, release_notes, release_date,
       required, minimum_version, metadata, created_at
FROM releases
WHERE application_id = $1 AND platform = $2 AND architecture = $3
ORDER BY release_date DESC
`

type GetReleasesByPlatformArchParams struct {
	ApplicationID string `json:"application_id"`
	Platform      string `json:"platform"`
	Architecture  string `json:"architecture"`
}

func (q *Queries) GetReleasesByPlatformArch(ctx context.Context, arg GetReleasesByPlatformArchParams) ([]Release, error) {
	rows, err := q.db.Query(ctx, getReleasesByPlatformArch, arg.ApplicationID, arg.Platform, arg.Architecture)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Release{}
	for rows.Next() {
		var i Release
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.Version,
			&i.Platform,
			&i.Architecture,
			&i.DownloadUrl,
			&i.Checksum,
			&i.ChecksumType,
			&i.FileSize,
			&i.ReleaseNotes,
			&i.ReleaseDate,
			&i.Required,
			&i.MinimumVersion,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRelease = `-- name: UpdateRelease :exec
UPDATE releases
SET download_url = $2, checksum = $3, checksum_type = $4, file_size = $5,
    release_notes = $6, release_date = $7, required = $8, minimum_version = $9, metadata = $10
WHERE id = $1
`

type UpdateReleaseParams struct {
	ID             string             `json:"id"`
	DownloadUrl    string             `json:"download_url"`
	Checksum       string             `json:"checksum"`
	ChecksumType   string             `json:"checksum_type"`
	FileSize       int64              `json:"file_size"`
	ReleaseNotes   pgtype.Text        `json:"release_notes"`
	ReleaseDate    pgtype.Timestamptz `json:"release_date"`
	Required       bool               `json:"required"`
	MinimumVersion pgtype.Text        `json:"minimum_version"`
	Metadata       []byte             `json:"metadata"`
}

func (q *Queries) UpdateRelease(ctx context.Context, arg UpdateReleaseParams) error {
	_, err := q.db.Exec(ctx, updateRelease,
		arg.ID,
		arg.DownloadUrl,
		arg.Checksum,
		arg.ChecksumType,
		arg.FileSize,
		arg.ReleaseNotes,
		arg.ReleaseDate,
		arg.Required,
		arg.MinimumVersion,
		arg.Metadata,
	)
	return err
}
